:toc-title: On this page:
:toc: auto
:toclevels: 5
:experimental:
:sectnums:
:sectnumlevels: 5
:sectanchors:
:sectlinks:
:partnums:

//= Ієрархічна модель
= Hierarchical model

== Overview

//Платформа реєстрів надає можливість побудувати ієрархічну модель доступу до об'єктів даних відповідно до рівнів ієрархічної структури та ролей користувачів. Це дозволяє забезпечити контроль над доступом до об'єктів на основі їх ієрархічного положення та ролі користувача.
The Platform for state registries enables you to build a hierarchical model where access to data objects corresponds to the hierarchy structure levels and user roles. This way, you can control access to objects based on their hierarchical position and the user's role.

//У цій ієрархічній моделі кожен підрозділ має унікальний код -- `structure_code`, який ідентифікує його в рамках системи. Крім того, використовується сурогатний ключ -- `hierarchy_code`, який формується шляхом конкатенації коду підрозділу та коду кожного батьківського рівня в ієрархії. Наприклад, `101.202.303` -- сурогатний ключ для доступу до об'єктів підрозділу третього рівня в ієрархії.
In the hierarchical model, each unit has a unique code (`structure_code`) that identifies it within the system. In addition, the system uses a surrogate key (`hierarchy_code`), which is formed by concatenating the unit code and the code of each parent level in the hierarchy. For example, `101.202.303` is a surrogate key for accessing the objects of the third-level subdivision in the hierarchy.

//Приналежність користувача до вузла ієрархії визначається за допомогою атрибута `hierarchy_code` у системі управління користувачами *Keycloak*. Цей атрибут має збігатися із сурогатним ключем для підрозділу у БД реєстру та використовується для належного призначення ролей та обмежень доступу користувача до відповідних рівнів ієрархії.
The `hierarchy_code` attribute in the *Keycloak* user management system determines the user's affiliation with a hierarchy node. This attribute must match the unit's surrogate key in the registry database. This way, you can correctly assign roles and restrict user access to the corresponding hierarchy levels.

//NOTE: Важливо зазначити, що *`hierarchy_code`* є обов'язковим атрибутом посадової особи у системі *Keycloak*, якщо така особа має виконувати функції в межах ієрархічної структури. Це дозволяє точно визначити приналежність та обмеження доступу для кожної посадової особи.
NOTE: It is important to note that *`hierarchy_code`* is a mandatory attribute for officers in the *Keycloak* system if such a person is to perform functions within the hierarchical structure. This allows you to determine each officer's affiliation and access restrictions accurately.

//Присвоєння атрибута ієрархії користувачам у Keycloak може бути здійснено безпосередньо в інтерфейсі самого сервісу або шляхом імпорту даних з CSV-файлу.
You can assign the hierarchy attribute to users directly in the Keycloak service interface or by importing data from a CSV file.

//Для ефективного керування та виконання завдань в рамках ієрархічної структури та управління персоналом, що працює за такою моделлю, передбачено декілька ролей:
The following roles are provided to make working within the hierarchical structure and managing personnel using this model more effective:

//* `hierarchy-registry-manager` -- керівник реєстру (посадова особа), відповідальна за керування ієрархічною структурою реєстру.
* `hierarchy-registry-manager`: Registry manager; an officer responsible for managing the hierarchical structure of the registry.
//* `hierarchy-registry-user` -- користувач реєстру (посадова особа), яка має доступ до ієрархічної структури та може виконувати завдання відповідно до своїх повноважень.
* `hierarchy-registry-user`: Registry user; an officer who has access to the hierarchical structure and can perform tasks within their authority.
//* `personnel-officer-admin` -- кадровик, посадова особа, відповідальна за управління персоналом, включаючи призначення та зміну ролей інших посадових осіб в межах своїх повноважень.
* `personnel-officer-admin`: Personnel officer; an officer responsible for personnel management, including appointing and updating roles of other officers.
//* `officer-moderator` -- модератор процесу автореєстрації посадових осіб у реєстрі, відповідальний за перевірку та схвалення запитів на реєстрацію нових користувачів.
* `officer-moderator`: Moderator; an officer who moderates the process of officers' auto-registration in the registry. A moderator is responsible for checking and approving registration requests from new users.

//Ці ролі допомагають забезпечити ефективну роботу та контроль над ієрархічною структурою реєстру, а також управління персоналом, забезпечуючи належну організацію та доступ до даних.
These roles are meant to help you control the hierarchical structure of your registry, manage personnel, and ensure proper organization and data access.

//== План дій з використання ієрархічної моделі у реєстрі
== Action plan for using a hierarchical model in the registry

//Скористайтеся наступним планом дій для налаштування та використання ієрархічної моделі у реєстрі:
Use the following roadmap to set up and use the hierarchical model in the registry:

[%interactive]
//* [ ] Використовуйте референтні приклади моделювання регламенту. Для цього розгорніть власний демо-реєстр.
* [ ] Use reference examples of regulations modeling. Deploy your copy of the registry demo.
//** Як розгорнути демо-реєстр та отримати референтні приклади моделювання регламенту, дивіться на сторінці xref:registry-admin/cp-deploy-consent-data.adoc[].
** For details on deploying a registry demo and getting regulations modeling samples, see xref:registry-admin/cp-deploy-consent-data.adoc[].
//** Приклади референтної моделі даних, бізнес-процесів та UI-форм доступні у файлах регламенту за відповідними назвами із префіксом *`reference-`* або у теках *_reference_*, якщо є декілька згрупованих прикладів моделювання.
** Samples of the reference data model, business processes, and UI forms are available in the regulations files with a *`reference-`* prefix or in the *_reference_* folders if there are several grouped modeling examples.

//* [ ] xref:#hierarchy-structure[Побудуйте власну ієрархічну структуру]
* [ ] xref:#hierarchy-structure[Build your hierarchical structure].
//* [ ] xref:#build-data-model[Створіть модель даних]
* [ ] xref:#build-data-model[Create a data model].
//* [ ] xref:#rls-rules[Створіть RLS-правила для доступу до даних за ієрархічною моделлю]
* [ ] xref:#rls-rules[Create RLS rules to access data in the hierarchical model].
//* [ ] xref:#inital-data-load[Наповніть таблиці-довідники даними]
* [ ] xref:#inital-data-load[Fill the reference tables with data].
//* [ ] xref:#create-users[Створіть користувачів у реєстрі]
* [ ] xref:#create-users[Create registry users].
//* [ ] xref:#bp-modeling[Змоделюйте бізнес-процеси]
* [ ] xref:#bp-modeling[Model the business processes].

[#hierarchy-structure]
//== Побудова ієрархічної структури
== Building the hierarchy structure

//. Продумайте та створіть ієрархічну структуру, що складається з декількох рівнів (вузлів). Назвемо їх підрозділами.
. Plan and create a hierarchical structure consisting of several levels and nodes. Let's call them units.
//. Призначте кожному такому підрозділу власний унікальний код ієрархії -- *`structure_code`*.
. Assign a unique hierarchy code (*`structure_code`*) to each unit.
//._Референтний приклад ієрархічної структури підрозділів_
+
[%collapsible]
._A reference example of a hierarchical structure_
====
[plantuml]
----
@startsalt
{
  {T
    + **Ministry of Economy of Ukraine (Code: 101)**
    ++ Department of Trade Agreements and Export Development (Code: 201)
    ++ Division of Public Policy in the field of Public Material Reserve (Code: 202)
    ++ Department of Labor and Employment (Code: 203)
        +++ Department of Labor (Code: 301)
        +++ Department of Industry and High-Risk Facilities Supervision (Code: 302)
  }
  {T
    + **Ministry of Digital Transformation of Ukraine (Code: 102)**
    ++ State Center of Informational Resources of Ukraine (Code: 204)
    ++ State Enterprise "Diia" (Code: 205)
  }
  {T
    + **Ministry of Internal Affairs of Ukraine (Code: 103)**
    ++ National Police of Ukraine (Code: 206)
    ++ State Border Guard Service of Ukraine (Code: 207)
    ++ State Migration Service of Ukraine (Code: 208)
        +++ Office for Management of Places of Temporary Aaccommodation of Foreigners (Code: 303)
        +++ Office for Management of Places of Temporary Accommodation of Refugees (Code: 304)
    ++ State Emergency Service of Ukraine (Code: 209)
  }
  {T
    + **Ministry of Communities and Territories Development of Ukraine (Code: 104)**
    ++ State Agency for Tourism Development of Ukraine (Code: 210)
    ++ State Agency on Energy Efficiency and Energy Saving of Ukraine (Code: 211)
    ++ State Aviation Administration of Ukraine (Code: 212)
    ++ State Service for Maritime, Inland Waterway Transport and Shipping of Ukraine (Code: 213)
    ++ State Service of Ukraine for Transport Safety (Code: 214)
    ++ State Agency for Reconstruction and Development of Infrastructure of Ukraine (Code: 215)
        +++ Department of Restoration of Infrastructure of Ukraine (Code: 305)
        +++ Department of Development of Infrastructure of Ukraine (Code: 306)
            ++++ Office of Infrastructure Development of Ukraine (Code: 401)
  }
}
@endsalt
----
====
+
[%collapsible]
._Table 1. Matching structure_code with hierarchy_code_
====
|===
|Unit name |Unit code (structure_code) |Surrogate key (hierarchy_code) |Note

|Ministry of Economy of Ukraine
|101
|101
|Hierarchy root node

|Department of Trade Agreements and Export Development
|201
|101.201
|

|Division of Public Policy in the field of Public Material Reserve
|202
|101.202
|

|Department of Labor and Employment
|203
|101.203
|

|Department of Labor
|301
|101.203.301
|

|Department of Industry and High-Risk Facilities Supervision
|302
|101.203.302
|

|Ministry of Digital Transformation of Ukraine
|102
|102
|Hierarchy root node

|State Center of Informational Resources of Ukraine
|204
|102.204
|

|State Enterprise "Diia"
|205
|102.205
|

|Ministry of Internal Affairs of Ukraine
|103
|103
|Hierarchy root node

|National Police of Ukraine
|206
|103.206
|

|State Border Guard Service of Ukraine
|207
|103.207
|

|State Migration Service of Ukraine
|208
|103.208
|

|Office for Management of Places of Temporary Accommodation of Foreigners
|303
|103.208.303
|

|Office for Management of Places of Temporary Accommodation of Refugees
|304
|103.208.304
|

|State Emergency Service of Ukraine
|209
|103.209
|

|Ministry of Communities and Territories Development of Ukraine
|104
|104
|Hierarchy root node

|State Agency for Tourism Development of Ukraine
|210
|104.210
|

|State Agency on Energy Efficiency and Energy Saving of Ukraine
|211
|104.211
|

|State Aviation Administration of Ukraine
|212
|104.212
|

|State Service for Maritime, Inland Waterway Transport and Shipping of Ukraine
|213
|104.213
|

|State Service of Ukraine for Transport Safety
|214
|104.214
|

|State Agency for Reconstruction and Development of Infrastructure of Ukraine
|215
|104.215
|

|Department of Restoration of Infrastructure of Ukraine
|305
|104.215.305
|

|Department of Development of Infrastructure of Ukraine
|306
|104.215.306
|

|Office of Infrastructure Development of Ukraine
|401
|104.215.306.401
|
|===
====

[#build-data-model]
//== Створення моделі даних
== Building the data model

//. Продумайте та створіть логічну модель даних для своєї xref:hierarchy-structure[ієрархічної структури]. Ми пропонуємо як приклад наступну структуру таблиць:
. Plan and create a logical data model for your xref:hierarchy-structure[hierarchical structure]. As an example, consider the following table structure:
//.ERD-діаграма логічної моделі на базі референтної структури
+
.An ERD diagram of the logical model based on the reference structure
[plantuml]
----
@startuml

!define table(x) class x << (T,#FFAAAA) >>
!define primary_key(x) <u>x</u>
!define foreign_key(x) <b>x</b>

hide methods
hide stereotypes

table(officers) {
  officers_id UUID
  user_name TEXT
  full_name TEXT
  drfo TEXT
  edrpou TEXT
  realm_roles TEXT
  work_start_date DATE
  unit_name TEXT
  hierarchy_code TEXT
  structure_code TEXT
  selfregistration_decision BOOLEAN
  --
  primary_key(officers_id)
}

table(unit) {
  id UUID
  unit_name VARCHAR(255)
  structure_code VARCHAR(255)
  hierarchy_code VARCHAR(255)
  --
  primary_key(id)
}

table(document_registration) {
  id UUID
  name TEXT
  unit_id UUID
  --
  primary_key(id)
  foreign_key(unit_id)
}

officers }--|| unit : unit_name
document_registration }--|| unit : unit_id

@enduml

----
//._Пояснення до структури таблиць референтної ієрархічної моделі_
+
._Notes on the table structure of the reference hierarchical model_
[%collapsible]
====
//* Таблиця `officers` -- містить інформацію про посадових осіб, їх ролі, ідентифікаційні дані та приналежність до певних підрозділів:
* The `officers` table contains information about officers, their roles, identification data, and affiliation with specific units:
+
//- `officers_id`: унікальний ідентифікатор посадової особи (тип `UUID`).
** `officers_id`: A unique officer ID (`UUID` type).
//- `user_name`: ім'я користувача в Keycloak (тип `TEXT`).
** `user_name`: User's name in Keycloak (`TEXT` type).
//- `full_name`: ПІБ користувача (тип `TEXT`).
** `full_name`: User's full name (`TEXT` type).
//- `drfo`: РНОКПП користувача (тип `TEXT`).
** `drfo`: User's RNOKPP code (`TEXT` type).
//- `edrpou`: ЄДРПОУ користувача (тип `TEXT`).
** `edrpou`: User's EDRPOU code (`TEXT` type).
//- `realm_roles`: перелік регламентних ролей користувача (тип `TEXT`).
** `realm_roles`: A list of user's regulations roles (`TEXT` type).
//- `work_start_date`: дата прийняття на роботу (тип `DATE`).
** `work_start_date`: Work start date (`DATE` type).
//- `unit_name`: назва підрозділу згідно з ієрархією (тип `TEXT`).
** `unit_name`: Unit's name in the hierarchy (`TEXT` type).
//- `hierarchy_code`: сурогатний ключ, складений на основі `structure_code` шляхом конкатенації (тип `TEXT`).
** `hierarchy_code`: A surrogate key based on `structure_code` using concatenation (`TEXT` type).
//- `structure_code`: унікальний код ієрархії для відповідного підрозділу (тип `TEXT`).
** `structure_code`: A unique hierarchy code of a corresponding unit (`TEXT` type).
//- `selfregistration_decision`: рішення модератора щодо самореєстрації (тип `BOOLEAN`).
** `selfregistration_decision`: Moderator's decision on self-registration (`BOOLEAN` type).
+
//* Таблиця `unit` -- містить інформацію про підрозділи:
* The `unit` table contains information about units:
+
//- `id`: унікальний ідентифікатор підрозділу (тип `UUID`).
** `id`: A unique unit ID (`UUID` type).
//- `unit_name`: назва підрозділу згідно з ієрархією (тип `VARCHAR(255)`).
** `unit_name`: Unit's name in the hierarchy (`VARCHAR(255)` type).
//- `structure_code`: унікальний код ієрархії для відповідного підрозділу (тип `VARCHAR(255)`).
** `structure_code`: A unique hierarchy code of a corresponding unit (`VARCHAR(255) type`).
//- `hierarchy_code`: сурогатнийй ключ, складений на основі `structure_code` (тип `VARCHAR(255)`).
** `hierarchy_code`: A surrogate key based on `structure_code` (`VARCHAR(255)` type).
+
//* Таблиця `document_registration` -- містить інформацію про документи, асоційовані з певним підрозділом (`unit`):
* The `document_registration` table contains information about the documents associated with a specific unit:
+
//- `id`: унікальний ідентифікатор документа (тип UUID).
** `id`: A unique document ID (`UUID` type).
//- `name`: назва документа (тип TEXT).
** `name`: Document name (`TEXT` type).
//- `unit_id`: зв'язок із підрозділом, до якого належить документ. Це відповідає ідентифікатору в таблиці `unit` (тип `UUID`).
** `unit_id`: The ID of the unit to which the document belongs. This corresponds to the ID in the `unit` table (`UUID` type).

//Зауважте, що всі UUID-поля використовують функцію `uuid_generate_v4()` для створення унікальних значень за замовчуванням.
Note that all UUID fields use the `uuid_generate_v4()` function to generate unique default values.
====
+
//. Створіть фізичну модель даних на основі вашої логічної моделі.
. Create a physical data model based on your logical model.
//.Фізична модель даних для ієрархічної структури підрозділів у реєстрі
+
.A physical data model for the hierarchical structure of units in the registry
====
[%collapsible]
.The "officers" table
=====
[source,xml]
----
<changeSet author="registry owner" id="table officers">
    <createTable tableName="officers" ext:historyFlag="true" remarks="A list of officers">
        <column name="officers_id" type="UUID" defaultValueComputed="uuid_generate_v4()">
            <constraints nullable="false" primaryKey="true" primaryKeyName="pk_officers_id"/>
        </column>
        <column name="user_name" type="TEXT" remarks="Keycloak username">
            <constraints nullable="false"/>
        </column>
        <column name="full_name" type="TEXT" remarks="User's full name">
            <constraints nullable="false"/>
        </column>
        <column name="drfo" type="TEXT" remarks="User's RNOKPP code">
            <constraints nullable="false"/>
        </column>
        <column name="edrpou" type="TEXT" remarks="User's EDRPOU code">
            <constraints nullable="false"/>
        </column>
        <column name="realm_roles" type="TEXT" remarks="A list of user's regulations roles"/>
        <column name="work_start_date" type="DATE" remarks="Work start date"/>
        <column name="unit_name" type="TEXT" remarks="Unit's name in the hierarchy"/>
        <column name="hierarchy_code" type="TEXT" remarks="A surrogate key based on structure_code"/>
        <column name="structure_code" type="TEXT" remarks="A unique hierarchy code of a corresponding unit"/>
        <column name="selfregistration_decision" type="BOOLEAN" remarks="Moderator's decision on self-registration"/>
    </createTable>
</changeSet>
----
=====

[%collapsible]
.The "unit" table
=====
[source,xml]
----
<changeSet id="24569-1" author="ek">
    <comment>CREATE TABLE unit</comment>
    <createTable tableName="unit" ext:historyFlag="true">
      <column name="id" type="UUID" defaultValueComputed="uuid_generate_v4()">
        <constraints
          nullable="false"
          primaryKey="true"
          primaryKeyName="pk_unit_id"/>
      </column>
      <column name="unit_name" type="VARCHAR(255)" remarks="Unit's name in the hierarchy">
        <constraints nullable="false"/>
      </column>
      <column name="structure_code" type="VARCHAR(255)"
        remarks="A hierarchy code of a corresponding unit">
        <constraints
          nullable="false"
          unique="true"/>
      </column>
      <column name="hierarchy_code" type="VARCHAR(255)"
        remarks="A surrogate key based on structure_code">
        <constraints
          nullable="false"
          unique="true"/>
      </column>
    </createTable>
</changeSet>
----
=====

[%collapsible]
.The "document_registration" table
=====
[source,xml]
----
<changeSet id="24569-2" author="ek">
    <comment>CREATE TABLE document_registration</comment>
    <createTable tableName="document_registration" ext:historyFlag="true">
      <column name="id" type="UUID" defaultValueComputed="uuid_generate_v4()">
        <constraints
          nullable="false"
          primaryKey="true"
          primaryKeyName="pk_document_registration_id"/>
      </column>
      <column name="name" type="TEXT" remarks="Document name">
        <constraints nullable="false"/>
      </column>
      <column name="unit_id" type="UUID">
        <constraints
          nullable="false"
          foreignKeyName="fk_document_registration_unit_id"
          referencedTableName="unit"
          referencedColumnNames="id"/>
      </column>
    </createTable>
</changeSet>
----
=====

====
+
[NOTE]
====
//* При створенні нової структури, таблиця з організаційною структурою може бути створена одразу при розгортанні регламенту, але мінімум один "батьківський" вузол в ієрархії повинен бути створений.
//TODO: Can we clarify this sentence a bit or split it into two?
* When creating a new structure, you can create the table with the organizational structure when deploying the regulations, but at least one parent node in the hierarchy must be created.
//* При створенні заявки, до неї автоматично додається код ієрархії - сурогатний ключ ініціатора БП.
* When an application is created, a hierarchy code with a surrogate key of the BP initiator is automatically added to it.
====

[#rls-rules]
//== Створення RLS-правил для доступу до даних
== Creating RLS rules for data access

//*RLS*-правила (*Row-Level Security*) використовуються для контролю доступу до рядків даних у БД. В нашій ієрархічній моделі RLS-правила використовуються для обмеження доступу користувачів до об'єктів даних залежно від їх приналежності до певного рівня ієрархії.
*RLS* (Row-Level Security) rules are used to control access to data rows in the database. In our hierarchical model, RLS rules restrict user access to data objects depending on the hierarchy level these objects belong to.

//Кожне RLS-правило перевіряє значення атрибута `hierarchy_code` в JWT користувача та порівнює зі значеннями стовпця `hierarchy_code` в певній таблиці бази даних. Якщо значення збігаються, то користувач отримує доступ до відповідних об'єктів даних.
Each RLS rule checks the value of the `hierarchy_code` attribute in the user's JWT (JSON Web Token) and compares it to the values of the `hierarchy_code` column in a specific database table. If the values match, the user can access the corresponding data objects.

//Ви можете встановлювати правила для таблиць або таблиць-представлень (Search Conditions).
You can set rules for tables or table views (search conditions).

//Ви можете використовувати різні типи RLS-правил для контролю доступу до таблиць на основі значення JWT-атрибута `hierarchy_code` та стовпця `hierarchy_code`.
You can use different types of RLS rules to control table access based on the value of the `hierarchy_code` JWT attribute and the `hierarchy_code` column.

[IMPORTANT]
====
//Налаштовуйте changeSets для додавання правил після відповідних таблиць або критеріїв пошуку, до яких необхідно застосувати ці правила.
Configure changeSets to add rules after the appropriate tables or search conditions to which the rules should be applied.
====

//Розглянемо тестову таблицю `test_table`, для якої застосуємо RLS-правила.
As an example, let's apply RLS rules to a test table.

.The "test_table" table
====
[source,xml]
----
<changeSet id="create_table_test_table" author="author_name">
  <comment>CREATE table test_table</comment>
  <ext:createTable tableName="test_table" ext:historyFlag="true">
    <ext:column name="id" type="int"/>
    <ext:column name="name" type="varchar(255)"/>
    <ext:column name="hierarchy_code" type="varchar(255)"/>
  </ext:createTable>
</changeSet>
----
====

//.RLS-правила для контролю доступу до таблиці `test_table` на основі значення JWT-атрибута `hierarchy_code` та стовпця `hierarchy_code`
.RLS rules for controlling access to the "test_table" based on the value of the "hierarchy_code" JWT attribute and the "hierarchy_code" column
====
//.*`<ext:addWriteRule>`* -- правило для додавання прав на запис.
.*`<ext:addWriteRule>`*: A rule to add write permissions.
[%collapsible]
=====
[source,xml]
----
<changeSet id="test_table_rls1" author="registry owner">
  <ext:rls name="write_rls1">
    <ext:addWriteRule
      name="writeRule1"
      jwtAttribute="hierarchy_code"
      checkColumn="hierarchy_code"
      checkTable="test_table"/>
  </ext:rls>
</changeSet>
----
=====

//.*`<ext:removeWriteRule>`* -- правило для видалення правила запису.
.*`<ext:removeWriteRule>`*: A rule to remove the write rule.
[%collapsible]
=====
[source,xml]
----
<changeSet id="test_table_rls2" author="registry owner">
  <ext:rls name="write_rls1">
    <ext:removeWriteRule name="writeRule1"/>
  </ext:rls>
</changeSet>
----
=====

//.*`<ext:addReadRule>`* -- правило для додавання прав на читання.
.*`<ext:addReadRule>`*: A rule to add read permissions.
[%collapsible]
=====
[source,xml]
----
<changeSet id="test_table_rls3" author="registry owner">
  <ext:rls name="read_rls1">
    <ext:addReadRule
      name="readRule1"
      jwtAttribute="hierarchy_code"
      checkColumn="hierarchy_code"
      checkTable="test_table"/>
  </ext:rls>
</changeSet>
----
=====

//.*`<ext:removeReadRule>`* -- правило для видалення правила читання.
.*`<ext:removeReadRule>`*: A rule to remove the read rule.
[%collapsible]
=====
[source,xml]
----
<changeSet id="test_table_rls4" author="registry owner">
  <ext:rls name="read_rls1">
    <ext:removeReadRule name="readRule1"/>
  </ext:rls>
</changeSet>
----
=====

//* Правила застосовуються до таблиці `test_table`.
* Rules are applied to the `test_table`.
//* Використовується JWT-атрибут `hierarchy_code`, що міститься у токені користувача.
* The `hierarchy_code` JWT attribute from the user's token is used.
//* Здійснюється перевірка значення стовпця `hierarchy_code` в таблиці `test_table` на збіг зі значенням JWT-атрибута `hierarchy_code`.
* The value of the `hierarchy_code` column in the `test_table` is checked for a match with the value of the `hierarchy_code` JWT attribute.
//* Користувач отримує доступ лише до об'єктів, які відповідають його рівню ієрархії. Відповідно правило видалення такий доступ скасовує.
* The user only gets access to objects that correspond to their hierarchy level. The deletion rule cancels this access.
====

//Розгляньмо, як це працює на конкретних прикладах із критеріями пошуку, відповідно до нашої референтної ієрархічної структури.
Let's see how this works according to our reference hierarchy structure using specific search condition examples.

//.Критерій пошуку `find_all_units` для взаємодії із фабрикою даних у рамках бізнес-процесу
.The "find_all_units" search condition for interacting with the data factory within the business process
====
.The "find_all_units" search condition
[%collapsible]
=====
[source,xml]
----
<changeSet id="24569-3" author="ek">
  <comment>CREATE search condition find-all-units</comment>
  <ext:createSearchCondition name="find_all_units" limit="all">
    <ext:table name="unit" alias="u">
      <ext:column name="id"/>
      <ext:column name="unit_name"/>
      <ext:column name="structure_code" searchType="notEqual"/>
      <ext:column name="hierarchy_code" searchType="startsWith" sorting="asc"/>
    </ext:table>
  </ext:createSearchCondition>
</changeSet>
----
=====

//Критерій пошуку з назвою `find_all_units` виконує пошук в таблиці `unit` за певними умовами. Основні характеристики цього критерію пошуку визначені наступним чином:
The `find_all_units` search condition searches the `unit` table using specific criteria. Here are the main properties of this search condition:

//* Таблиця: `unit` (із псевдонімом `u`).
* Table: `unit` (alias: `u`).
//* Стовпці, які вибираються: `id`, `unit_name`, `structure_code`, `hierarchy_code`.
* Columns to select: `id`, `unit_name`, `structure_code`, `hierarchy_code`.
//* Умови пошуку:
* Search criteria:
//** Стовпець `structure_code` має бути відмінним від певного значення (`searchType="notEqual"`).
** The `structure_code` column must differ from a particular value (`searchType="notEqual"`).
//** Стовпець `hierarchy_code` має починатися з певного значення (`searchType="startsWith"`).
** The `structure_code` column must start with a particular value (`searchType="startsWith"`).
//* Сортування результатів по стовпцю `hierarchy_code` в порядку зростання (`sorting="asc"`).
* Results are sorted by the `hierarchy_code` column in ascending order (`sorting="asc"`).

//Цей критерій пошуку дозволяє знайти усі записи в таблиці `unit`, які відповідають вищезазначеним умовам. Ви можете використовувати цей критерій пошуку для отримання конкретної підмножини даних із таблиці `unit` з урахуванням вказаних умов.
This search condition allows you to find all entries in the `unit` table that meet the described criteria. You can use this search condition to retrieve a specific subset of data from the `unit` table based on your criteria.
====

//.RLS-правило на читання даних для контролю доступу до таблиці-представлення `find_all_units_v` на основі значення JWT-атрибута `hierarchy_code` та стовпця `hierarchy_code`
.An RLS rule for reading data to control access to the "find_all_units_v" view table based on the value of the "hierarchy_code" JWT attribute and the "hierarchy_code" column.
====
[%collapsible]
//.addReadRule для представлення `find_all_units_v`
.addReadRule for the "find_all_units_v" view table
=====
[source,xml]
----
<changeSet author="ek" id="24569-4">
  <comment>CREATE rls for find-all-units SC</comment>
  <ext:rls name="read_rls for find_all_units">
    <ext:addReadRule
      name="hierarchy_code_rule"
      jwtAttribute="hierarchy_code"
      checkColumn="hierarchy_code"
      checkTable="find_all_units_v"/>
  </ext:rls>
</changeSet>
----
=====

//RLS-правило `read_rls for find_all_units` створює правило на читання даних для контролю доступу до таблиці-представлення `find_all_units_v` на основі значення JWT-атрибута `hierarchy_code` та стовпця `hierarchy_code`. Це правило перевіряє, чи збігаються значення JWT-атрибута `hierarchy_code` та стовпця `hierarchy_code`. Якщо значення збігаються, то користувач має дозвіл на читання даних з цієї таблиці.
The `read_rls for find_all_units` RLS rule creates a data read rule to control access to the `find_all_units_v` view table based on the value of the `hierarchy_code` JWT attribute and the `hierarchy_code` column. This rule checks whether the attribute and column values match. If the values match, the user can read data from this table.
====

[#inital-data-load]
//== Завантаження даних до таблиць
== Loading data into tables

//Підготуйте відповідні CSV-файли до завантаження у систему та наповнення таблиць-довідників.
Prepare the CSV files to upload into the reference tables.

//._Приклад вмісту CSV-файлу для заповнення таблиці `unit`, передбаченої референтною ієрархічною_
//TODO: ієрархічною _структурою_?
._An example of a CSV file for filling the "unit" table as part of the reference hierarchical structure_
[%collapsible]
====
[source,csv]
----
structure_code,unit_name,hierarchy_code
101,Ministry of Economy of Ukraine,101
102,Ministry of Digital Transformation of Ukraine,102
103,Ministry of Internal Affairs of Ukraine,103
104,Ministry of Communities and Territories Development of Ukraine,104
201,Department of Trade Agreements and Export Development,101.201
202,Division of Public Policy in the field of Public Material Reserve,101.202
203,Department of Labor and Employment,101.203
301,Department of Labor,101.203.301
302,Department of Industry and High-Risk Facilities Supervision,101.203.302
204,State Center of Informational Resources of Ukraine,102.204
205,State Enterprise "Diia",102.205
206,National Police of Ukraine,103.206
207,State Border Guard Service of Ukraine,103.207
208,State Migration Service of Ukraine,103.208
209,State Emergency Service of Ukraine,103.209
303,Office for Management of Places of Temporary Accommodation of Foreigners,103.208.303
304,Office for Management of Places of Temporary Accommodation of Refugees,103.208.304
210,State Agency for Tourism Development of Ukraine,104.210
211,State Agency on Energy Efficiency and Energy Saving of Ukraine,104.211
212,State Aviation Administration of Ukraine,104.212
213,State Service for Maritime, Inland Waterway Transport and Shipping of Ukraine,104.213
214,State Service of Ukraine for Transport Safety,104.214
215,State Agency for Reconstruction and Development of Infrastructure of Ukraine,104.215
305,Department of Restoration of Infrastructure of Ukraine,104.215.305
306,Department of Development of Infrastructure of Ukraine,104.215.306
401,Office of Infrastructure Development of Ukraine,104.215.306.401
----
====

//._Приклад вмісту CSV-файлу для заповнення таблиці `document_registration`, передбаченої референтною ієрархічною структурою_
._An example of a CSV file for filling the "document_registration" table as part of the reference hierarchical structure_
[%collapsible]
====
[source,csv]
----
name,hierarchy_code
Application No. 102,103.206
Resolution No. 1657,104.215.306
Resolution No. 42,101.203.301
----
====

[TIP]
====
//Первинне наповнення таблиць даними відбувається за допомогою БД-процедури PL/pgSQL.
The initial data is loaded into the tables using a PL/pgSQL database procedure.

//* Детальний опис процедури для первинного завантаження даних читайте на сторінці xref:data-modeling/initial-load/data-initial-data-load-pl-pgsql.adoc[].
For details on initial data loading, see xref:data-modeling/initial-load/data-initial-data-load-pl-pgsql.adoc[].

//* Також перегляньте xref:study-project/study-tasks/task-1-registry-db-modeling.adoc[] для ознайомлення із практичним застосуванням первинного завантаження при моделюванні регламенту.
//TODO: study-task topics are out of translation scope
====

[#create-users]
//== Створення користувачів
== Creating users

//Створіть відповідних посадових осіб у реєстрі. Зробити це можна у декілька способів:
Create officer users in the registry. There are several ways you can do this:

//. Створіть користувача вручну (_див. xref:registry-admin/create-users/manual-user-creation.adoc[]_)
* Create users manually (see xref:registry-admin/create-users/manual-user-creation.adoc[]).
+
//. Завантажте користувачів СSV-файлом (_див. xref:registry-admin/create-users/import-users-officer.adoc[]_)
* Upload users via a CSV file (see xref:registry-admin/create-users/import-users-officer.adoc[]).
+
//. Надайте можливість автоматичної реєстрації у системі через процес онбордингу (_див. xref:best-practices/bp-officer-self-register-manual.adoc[] та xref:best-practices/bp-officer-self-register-auto.adoc[]_). При такому підході необхідно попередньо увімкнути автореєстрації на рівні конфігурації реєстру в адміністративній панелі Control Plane (_див. xref:registry-admin/cp-auth-setup/cp-officer-self-registration.adoc[]_).
* Enable automatic registration in the system via the onboarding process (see xref:best-practices/bp-officer-self-register-manual.adoc[] and xref:best-practices/bp-officer-self-register-auto.adoc[]). To use this approach, you must first enable auto-registration at the registry configuration level in the Control Plane admin console (see xref:registry-admin/cp-auth-setup/cp-officer-self-registration.adoc[]).
+
[WARNING]
====
//Кожна посадова особа, зареєстрована в системі, повинна мати специфічний атрибут ієрархічної моделі в Keycloak -- `hierarchy_code`, який є сурогатним ключем для доступу до даних певного рівня ієрархії.
Each registered officer must have a hierarchy-related `hierarchy_code` attribute in Keycloak. This attribute serves as a surrogate key for accessing data that belongs to a specific hierarchy level.

image:registry-admin/hierarchy-model/hierarchy-model-attributes.png[]

//Також необхідно чітко визначити ролі для таких користувачів. Певна роль із прив'язкою до атрибута `hierarchy_code` дозволить обмежувати доступ лише до потрібного рівня, тобто підрозділу, ієрархічної структури та йому підпорядкованим.
It is also necessary to clearly define the roles for these users. A specific role with the `hierarchy_code` attribute allows you to limit an officer's access to the desired hierarchy level -- that is, a unit in the hierarchical structure and its subordinates.

//Якщо ви реєструєте керівника реєстру з ієрархічною моделлю управління, то окрім атрибута `hierarchy_code` йому необхідно призначити роль `hierarchy-registry-manager`.
When you create a registry manager within the hierarchical management model, you must assign the `hierarchy-registry-manager` role to them in addition to the `hierarchy_code` attribute.

//Для всіх інших ролей ієрархічної моделі діє той же принцип.
The same principle applies to all other roles within the hierarchical model.

image:registry-admin/hierarchy-model/hierarchy-model-roles.png[]

//Список ролей, пов'язаних з ієрархічною моделлю:
The following roles are related to the hierarchical model:
//TODO: We have the exact same list in the Overview section -- do we really need to repeat it twice within the same topic?

//* *`hierarchy-registry-manager`* -- керівник реєстру (посадова особа), відповідальна за керування ієрархічною структурою реєстру.
* `hierarchy-registry-manager`: Registry manager; an officer responsible for managing the hierarchical structure of the registry.
//* *`hierarchy-registry-user`* -- користувач реєстру (посадова особа), яка має доступ до ієрархічної структури та може виконувати завдання відповідно до своїх повноважень.
* `hierarchy-registry-user`: Registry user; an officer who has access to the hierarchical structure and can perform tasks within their authority.
//* *`personnel-officer-admin`* -- кадровик, посадова особа, відповідальна за управління персоналом, включаючи призначення та зміну ролей інших посадових осіб в межах своїх повноважень.
* `personnel-officer-admin`: Personnel officer; an officer responsible for personnel management, including appointing and updating roles of other officers.
//* *`officer-moderator`* -- модератор процесу автореєстрації посадових осіб у реєстрі, відповідальний за перевірку та схвалення запитів на реєстрацію нових користувачів.
* `officer-moderator`: Moderator; an officer who moderates the process of officers' auto-registration in the registry. A moderator is responsible for checking and approving registration requests from new users.

//Усі вищезазначені ролі, пов'язані з ієрархічною моделлю, а також системну роль `officer`, необхідно додати у файл *_roles/officer.yml_* регламенту реєстру.
All the hierarchy-related roles and the `officer` system role must be added to the *_roles/officer.yml_* file of the registry regulations.

.An example of roles/officer.yml
[%collapsible]
=====
[source,yaml]
----
roles:
  - name: officer
    description: Officer role
  - name: personnel-officer-admin
    description: Personnel officer admin role
  - name: officer-moderator
    description: Manual registration moderator
  - name: hierarchy-registry-user
    description: User of the registry with the hierarchical management model
  - name: hierarchy-registry-manager
    description: Manager of the registry with the hierarchical management model
  - name: officer-moderator
    description: Officers auto-registration moderator
----
=====

//Для того, щоб надати певній ролі доступ до конкретного бізнес-процесу, необхідно виконати авторизаційні налаштування для ролей у файлі *_bp-auth/officer.yml_*.
To grant business process access to a specific role, you must set up authorization for the role in the *_bp-auth/officer.yml_* file.

.An example of bp-auth/officer.yml
[%collapsible]
=====
[source,yaml]
----
authorization:
  realm: "officer"
  process_definitions:
  - process_definition_id: 'reference-hierarchy-management'
    process_name: 'Hierarchical structure management'
    process_description: 'Hierarchical structure management'
    roles:
      - 'hierarchy-registry-manager'
  - process_definition_id: 'reference-hierarchy-create-document'
    process_name: 'Create data for the data factory according to the hierarchical structure'
    process_description: 'Create data for the data factory according to the hierarchical structure'
    roles:
      - 'hierarchy-registry-user'
  - process_definition_id: 'reference-hierarchy-edit-document'
    process_name: 'View and edit data in the data factory according to the hierarchical structure'
    process_description: 'View and edit data in the data factory according to the hierarchical structure'
----
=====

====

[#bp-modeling]
//== Моделювання бізнес-процесів
== Modeling business processes

//Після розгортання регламенту включно з ієрархічною моделлю даних, ви можете моделювати власну логіку взаємодії з даними реєстру та їх обробки за допомогою бізнес-процесів та відповідних інтеграційних розширень-конекторів, які також називають делегатами.
After deploying the regulations with the hierarchical data model, you can start modeling your logic for interacting with registry data and processing it by the business processes and integration connectors, also called delegates.

//TODO: усіХ
//На основі усі змодельованих таблиць, критеріїв пошуку у моделі даних реєстру, Платформа створює REST API-ендпоінти (також -- ресурси), які публікуються у сервісі `registry-rest-api` й можуть бути використані у бізнес-процесах для отримання, створення, редагування, або видалення даних.
Based on all the modeled tables and search conditions in the registry data model, the Platform creates REST API endpoints (resources) and publishes them in the `registry-rest-api` service. You can use these resources in business processes to obtain, create, edit, or delete data.

//TIP: Референтні приклади моделювання бізнес-процесів та UI-форм доступні для використання в регламенті демо-реєстру. Як розгорнути демо-реєстр з усіма наявними прикладами моделювання регламенту, дивіться на сторінці xref:registry-admin/cp-deploy-consent-data.adoc[].
TIP: Business processes and UI forms modeling examples are available in the regulations of the registry demo. To learn how to deploy the registry demo, see xref:registry-admin/cp-deploy-consent-data.adoc[].

////

[TIP]
====
Референтні бізнес-процеси для представленої ієрархічної структури описані на сторінках:

* xref:best-practices/hierarchy-model/bp-create-entity-hierarchy-model.adoc[]
* xref:best-practices/hierarchy-model/bp-view-update-data-db.adoc[]
====

== Процеси, пов'язані з ієрархічною структурою

* xref:best-practices/hierarchy-model/bp-create-entity-hierarchy-model.adoc[]
* xref:best-practices/hierarchy-model/bp-view-update-data-db.adoc[]