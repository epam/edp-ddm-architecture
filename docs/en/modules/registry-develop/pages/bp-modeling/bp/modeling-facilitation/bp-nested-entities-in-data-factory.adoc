= Збереження декількох сутностей в рамках однієї транзакції
:toc:
:toc-title: ЗМІСТ
:toclevels: 5
:sectnums:
:sectnumlevels: 5
:sectanchors:

== Проблематика

При використанні делегата `dataFactoryConnectorCreateDelegate` та відповідного ендпоінта, за потреби запису 2-х і більше сутностей до бази даних, виникає проблема -- це може бути реалізовано тільки по черзі, різними транзакціями.

Відповідно, одна транзакція може завершитися успішно, а наступна -- з будь-якої причини не завершитися. Такий сценарій може призвести до неконсистентності даних, необхідності видалення успішної транзакції із БД і повторного виконання всіх процедур.

Такий підхід ускладнює моделювання, значно подовжуючи бізнес-процес, а також збільшує навантаження на базу даних, адже збільшується і кількість транзакцій при створенні сутностей.

.Приклад
====
Наприклад, необхідно записати дані про користувача (1), його навчальний профіль (2) та налаштування користувача (3). Маємо три послідовні БД-транзакції:

. Запис персональних даних користувача (простий об'єкт `personProfile`) до таблиці `person_profile`. Операція успішна.
. Запис даних для створення навчального профілю користувача (простий об'єкт `personEduProfile`) до таблиці `person_edu_profile`. Операція неуспішна.
. Запис налаштувань користувача (простий об'єкт `userSettings`) до таблиці `user_setting`. Транзакція не розпочалася взагалі.

В результаті, лише одна транзакція успішна. База даних не консистентна. Виникає необхідність відкотити БД до попереднього стану, тобто видалити кожну виконану транзакцію через `DELETE`-ендпоінт, і виконати всі три записи повторно.
====

Для розв'язання цієї проблеми впроваджено спеціальний делегат, що забезпечуватиме можливість одночасно зберігати декілька сутностей до різних таблиць бази даних в рамках однієї транзакції.

== Загальний опис

З метою підтримки функціональності збереження декількох сутностей в рамках однієї транзакціїfootnote:[_Транзакція_ -- група послідовних операцій із базою даних, яка є логічною одиницею роботи з даними. Транзакція може бути виконана або цілком і успішно, дотримуючись цілісності даних і незалежно від інших транзакцій, що ідуть паралельно, або не виконана зовсім.], розроблено типове розширення до бізнес-процесів -- делегат `${dataFactoryConnectorNestedCreateDelegate}`, для якого імплементовано однойменний шаблон *Create nested entities in data factory*, представлений у вигляді JSON-файлу _dataFactoryConnectorNestedCreateDelegate.json_.

Делегат потрібний для того, щоб в рамках однієї транзакції створювати декілька сутностей у Фабриці даних.

[TIP]
====
На Платформі реєстрів реалізовано подібний делегат і відповідний шаблон до нього -- *Create entity in data factory*, але він дозволяє створити _лише одну_ сутність в рамках транзакції.

За таких обставин результат _однієї сервісної задачі_ бізнес-процесу може створити тільки _один запис_ у сховищі даних.
====

За допомогою делегата `${dataFactoryConnectorNestedCreateDelegate}` реалізовано можливість створення _декількох записів з однієї сервісної задачі_.

Для того, щоб делегат міг функціонувати, на рівні Фабрики даних реалізована можливість створення _вкладених сутностей_ (_nested entities_), тобто імплементовано окремий _спеціальний ендпоінт_, щоб приймати комплексні (вкладені) об'єкти, що містять декілька сутностей, від рівня бізнес-процесів і створювати відповідні записи у різних таблицях бази даних за одну транзакцію.

На рівні API, у контракті, описано, яким має бути тіло запита, щоб мати змогу створити декілька сутностей у БД.

[IMPORTANT]
====
Після опрацювання на рівні API, Фабрика даних сама розкладе дані до належних таблиць.
====

== Моделювання бізнес-процесу для створення та використання вкладених сутностей

[CAUTION]
====
Передумови ::

Перед моделюванням процесу та налаштуванням делегата *Create nested entities in data factory*, переконайтеся, що папка `/element-templates` застосунку Camunda Modeler містить файл _dataFactoryConnectorNestedCreateDelegate.json_.
+
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-1.png[]
====

=== Моделювання та налаштування бізнес-процесу

На прикладі бізнес-процесу для створення вкладених сутностей розглянемо налаштування делегата *Create nested entities in data factory*, а також кроки моделювання таких сутностей у процесі: _створення користувача_, _створення навчального профілю користувача_, а також _створення наказів_, на підставі яких додається навчальний профіль.

image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-01.png[]

==== Створення пулу для бізнес-процесу

. Відкрийте додаток *Camunda Modeler* та створіть нову діаграму BPMN. Для цього у лівому верхньому куті натисніть меню *File* -> *New File* -> *BPMN Diagram*.
+
image:registry-develop:bp-modeling/bp/modeling-instruction/bp-1.png[]

. На панелі інструментів зліва знайдіть елемент *Create pool/Participant* та перетягніть його до області моделювання.
+
image:registry-develop:bp-modeling/bp/modeling-instruction/bp-2.png[]

. Заповніть наступні поля відповідними значеннями:

* У полі `Participant Name` введіть назву пулу, що відображатиметься у моделері -- `Бізнес-процес`.
* У полі `Process id` введіть ідентифікатор бізнес-процесу -- `nested_entity_test_process`.
* У полі `Process Name` вкажіть бізнес-назву процесу -- `nested entity test process`.

+
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-02.png[]

==== Моделювання стартової події

_Створіть початкову подію_ для запуску бізнес-процесу користувачем. Для цього виконайте наступні кроки:

. На панелі інструментів, зліва, знайдіть елемент (коло) *CreateStartEvent* та перетягніть його до панелі моделювання.
. На панелі налаштувань справа заповніть наступні параметри відповідними значеннями:
* У полі `Name` введіть назву початкової події -- `Початок`;
* У полі `Initiator` введіть `initiator`.

+
TIP: `initiator` -- спеціальна змінна, що встановлюється для користувача, який розпочав процес.

+
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-03.png[]

==== Моделювання користувацьких форм для введення та підпису даних

Моделювальник має створити дві користувацькі задачі (форми) для внесення персональних даних користувача (1) та їх подальшого підпису КЕП (2).

image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-04.png[]

. Змоделюйте користувацьку задачу (*User form*) для внесення даних профілю користувача та пов'яжіть її із формою бізнес-процесу параметром `Form key`.

* У полі `Id` вкажіть ідентифікатор задачі -- `addPersonProfileActivity`. Він є ключем визначення задачі (task definition key).
* У полі `Name` введіть назву задачі. Наприклад, `Внести дані про освітній профіль`.
* У полі `Form key` введіть ключ форми бізнес-процесу -- `add-dataprof`.
* У полі `Assignee` вкажіть змінну, що використовується для зберігання користувача, який запустив екземпляр процесу, -- `${initiator}`.
+
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-05.png[]

. Змоделюйте користувацьку задачу (*User form*) для підпису даних профілю користувача за допомогою КЕП та пов'яжіть її із формою бізнес-процесу параметром `Form key`.

* У полі `Id` вкажіть ідентифікатор задачі -- `signPersonProfileActivity`. Він є ключем визначення задачі (task definition key).
* У полі `Name` введіть назву задачі. Наприклад, `Підписати дані про освітній профіль`.
* У полі `Form key` введіть ключ форми бізнес-процесу -- `add-signd`.
* У полі `Assignee` вкажіть змінну, що використовується для зберігання користувача, який запустив екземпляр процесу, -- `${initiator}`.
+
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-06.png[]


TIP: Тобто з погляду UI, після запуску бізнес-процесу, перед посадовою особою з'явиться форма для внесення даних профілю. Після внесення даних з'явиться нова форма для підпису даних за допомогою КЕП. Дані будуть передані бізнес-процесу за параметром `Form key` і використані у наступній задачі процесу.

==== Моделювання задачі скриптування "Підготовка даних до запису (transient var)" для формування простого об'єкта

Внесені на формі та підписані КЕП дані передаються задачі скриптування (*Script task*), де використовується groovy-скрипт, який формує із цих даних JSON-об'єкт і записує його до змінної `createPersonPayload`.

image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-07.png[]

. Створіть нову задачу, визначте її тип, натиснувши іконку ключа та обравши з меню пункт *Script Task* (Задача скриптування).

. На панелі налаштувань справа заповніть наступні поля:

* У полі `Name` вкажіть назву задачі -- `Підготовка даних для запису (transient var)`.
* У полі `Script Format` вкажіть формат скрипту -- `groovy`.
* У полі `Script Type` вкажіть тип скрипту -- `Inline Script`.
* У полі `Script` введіть безпосередньо groovy-скрипт:
+
.Приклад. Groovy-скрипт, що формує JSON-об'єкт для подальшого запису до БД
====
[source,groovy]
----
def cephData = [:]

        def formData = submission('signPersonProfileActivity').formData

        cephData['lastName'] = formData.prop('last_name').value()
        cephData['firstName'] = formData.prop('first_name').value()
        cephData['secondName'] = formData.prop('second_name').value()
        cephData['birthday'] = formData.prop('birthday').value()

        set_transient_variable('createPersonPayload', S(cephData, 'application/json'))
----
====
+
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-08.png[]

. В результаті виконання задачі, у виводі отримуємо сформований JSON, збережений до змінної `createPersonPayload`, що надалі використовуватиметься у бізнес-процесі.
+
.Приклад. Сформований JSON-об'єкт, збережений до змінної 'createPersonPayload'
====
[source,json]
----
{
"secondName": "string",
"firstName": "string",
"lastName": "string",
"birthday": "2022-02-16T13:17:10.952Z"
}
----
====

==== Моделювання Call Activity для підпису простого об'єкта системним ключем

Далі необхідно створити Call Activity для виклику глобального підпроцесу підпису даних системним ключем. Call Activity використовує змінну `createPersonPayload`, дані з якої передаються до підпроцесу для подальшого їх підпису.

В результаті виконання підпроцесу, викликаного у Call Activity, дані підписуються системним Ceph-ключем. Ключ зберігається до змінної `person_profile_system_signature_ceph_key`.

. Змоделюйте елемент *Call Activity*.
. Перейдіть до панелі налаштувань справа та застосуйте делегат *System digital signature*. Для цього оберіть відповідний шаблон із каталогу (`Open Catolog`).
+
TIP: Приклад налаштування делегата System digital signature наведено за xref:bp-modeling/bp/element-templates/bp-element-templates-installation-configuration.adoc#element-temp-system-digital-signature[посиланням].

. Виконайте подальші налаштування:

* У полі `Name` вкажіть назву елемента -- `Підписати дані системним ключем`.
* У полі `Input data` вкажіть вхідні дані, які необхідно передати підпроцесу, що викликатиметься -- `${createPersonPayload}`.
* У полі `Output variable name` введіть назву змінної, в яку буде записано системний Ceph-ключ -- `person_profile_system_signature_ceph_key`. Він потрібний для додаткового системного підпису у Фабриці даних.
+
NOTE: Ідентифікатор підпроцесу, що викликатиметься, передається у полі `Called Element` і має стале значення `system-signature-bp`. Ці та деякі інші налаштування "вшито" до шаблону з метою спрощення моделювання.
+
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-09.png[]

==== Моделювання сервісної задачі для створення профілю користувача

Надалі дані використовуються у сервісній задачі "Створити профайл".

У задачі необхідно застосувати делегат для створення однієї сутності у базі даних (*Create entity in data factory*), використавши підписані дані (Payload) зі змінної `${createPersonPayload}`, та надіслати запит до відповідного API-ендпоінту (ресурсу) `person-profile`.

Разом із даними передається і ключ для перевірки системного підпису Фабрикою даних, який взято зі змінної `${person_profile_system_signature_ceph_key}`.

В результаті отримуємо відповідь від API, яка зберігатиметься у змінній `createPersonProfileResponse`.

. Змоделюйте нову задачу.
. Визначте її тип, натиснувши іконку ключа та обравши з меню пункт *Service Task* (сервісна задача).
. Перейдіть до панелі налаштувань справа та застосуйте делегат *Create entity in data factory*. Для цього оберіть відповідний шаблон із каталогу (`Open Catalog`).

. Виконайте подальші налаштування:

* У полі `Id` вкажіть ідентифікатор сервісної задачі -- `createProfile`.
* У полі `Name` вкажіть назву задачі. Наприклад, `Створити профайл`.
* У полі `Resource` вкажіть ресурс (API-ендпоінт), куди необхідно виконати запит -- `person-profile`.
+
NOTE: На рівні API ендпоінт виглядає наступним чином: `/<resource name>`, де `<resource name>` -- назва ресурсу. Тобто у полі `Resource` необхідно ввести значення, вказане після косої риски (`/`).

* У полі `Payload` введіть тіло запита -- JSON-об`єкт, тобто дані зі змінної `${createPersonPayload}`, які необхідно зберегти до Фабрики даних.
+
NOTE: Майте на увазі, що необхідно попередньо побудувати цей JSON-об`єкт, тобто `payload`, в рамках задачі скриптування.

* У полі `X-Access-Token` вкажіть токен доступу до ресурсу.
+
[CAUTION]
====
Токен доступу береться з АБО ініціатора (наприклад, `${initiator().accessToken}`), АБО виконавця задачі (наприклад, `${completer('taskDefinitionId').accessToken}`):

* Якщо перед сервісною задачею у бізнес-процесі немає жодної користувацької задачі, використовуємо токен ініціатора процесу (initiator).

* Якщо перед сервісною задачею є користувацька задача, використовуємо токен виконавця задачі (completer).

Таким чином ми від імені користувача, який АБО запустив бізнес-процес, АБО виконав користувацьку задачу, створюємо сутність у базі даних.
====

* У полі `X-Digital-Signature-source` вкажіть джерело цифрового підпису (КЕП), тобто передайте функції `sign_submission()` ID користувацької форми, де застосовували КЕП -- `${sign_submission('signPersonProfileActivity').signatureDocumentId}`.

* У полі `X-Digital-Signature-Derived-source` вкажіть джерело системного підпису, тобто змінну, з якої необхідно взяти системний ключ, -- `${person_profile_system_signature_ceph_key}`.

* У полі `Result variable` вкажіть назву змінної, до якої необхідно зберегти відповідь від API, -- `createPersonProfileResponse`.
+
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-2.png[]

IMPORTANT: В результаті виконується _одна транзакція_, що записує _один простий об'єкт_ `personProfile` до відповідної таблиці `person_profile` у базі даних.

==== Моделювання задачі скриптування "Підготовка даних" для формування комплексного об'єкта

Далі у задачі скриптування необхідно створити комплексний об'єкт (nested object), що містить вкладені сутності:

* об'єкт `personEduProfile` (навчальний профіль користувача), в якому ми передаємо вкладений об'єкт з ID щойно створеного користувача (`personProfileId`);
* а також об'єкт `orders`, в якому передається список атрибутів наказу, тобто додаткові налаштування (підстави) для створення такого навчального профілю.

Комплексний JSON-об'єкт із вкладеними сутностями записуємо до змінної `createComplexPayload`.

image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-3.png[]

. Створіть нову задачу, визначте її тип, натиснувши іконку ключа та обравши з меню пункт *Script Task* (Задача скриптування).

. На панелі налаштувань справа заповніть наступні поля:

* У полі `Name` вкажіть назву задачі -- `Підготовка даних`.
* У полі `Script Format` вкажіть формат скрипту -- `groovy`.
* У полі `Script Type` вкажіть тип скрипту -- `Inline Script`.
* У полі `Script` введіть безпосередньо groovy-скрипт:
+
.Приклад. Groovy-скрипт, що формує комплексний JSON-об'єкт для подальшого запису до БД
====
[source,groovy]
----
def personProfileId = createPersonProfileResponse.responseBody.prop('id').value()

        def personEduProfile = ['personProfileId':personProfileId]

        def formData = submission('signPersonProfileActivity').formData

        def orders = [:]
        orders['ordersType'] = formData.prop('order_type').value()
        orders['ordersNumber'] = formData.prop('order_number').value()
        orders['ordersDate'] = formData.prop('order_date').value()
        orders['personProfileId'] = personProfileId

        def cephData = ['personEduProfile':personEduProfile,'orders':orders]

        set_transient_variable('createComplexPayload', S(cephData, 'application/json'))
----
====
+
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-4.png[]

. В результаті виконання задачі, у виводі отримуємо сформований JSON, збережений до змінної `createComplexPayload`, що надалі використовуватиметься у бізнес-процесі.
+
.Приклад. Сформований JSON-об'єкт, збережений до змінної 'createComplexPayload'
====
[source,json]
----
{
  "personEduProfile": {
    "personProfileId": "3fa85f64-5717-4562-b3fc-2c963f66afa6"
  },
  "orders": {
    "ordersType": "string",
    "ordersNumber": "string",
    "ordersDate": "2022-02-16T13:33:30.660Z",
    "personProfileId": "3fa85f64-5717-4562-b3fc-2c963f66afa6"
  }
}
----
====

==== Моделювання Call Activity для підпису комплексного об'єкта системним ключем

Далі необхідно створити Call Activity для виклику глобального підпроцесу підпису даних системним ключем. Call Activity використовує змінну `createComplexPayload`, дані з якої передаються до підпроцесу для подальшого їх підпису.

В результаті виконання підпроцесу, викликаного у Call Activity, дані підписуються системним Ceph-ключем для перевірки системного підпису Фабрикою даних. Ключ зберігається до змінної `transaction_system_signature_ceph_key`.

. Змоделюйте елемент *Call Activity*.
. Перейдіть до панелі налаштувань справа та застосуйте делегат *System digital signature*. Для цього оберіть відповідний шаблон із каталогу (`Open Catolog`).
+
TIP: Приклад налаштування делегата System digital signature наведено за xref:bp-modeling/bp/element-templates/bp-element-templates-installation-configuration.adoc#element-temp-system-digital-signature[посиланням].

. Виконайте подальші налаштування:

* У полі `Name` вкажіть назву елемента -- `Підписати дані системним ключем`.
* У полі `Input data` вкажіть вхідні дані, які необхідно передати підпроцесу, що викликатиметься -- `${createComplexPayload}`.
* У полі `Output variable name` введіть назву змінної, до якої буде записано системний Ceph-ключ -- `transaction_system_signature_ceph_key`. Він потрібний для перевірки системного підпису у Фабриці даних.
+
NOTE: Ідентифікатор підпроцесу, що викликатиметься, передається у полі `Called Element` і має стале значення `system-signature-bp`. Ці та деякі інші налаштування "вшито" до шаблону з метою спрощення моделювання.
+
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-5.png[]

==== Моделювання сервісної задачі для створення декількох сутностей в рамках однієї транзакції

Далі дані використовуються у сервісній задачі "Збереження даних".

У задачі необхідно застосувати делегат для створення декількох сутностей у базі даних в рамках однієї транзакції (*Create nested entities in data factory*), використавши підписані дані (Payload) зі змінної `${createСomplexPayload}`.

В рамках виконання задачі бізнес-процес: ::

* надсилає підписані дані (`${createComplexPayload}`) до API-ендпоінту (ресурсу) `nested-transaction-entity`.
* передає токен доступу до ресурсу.
* передає у запиті КЕП користувача.
* передає системний ключ зі змінної `${transaction_system_signature_ceph_key}`.

Результат (відповідь) від API записуємо до змінної `response`.

. Змоделюйте нову задачу.
. Визначте її тип, натиснувши іконку ключа та обравши з меню пункт *Service Task* (сервісна задача).
. Перейдіть до панелі налаштувань справа та застосуйте делегат *Create entity in data factory*. Для цього оберіть відповідний шаблон із каталогу (`Open Catalog`).
+
TIP: Приклад налаштування делегата *Create nested entities in data factory* наведено за xref:bp-modeling/bp/element-templates/bp-element-templates-installation-configuration.adoc#create-nested-entities[посиланням].

. Виконайте подальші налаштування:

* У полі `Id` вкажіть ідентифікатор сервісної задачі -- `createComplex`.
* У полі `Name` вкажіть назву задачі. Наприклад, `Збереження даних`.
* У полі `Resource` вкажіть ресурс (API-ендпоінт), куди необхідно виконати запит -- `nested-transaction-entity`.
+
NOTE: На рівні API ендпоінт виглядає наступним чином: `/nested/<resource name>`, де `<resource name>` -- назва ресурсу. Тобто у полі `Resource` необхідно ввести значення, вказане після останньої косої риски (`/`).

* У полі `Payload` введіть тіло запита -- JSON-об`єкт, тобто дані зі змінної `${createComplexPayload}`, які необхідно зберегти до Фабрики даних.
+
NOTE: Майте на увазі, що необхідно попередньо побудувати цей JSON-об`єкт, тобто `payload`, в рамках задачі скриптування.

* У полі `X-Access-Token` вкажіть токен доступу до ресурсу.
+
[CAUTION]
====
Токен доступу береться з АБО ініціатора (наприклад, `${initiator().accessToken}`), АБО виконавця задачі (наприклад, `${completer('taskDefinitionId').accessToken}`):

* Якщо перед сервісною задачею у бізнес-процесі немає жодної користувацької задачі, використовуємо токен ініціатора процесу (initiator).

* Якщо перед сервісною задачею є користувацька задача, використовуємо токен виконавця задачі (completer).

Таким чином ми від імені користувача, який АБО запустив бізнес-процес, АБО виконав користувацьку задачу, створюємо сутності у базі даних.
====

* У полі `X-Digital-Signature-source` вкажіть джерело цифрового підпису (КЕП), тобто передайте функції `sign_submission()` ID користувацької форми, де застосовували КЕП, -- `${sign_submission('signPersonProfileActivity').signatureDocumentId}`.

* У полі `X-Digital-Signature-Derived-source` вкажіть джерело системного підпису, тобто змінну, з якої необхідно взяти системний ключ, -- `${transaction_system_signature_ceph_key}`.

* У полі `Result variable` вкажіть назву змінної, в якій необхідно зберегти відповідь від API, -- `response`.
+
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-6.png[]

. Виконайте `Unlink` шаблону, тобто від'єднайте шаблон від задачі, щоб побачити деталі його імплементації, що передзаповнюються автоматично з метою спрощення моделювання:

* У полі `Implementation` визначено тип -- `Delegate Expression`.
* У полі `Delegate Expression`  визначено назву делегата -- `$dataFactoryConnectorNestedCreateDelegate`.
+
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-7.png[]
+
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-8.png[]

[IMPORTANT]
====
В результаті виконується _одна транзакція_, що записує _комплексний об'єкт_, який складається із декількох вкладених об'єктів (сутностей): `personEduProfile` та `orders`, до відповідних БД-таблиць `person_edu_profile` та `order`, які посилаються за зовнішнім ключем `personProfileId` до таблиці `person_profile`.

Таким чином маємо виконану транзакцію одночасно до 3-х таблиць у базі даних. Рівень API Фабрики даних автоматично розкладає дані, що надходять у тілі запита, за різними таблицями.
====

[start=6]
. Продовжіть бізнес-процес за необхідності або завершіть.

=== Використання комплексного об'єкта у бізнес-процесі

Розглянемо приклад подальшого використання комплексного об'єкта у цьому ж бізнес-процесі, дані якого були збережені до бази даних в рамках попередньої транзакції.

==== Моделювання сервісної задачі "Get transaction"

Для подальшого використання комплексного об'єкта та його збережених сутностей, необхідно спочатку отримати ID транзакції, в рамках якої був записаний цей об'єкт.

Для цього потрібно надіслати `GET`-запит на відповідний ендпоінт `Get transaction`, вказавши ID транзакції зі змінної `response` останньої сервісної задачі -- `${response.value.responseBody.prop('id').value()}`, а також токен доступу до ресурсу.

image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-9.png[]

. Змоделюйте нову задачу.
. Визначте її тип, натиснувши іконку ключа та обравши з меню пункт *Service Task* (сервісна задача).
. Перейдіть до панелі налаштувань справа та застосуйте делегат *Read entity from data factory*. Для цього оберіть відповідний шаблон із каталогу (`Open Catalog`).

. Виконайте подальші налаштування:

* У полі `Name` вкажіть назву задачі. Наприклад, `Get transaction`.
* У полі `Resource` вкажіть ресурс (API-ендпоінт), куди необхідно виконати запит -- `transaction`.
+
NOTE: На рівні API ендпоінт виглядає наступним чином: `/<resource name>`, де `<resource name>` -- назва ресурсу. Тобто у полі `Resource` необхідно ввести значення, вказане після косої риски (`/`).

* У полі `Resource id` введіть ID транзакції зі змінної `response` останньої сервісної задачі -- `${response.value.responseBody.prop('id').value()}`, що необхідно передати до Фабрики даних.

* У полі `X-Access-Token` вкажіть токен доступу до ресурсу -- `${completer('signPersonProfileActivity').accessToken}`.
+
[CAUTION]
====
Токен доступу береться з АБО ініціатора (наприклад, `${initiator().accessToken}`), АБО виконавця задачі (наприклад, `${completer('taskDefinitionId').accessToken}`):

* Якщо перед сервісною задачею у бізнес-процесі немає жодної користувацької задачі, використовуємо токен ініціатора процесу (initiator).

* Якщо перед сервісною задачею є користувацька задача, використовуємо токен виконавця задачі (completer).

Таким чином ми від імені користувача, який АБО запустив бізнес-процес, АБО виконав користувацьку задачу, виконуємо пошук сутності у базі даних.
====

* У полі `Result variable` вкажіть назву змінної, в якій необхідно зберегти відповідь від API, -- `txResponse`.
+
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-10.png[]

==== Моделювання сервісної задачі "Пошук даних за наказом"

Після отримання ID транзакції в результаті виконання попередньої задачі, ми можемо виконати пошук за певними даними, що збереглися в рамках такої транзакції (тут -- за наказом, тобто об'єктом `orders`).

Для цього потрібно надіслати `GET`-запит на відповідний ендпоінт `orders`, вказавши ID транзакції зі змінної `txResponse` останньої сервісної задачі -- `${txResponse.value.responseBody.prop('ordersId').value()}`, а також токен доступу до ресурсу.


. Змоделюйте нову задачу.
. Визначте її тип, натиснувши іконку ключа та обравши з меню пункт *Service Task* (сервісна задача).
. Перейдіть до панелі налаштувань справа та застосуйте делегат *Read entity from data factory*. Для цього оберіть відповідний шаблон із каталогу (`Open Catalog`).

. Виконайте подальші налаштування:

* У полі `Name` вкажіть назву задачі. Наприклад, `Пошук даних за наказом`.
* У полі `Resource` вкажіть ресурс (API-ендпоінт), куди необхідно виконати запит -- `orders`.
+
NOTE: На рівні API ендпоінт виглядає наступним чином: `/<resource name>`, де `<resource name>` -- назва ресурсу. Тобто у полі `Resource` необхідно ввести значення, вказане після косої риски (`/`).

* У полі `Resource id` введіть ID транзакції зі змінної `txResponse` останньої сервісної задачі -- `${txResponse.value.responseBody.prop('ordersId').value()}`, що необхідно передати до Фабрики даних.

* У полі `X-Access-Token` вкажіть токен доступу до ресурсу -- `${completer('signPersonProfileActivity').accessToken}`.
+
[CAUTION]
====
Токен доступу береться з АБО ініціатора (наприклад, `${initiator().accessToken}`), АБО виконавця задачі (наприклад, `${completer('taskDefinitionId').accessToken}`):

* Якщо перед сервісною задачею у бізнес-процесі немає жодної користувацької задачі, використовуємо токен ініціатора процесу (initiator).

* Якщо перед сервісною задачею є користувацька задача, використовуємо токен виконавця задачі (completer).

Таким чином ми від імені користувача, який АБО запустив бізнес-процес, АБО виконав користувацьку задачу, виконуємо пошук сутності у базі даних.
====

* У полі `Result variable` вкажіть назву змінної, в якій необхідно зберегти відповідь від API, -- `ordResponse`.
+
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-11.png[]

. Продовжіть бізнес-процес за необхідності або завершіть.

== Імплементація на рівні API

Для окремого типу запита використовують окремий делегат. Тобто в загальному випадку є REST-контролер, який підтримує певні типи запитів (методи): `POST`, `GET`, `PUT` та `DELETE`. Для кожного методу -- свій делегат.

[WARNING]
====
Для ресурсу `/nested/<resource name>` та делегата `$dataFactoryConnectorNestedCreateDelegate` використовується _лише_ метод `PUT`.

І хоча метод `PUT` зазвичай використовується для оновлення записів, та у нашому випадку `PUT` може як _створити сутність_, так і _оновити_ її, в залежності від того, які параметри ми передаємо у запиті:

* Якщо необхідно _створити сутність_, то ми НЕ передаємо параметр `<table_primary_key>_id` у тілі запита. Наприклад, `orders_id`.

* Якщо необхідно _оновити сутність_, то ми включаємо параметр ``<table_primary_key>_id`` у тіло запита. Наприклад, `orders_id`.
====

.Приклад. Тіло запита
====
[source,json]
----
{
  "personEduProfile": {
    "personProfileId": "3fa85f64-5717-4562-b3fc-2c963f66afa6"
  },
  "orders": {
    "ordersType": "string",
    "ordersNumber": "string",
    "ordersDate": "2022-02-16T13:33:30.660Z",
    "personProfileId": "3fa85f64-5717-4562-b3fc-2c963f66afa6"
  }
}
----
====

.Приклад відповіді від API-сервісу:
====

HTTP-код: ::
----
200 OK
----

Тіло відповіді: ::
----
{
   "id":"d1394f5d-5274-4831-90ac-0dfdb6d7bd35"
}
----
====

[IMPORTANT]
====
Отже, нема потреби створювати окремий контролер із різними ендпоінтами для різних цілей. Достатньо використовувати один _окремий_ ендпоінт, який матиме можливість приймати й правильно опрацьовувати комплексний JSON-об'єкт, в якому одночасно передаватимуться всі необхідні дані користувача та його налаштування, і параметри якого можна буде зберегти до різних таблиць в одній БД-транзакції.
====