:toc: auto
:toclevels: 5
:experimental:
:sectnums:
:sectnumlevels: 5
:sectanchors:
:sectlinks:
:partnums:

//= Вибір одного або декількох рядків у таблиці та виконання дій щодо даних у записах
= Selecting one or multiple rows in a table and performing actions on the data in the records

//== Моделювання структур даних
== Data structure modeling

//Створіть модель даних реєстру за прикладом нижче.
Create a data model for the registry based on the example below.

[TIP]
====
//Приклад _.xml_-схем та пов'язаних CSV-файлів для створення моделі даних ви можете знайти у регламенті демо-реєстру *_consent-data_* за посиланням:
Example .xml schemas and associated CSV files for creating a data model can be found in the demo registry *_consent-data_* regulations at the following link:
https://admin-tools-consent-data.apps.envone.dev.registry.eua.gov.ua/gerrit.

//Схема для створення таблиць та критеріїв пошуку буде доступна за назвою *_licenseTable.xml_*.
The schema for creating tables and search conditions will be available under the name *_licenseTable.xml_*.

//Файл-довідник CSV із даними для імпорту в БД буде доступний за назвою *_licences.csv_*.
The CSV reference file with data for importing into the database will be available under the name *_licenses.csv_*.

//Файл для заповнення таблиці licences даними буде доступний за назвою *_populateLicenses.xml_*.
The file for populating the licenses table with data will be available under the name *_populateLicenses.xml_*.
====

//. Створіть новий тип даних, таблицю та критерій пошуку.
. Create a new data type, table, and search conditions.
+
//Ця модель даних створює новий користувацький тип даних та таблицю, а також визначає критерій пошуку.
This data model creates a new user-defined data type and table, as well as it defines the search condition.

+
._Базова модель даних для нашого прикладу_
._Basic data model for our example_
[%collapsible]
====
[source,xml]
----
  <changeSet author="registry owner" id="enum license_status">
    <comment>CREATE TYPE license_status</comment>
    <ext:createType name="license_status">
      <ext:asEnum>
        <ext:label translation="діюча">active</ext:label>
        <ext:label translation="анульована">canceled</ext:label>
      </ext:asEnum>
    </ext:createType>
  </changeSet>

  <changeSet author="registry owner" id="table licenses">
    <comment>CREATE TABLE licenses</comment>
    <ext:createTable tableName="licenses" ext:historyFlag="true">
      <column name="license_id" type="UUID">
        <constraints nullable="false" primaryKey="true" primaryKeyName="pk_licenses"/>
      </column>
      <column name="number" type="TEXT">
        <constraints nullable="false"/>
      </column>
      <column name="date_received" type="DATE">
        <constraints nullable="false"/>
      </column>
      <column name="date_terminated" type="DATE">
        <constraints nullable="false"/>
      </column>
      <column name="full_name" type="TEXT">
        <constraints nullable="false"/>
      </column>
      <column name="licensing_status" type="license_status">
        <constraints nullable="false"/>
      </column>
    </ext:createTable>
  </changeSet>

  <changeSet author="registry owner" id="searchCondition search_licenses_by_status">
    <comment>CREATE search condition search_licenses_by_status</comment>
    <ext:createSearchCondition name="search_licenses_by_status">
      <ext:table name="licenses" alias="l">
        <ext:column name="license_id"/>
        <ext:column name="number"/>
        <ext:column name="date_received"/>
        <ext:column name="date_terminated"/>
        <ext:column name="full_name"/>
        <ext:column name="licensing_status" searchType="equal"/>
      </ext:table>
    </ext:createSearchCondition>
  </changeSet>
----
====
+
//Створюється користувацький тип даних *`license_status`* з двома можливими значеннями: "діюча" (`active`) та "анульована" (`canceled`).
A custom data type called *`license_status`* is being created with two possible values: "`active`" and "`canceled`".
+
//Створюється нова таблиця *`licenses`* з наступними стовпцями:
A new table called *`licenses`* is being created with the following columns:

//* *`license_id`*: унікальний ідентифікатор ліцензії (`UUID`).
//* *`number`*: номер ліцензії (текстовий формат).
//* *`date_received`*: дата отримання ліцензії (формат дати).
//* *`date_terminated`*: дата припинення ліцензії (формат дати).
//* *`full_name`*: повне ім'я власника ліцензії (текстовий формат).
//* *`licensing_status`*: статус ліцензії (тип даних `license_status`).

* *`license_id`*: unique identifier for the license (`UUID`).
* *`number`*: license number (text format).
* *`date_received`*: date when the license was received (date format).
* *`date_terminated`*: date when the license was terminated (date format).
* *`full_name`*: full name of the license owner (text format).
* *`licensing_status`*: license status (of type `license_status`).
+
//Створюється критерій пошуку (Search condition) із назвою *`search_licenses_by_status`*, який дозволяє здійснювати пошук ліцензій у таблиці *`licenses`* за їх статусом. У цій умові пошуку передбачено, що значення стовпця *`licensing_status`* повинно бути рівним значенню, заданому при пошуку (*`searchType="equal"`*).
A search condition named *`search_licenses_by_status`* is being created, which allows searching for licenses in the *`licenses`* table based on their status. This search condition assumes that the value of the *`licensing_status`* column should be equal to the specified search value (*`searchType="equal"`*).

[start=2]
//. Підготуйте файл-довідник CSV із даними для імпорту в БД.
. Prepare a CSV reference file with data for importing into the database.
+
//Цей файл-довідник CSV містить дані про ліцензії, які можуть бути завантажені до бази даних (таблиці "licenses"). У файлі представлені наступні стовпці:
This CSV reference file contains data about licenses that can be loaded into the database (table "licenses"). The file contains the following columns:
+
//* *`number`*: номер ліцензії.
//* *`licensing_status`*: статус ліцензії (діюча або анульована).
//* *`date_received`*: дата отримання ліцензії.
//* *`date_terminated`*: дата припинення дії ліцензії.
//* *`full_name`*: повне ім'я власника ліцензії (організація або фізична особа).
* *`number`*: license number.
* *`licensing_status`*: license status (active or canceled).
* *`date_received`*: date when the license was received.
* *`date_terminated`*: date when the license was terminated.
* *`full_name`*: full name of the license owner (organization or individual).
+
//Ці дані можуть бути імпортовані в таблицю *`licenses`* бази даних.
These data can be imported into the *`licenses`* table of the database.
+
//. Імпортуйте дані з файлу-довідника CSV за допомогою виклику функції завантаження даних до БД -- *`CALL p_load_table_from_csv()`*. Для цього створіть окремий файл *_populateLicences.xml_*, в якому вкажіть наступну структуру:
. Import the data from the CSV reference file using the data loading function call to the database: *`CALL p_load_table_from_csv()`*. To do this, create a separate file named *_populateLicences.xml_* with the following structure:
+
[source,xml]
----
  <property  name="dataLoadPath"  value="/tmp/data-load/"/>

  <changeSet author="registry owner" id="load licenses">
    <sql dbms="postgresql" endDelimiter=";" splitStatements="true" stripComments="true">
      CALL p_load_table_from_csv('licenses','${dataLoadPath}licenses.csv', array['number', 'licensing_status', 'date_received', 'date_terminated', 'full_name']);
    </sql>
  </changeSet>
----
+
//Ця функція використовує вбудований механізм Liquibase для імпорту даних з CSV-файлу в таблицю бази даних. Використовуються наступні компоненти:
This function uses the built-in Liquibase mechanism to import data from a CSV file into a database table. The following components are used:

//* *`<property>`*: встановлює значення змінної dataLoadPath, яка вказує шлях до каталогу з файлами CSV для завантаження даних.
* *`<property>`*: sets the value of the `dataLoadPath` variable, which specifies the path to the directory containing CSV files for data loading.
//* *`<changeSet>`*: описує зміни, які слід застосувати до бази даних. В цьому випадку -- виклик функції *`p_load_table_from_csv()`* для імпорту даних з CSV-файлу в таблицю *`licenses`*.
* *`<changeSet>`*: describes the changes to apply to the database. In this case, it's a call to the *`p_load_table_from_csv()`* function to import data from the CSV file into the *`licenses`* table.
//* *`<sql>`*: описує SQL-запит, який викликає функцію `p_load_table_from_csv`. Запит включає ім'я таблиці `licenses`, шлях до CSV-файлу (використовуючи змінну `${dataLoadPath}`), та масив зі стовпцями, які слід імпортувати з файлу.
* *`<sql>`*: describes the SQL query that invokes the `p_load_table_from_csv` function. The query includes the name of the `licenses` table, the path to the CSV file (using the `${dataLoadPath}` variable), and an array of columns to import from the file.

//TIP: Детальніше про створення моделі та завантаження даних до реєстру ви можете переглянути у розділах xref:data-modeling/data/physical-model/overview.adoc[] та xref:data-modeling/initial-load/data-initial-data-load-pl-pgsql.adoc[].
TIP: For more information on creating a data model and loading data into the registry, please refer to xref:data-modeling/data/physical-model/overview.adoc[] and  xref:data-modeling/initial-load/data-initial-data-load-pl-pgsql.adoc[].

//== Референтний бізнес-процес
== Reference business process

//=== Створення пулів для процесів
=== Creating pools for processes

//Це комплексний бізнес-процес, який складається з основного процесу та підпроцесів, які він викликає.
This is a complex business process consisting of a main process and subprocesses that it invokes.

//BPMN-діаграма містить основний процес та два підпроцеси, які ініціюються основним через *Call Activity*. Ці підпроцеси є подібними та відрізняються лише назвами задач та порядком їх виконання.
The BPMN diagram includes the main process and two subprocesses initiated by the main process through a *Call Activity*. These subprocesses are similar and differ only in the names of tasks and their execution order.

//У нашому прикладі розглянемо основний процес, а також коротко один із підпроцесів -- анулювання ліцензії.
In our example, we will examine the main process and briefly discuss one of the subprocesses -- license cancellation.

[TIP]
====
//Приклад _.bpmn_-моделі процесу із виконанням дії над багатьма рядками таблиці, а також користувацькі _.json_-форми до нього ви можете знайти у регламенті демо-реєстру *_consent-data_* за посиланням:
You can find an example _.bpmn_ model of the process with multiple row table action and its corresponding custom _.json_ forms in the demo registry regulation at the following link:
https://admin-tools-consent-data.apps.envone.dev.registry.eua.gov.ua/gerrit.

//Процес буде доступний за назвою *_edit-grid-rows-action.bpmn_*. Назви форм ви можете знайти всередині відповідних користувацьких задач бізнес-процесу у полі *`Form key`*.
The process will be available under the name *_edit-grid-rows-action.bpmn_*. The form names can be found inside the respective user tasks of the business process in the *`Form key`* field.

//Споріднена модель процесу із виконанням дії над одним рядком таблиці буде доступний за назвою *_bp-action-one-row-grid.bpmn_*.
The related model of the process with single row table action will be available under the name *_bp-action-one-row-grid.bpmn_*.
====

//=== Вибір усіх органів ліцензування з БД через критерій пошуку
=== Selecting all licensing authorities from the database using search condition

//Змоделюйте сервісну задача (Service Task) та використайте делегат *Search entities in data factory*.
Model a Service Task and utilize the delegate *Search entities in data factory*.

//На основі створеної моделі даних, ця задача відповідає за пошук та вибірку ліцензій з таблиці *`licenses`*. Таблиця *`licenses`* містить наступні стовпці:
Based on the created data model, this task is responsible for searching and selecting licenses from the *`licenses`* table. The *`licenses`* table contains the following columns:

//* `license_id` -- унікальний ідентифікатор ліцензії (`UUID`).
//* `number` -- номер ліцензії (`TEXT`).
//* `date_received` -- дата отримання ліцензії (`DATE`).
//* `date_terminated` -- дата припинення ліцензії (`DATE`).
//* `full_name` -- повне ім'я органу ліцензування (`TEXT`).
//* `licensing_status` -- статус ліцензії (тип даних `license_status`).
* `license_id`: unique identifier of the license (`UUID`).
* `number`: license number (`TEXT`).
* `date_received`: date of license issuance (`DATE`).
* `date_terminated`: date of license termination (`DATE`).
* `full_name`: full name of the licensing authority (`TEXT`).
* `licensing_status`: license status (data type: `license_status`).

//Тип даних *`license_status`* є переліком з двома можливими значеннями:
The *`license_status`* data type is an enumeration with two possible values:

//* *`active`* (чинна) -- ліцензія є дійсною.
//* *`canceled`* (анульована) -- ліцензія скасована.
* *`active`*: the license is valid.
* *`canceled`*: the license is canceled.

//Поточна задача використовує умову пошуку (Search condition) *`search_licenses_by_status`*, яка дозволяє фільтрувати ліцензії в таблиці *`licenses`* за статусом ліцензування. У цьому випадку, задача шукає ліцензії зі статусом *`active`* (чинні).
The current task uses the search condition *`search_licenses_by_status`* to filter licenses in the *`licenses`* table based on their licensing status. In this case, the task searches for licenses with the status *`active`*.

//Таким чином, сервісне завдання виконує пошук активних ліцензій у таблиці *`licenses`* на основі визначених умов пошуку, передаючи системний токен доступу для авторизації запиту до бази даних.
Thus, the service task performs a search for active licenses in the *`licenses`* table based on the defined search conditions, passing the system access token for query authorization to the database.

//Параметри які використовуються для налаштування та отримання результатів пошуку: ::
The parameters used for configuration and obtaining search results are as follows: ::

//. У секції *Inputs* встановіть вхідний параметр *`resource`* як *`search-licenses-by-status`* для визначення ресурсу/API-ендпоінту, який слід використати для пошуку.
. In the *Inputs* section, set the input parameter *`resource`* as *`search-licenses-by-status`* to determine the resource/API endpoint to be used for the search.
+
//TIP: Тут ендпоінт `search-licenses-by-status` генерується на базі критерію пошуку `search_licenses_by_status`, визначеного у моделі даних.
TIP: Here, the endpoint `search-licenses-by-status` is generated based on the search criterion `search_licenses_by_status` defined in the data model.
+
//. У секції *Inputs > Search variables* передайте параметри пошуку, які необхідно застосувати, як ключі-значення (*`Map`*):
. In the *Inputs > Search variables* section, provide the search parameters to be applied as key-value pairs (*`Map`*):

* `Key: *licensingStatus*`
* `Value: *active*`
+
//У цьому випадку, ми шукаємо ліцензії зі статусом *`active`*.
In this case, we are searching for licenses with the status *`active`*.
+
//. У секції *Inputs > X-Access-Token* передайте системний токен доступу для авторизації запита до бази даних:
. In the *Inputs > X-Access-Token* section, pass the system access token for query authorization to the database:
+
----
${system_user().accessToken}
----
+
//. У секції *Outputs > Result variable* встановіть вихідний параметр як змінну *`licensesResponse`*, до якої зберігатиметься відповідь від бази даних для подальшого використання.
. In the *Outputs > Result variable* section, set the output parameter as the variable *`licensesResponse`*, which will store the response from the database for further use.

image:best-practices/edit-grid-rows-action/edit-grid-rows-action-1.png[]

//=== Скрипт підготовки даних для відображення на формі у табличному вигляді
===  Data preparation script for displaying in tabular form

//Змоделюйте сервісну задачу та використайте наступний groovy-скрипт.
Model the service task and use the following Groovy script.

image:best-practices/edit-grid-rows-action/edit-grid-rows-action-2.png[]

.Скрипт для отримання списку ліцензій та виведення їх на форму
.Script for retrieving alList of licenses and displaying them on a form
====
[source,groovy]
----
def licenses = licensesResponse.responseBody.elements()

        def payload = S([:], 'application/json')
        payload.prop('licenses', licenses)
        set_transient_variable('payload', payload)
----
====

//Цей скрипт виконує наступні дії:
This script performs the following actions:

//. Витягує список ліцензій з відповіді *`licensesResponse.responseBody.elements()`*. Змінна *`licenses`* містить список активних ліцензій, отриманих від попереднього сервісного завдання.
. Extracts the list of licenses from the response *`licensesResponse.responseBody.elements()`*. The variable *`licenses`* contains the list of active licenses obtained from the previous service task.
+
//. Створює новий об'єкт JSON *`payload`* з порожнім словником.
. Creates a new JSON object *`payload`* with an empty dictionary.
+
//. Додає до об'єкта JSON *`payload`* список ліцензій, отриманий на першому кроці, під ключем *`licenses`*.
. Adds the list of licenses obtained in the first step to the JSON object *`payload`*, under the key *`licenses`*.
+
//. Зберігає JSON об'єкт *`payload`* у транзієнтну змінну (тимчасову змінну, яка існує лише під час виконання процесу) з назвою *`payload`*.
. Stores the JSON object *`payload`* in a transient variable (a temporary variable that exists only during the process execution) named *`payload`*.

//=== Обрання дії над даними в одному рядку таблиці
=== Performing an action on data in a single row of a table

//Змоделюйте користувацьку задачу (User Task) та поєднайте її з відповідною UI-формою за ключем *`Form key`*.
Model a User Task and associate it with the corresponding UI form using the *`Form key`* key.

//Основна мета цієї форми -- дозволити користувачу обрати дію, яку він хоче виконати над даними у певному рядку таблиці за допомогою компонента *Edit Grid* (змінити дату або анулювати ліцензію).
The main goal of this form is to allow the user to select an action to perform on the data in a specific row of a table using the *Edit Grid* component (such as changing the date or canceling a license).

//Виконайте наступні налаштування: ::
Perform the following configurations: ::

//. У полі *`Name`* введіть назву користувацької задачі.
. In the *Name* field, enter the name of the User Task.
//. Застосуйте шаблон делегата -- *`User Form`*.
. Apply the delegate template -- *`User Form`*.
//. У полі *`ID`* введіть ідентифікатор задачі -- *`defineActionActivity`*.
. In the *`ID`* field, enter the task identifier -- *`defineActionActivity`*.
//. У полі *`Form key`* визначте ключ для поєднання із відповідною змодельованою формою бізнес-процесу -- *`feature-edit-grid-rows-action-define`*.
. In the *`Form key`* field, define the key to connect with the corresponding modeled form of the business process -- *`feature-edit-grid-rows-action-define`*.
//. У полі `Assignee` вкажіть змінну для особи, якій призначається поточна задача, -- *`${initiator}`*.
. In the *Assignee* field, specify the variable for the person assigned to the current task -- *`${initiator}`*.
//. У полі *`Form data pre-population`* передайте дані на UI-форму як змінну ${payload}.
. In the *`Form data pre-population`* field, pass the data to the UI form as the variable *`${payload}`*.


image:best-practices/edit-grid-rows-action/edit-grid-rows-action-3.png[]

//=== Моделювання XOR-шлюзу та додавання логіки через вирази умови
=== Modeling an XOR gateway and adding logic through condition expressions

//Змоделюйте XOR-шлюз, який визначає, який з підпроцесів слід викликати на основі *`action codes`*, обраних на попередній формі.
Model an XOR Gateway that determines which subprocess to call based on the *`action codes`* selected on the previous form.

//TIP: Action codes -- кнопки у контекстному меню "Три крапки", змодельовані на UI-формі за допомогою елемента *`Edit Grid`*.
TIP: Action codes are buttons in the context menu (three dots), modeled on the UI form using the *`Edit Grid`* element.

image:best-practices/edit-grid-rows-action/edit-grid-rows-action-4.png[]

[NOTE]
====
//Якщо на формі *`defineActionActivity`* обрано чекбокс з декількома рядками (записами) таблиці, то для кожного з цих рядків запуститься підпроцес відповідно до обраної кнопки на UI-формі (у цьому контексті це мають бути _окремі кнопки_, змодельовані через компонент *Button*). Запуск підпроцесу для кожного з обраних рядків можливий завдяки функції мультиекземпляра *`Multi-instance`* (_див.xref:#call-activity-cancel[]_).
If the multiple rows (records) checkbox is selected on the *`defineActionActivity`* form, a subprocess will be triggered for each of these rows according to the selected button on the UI form (in this context, these should be _separate buttons_ modeled using the *Button* component). Launching a subprocess for each selected row is made possible by the *`Multi-instance`* feature (see _xref:#call-activity-cancel[]_ ).

//Якщо ви обрали контекстне меню "Три крапки" навпроти певного рядка, то відповідний підпроцес запуститься лише для даних цього рядка. Який саме підпроцес запуститься -- регулюється логікою кодів дії  (action codes), змодельованих на формі у компоненті *Edit Grid*. Тобто контекстне меню "Три крапки" дозволяє обрати логіку виконання дії над одним рядком таблиці.
If you select the context menu (three dots) next to a specific row, the corresponding subprocess will only be triggered for the data in that row. The specific subprocess to be launched is controlled by the action code logic, modeled on the *Edit Grid* component. In other words, the context menu (three dots) allows you to choose the execution logic for an individual row of the table.
====

//Залежно від дії, визначеної в action codes (у нашому прикладі ми оновлюємо дані лише по одному рядку на формі, тому використовуємо лише action codes через контекстне меню), основний процес ініціює один з наступних підпроцесів через *Call Activity*:
Depending on the action defined in the action codes (in our example, we only update data for one row on the form, so we only use action codes through the context menu), the main process initiates one of the following subprocesses through the *Call Activity*:

//. Процес "Зміна дати терміну дії ліцензії", якщо введений action code відповідає наступній умові:
. The `Change license expiry date process` if the entered action code satisfies the following condition:
+
[source,juel]
----
${submission('defineActionActivity').formData.hasProp('_action_code') && submission('defineActionActivity').formData.prop('_action_code').value().equals('_action_update')}
----
+
image:best-practices/edit-grid-rows-action/edit-grid-rows-action-4-1.png[]
+
//. Процес "Скасування ліцензії", якщо введений action code відповідає наступній умові:
. `License Cancellation` process if the entered action code satisfies the following condition:
+
[source,juel]
----
${submission('defineActionActivity').formData.hasProp('_action_code') && submission('defineActionActivity').formData.prop('_action_code').value().equals('_action_cancel')}
----
+
image:best-practices/edit-grid-rows-action/edit-grid-rows-action-4-2.png[]

//Після виклику відповідного підпроцесу за допомогою Call Activity, основний процес продовжується до кінцевої події. Далі розглянемо потік із викликом підпроцесу для скасування ліцензії.
After calling the corresponding subprocess using the Call Activity, the main process continues to the final event. Next, we will discuss the flow with the cancellation subprocess call.

[#call-activity-cancel]
//=== Call Activity для виклику підпроцесу скасування ліцензії
=== Call Activity for the license cancellation subprocess

//Цей Call Activity виконує процес з іменем *`license-cancellation`* для кожного елемента в колекції даних, яка вказана в `multiInstanceLoopCharacteristics`. Тобто якщо на формі з Edit Grid ви обрали чекбокс на одному і більше записів, то при використанні функції Multi-instance, підпроцес запуститься для кожного з таких записів.
This Call Activity executes a process named *`license-cancellation`* for each item in the data collection specified in `multiInstanceLoopCharacteristics`. This means that if you select the checkbox on one or more records in the Edit Grid form, using the Multi-instance feature, the subprocess will be triggered for each of those records.

[NOTE]
====
//Зверніть увагу, що коли обрано чекбокс дії над одним і більше рядком таблиці, дані з форми мають надсилатися до процесу за action-кодами, які змодельовані на UI-формі через компонент *Button*.
Note that when the checkbox for multiple rows in the table is selected, the data from the form should be sent to the process based on the action codes modeled on the UI form using the *Button* component.

//Детальніше про це див. у розділі
For more details, see
xref:#modeling-forms[].
====

[TIP]
====
//Детальніше про Call Activity та особливості їх застосування ви можете переглянути на сторінках:
For more details on Call Activity and its application features, you can review the following pages:

* xref:bp-modeling/bp/element-templates/bp-element-templates-installation-configuration.adoc[]
* xref:bp-modeling/bp/bpmn/subprocesses/overview.adoc[]
====

//Виконайте наступні налаштування: ::
Perform the following configurations: ::
+
//. У секції *Multi-instance* > *`Collection`* введіть значення:
. In the *Multi-instance* > *`Collection`* section, enter the value:
+
----
${submission('defineActionActivity').formData.prop('licenses').elements()}
----
+
//. Для *Multi-instance* > *`Element variable`* вкажіть змінну *`license`*.
. For *Multi-instance* > *`Element variable`*, specify the variable *`license`*.
+
[NOTE]
====
//Це означає, що Call Activity буде виконана для кожного елемента в колекції даних, який повертається функцією *`${submission('defineActionActivity').formData.prop('licenses').elements()}`*. Кожен елемент цієї колекції буде збережений до визначеної змінної *`license`*.
This means that the Call Activity will be performed for each element in the data collection returned by the function ${submission('defineActionActivity').formData.prop('licenses').elements()}. Each element of this collection will be stored in the defined variable license.

//Використання функції *`Multi-instance`* також показано на прикладі
The use of the Multi-instance feature is also demonstrated in the example
xref:registry-admin/user-notifications/email/e-mail-notification.adoc[].
====
+
//. У полі *`Called element`* вкажіть ідентифікатор (Process ID) підпроцесу, який необхідно викликати та запустити. У нашому випадку -- це *`license-cancellation`*.
. In the *`Called element`* field, specify the identifier (Process ID) of the subprocess to be called and executed. In our case, it is *`license-cancellation`*.
+
//. Для поля *`Asynchronous continuation`* вкажіть значення *`Before`*. Це означає, що ця активність буде виконана асинхронно. Асинхронне виконання починається перед виконанням самого Call Activity, тобто "асинхронно перед".
. For the *`Asynchronous continuation`* field, specify the value *`Before`*. This means that this activity will be performed asynchronously. Asynchronous continuation starts before the execution of the Call Activity itself, meaning "asynchronously before."
+
[TIP]
====
.Що таке Asynchronous continuation?
.What is Asynchronous continuation?
[%collapsible]
=====
//*Asynchronous continuation* у Call Activity в Camunda BPM -- це механізм, що дозволяє виконати активність асинхронно відносно основного потоку процесу. Це означає, що активність (у цьому випадку Call Activity) може бути виконана пізніше, не затримуючи виконання наступних елементів в основному потоці.
*Asynchronous continuation* in Call Activity in Camunda BPM is a mechanism that allows executing an activity asynchronously in relation to the main process flow. This means that the activity (in this case, Call Activity) can be executed later without delaying the execution of subsequent elements in the main flow.

//Asynchronous continuation часто використовується, коли потрібно запустити довготривалу або ресурсомістку операцію без блокування подальшого виконання процесу. Це може бути корисним, наприклад, коли Call Activity викликає зовнішній процес, який може тривати певний час.
Asynchronous continuation is often used when it is necessary to initiate a long-running or resource-intensive operation without blocking the further execution of the process. This can be useful, for example, when the Call Activity invokes an external process that may take some time.

//Після завершення асинхронної операції, робота процесу продовжується з наступної точки, після Call Activity. Asynchronous continuation також дозволяє системі керування процесами (наприклад, Camunda BPM) більш ефективно управляти ресурсами, розподіляючи навантаження між різними екземплярами процесу.
After the completion of the asynchronous operation, the process workflow continues from the next point after the Call Activity. Asynchronous continuation also enables process management systems (such as Camunda BPM) to more efficiently manage resources by distributing the load among different process instances.

//*`Asynchronous continuation: before`* в контексті Camunda BPM означає, що асинхронний виклик відбувається перед запуском Call Activity, а не після його завершення.
In the context of Camunda BPM, *`asynchronous continuation: before`* means that the asynchronous invocation takes place before the start of the Call Activity, rather than after its completion.

//Такий варіант використання асинхронного продовження може бути корисним, коли вам потрібно запустити довготривалу або ресурсомістку активність (як-от Call Activity), але ви не хочете блокувати виконання основного потоку процесу, поки ця активність не буде виконана.
This use of asynchronous continuation can be useful when you need to initiate a long-running or resource-intensive activity (such as a Call Activity), but you don't want to block the execution of the main process flow until this activity is completed.
=====
====

+
image:best-practices/edit-grid-rows-action/edit-grid-rows-action-5.png[]
+
//. У полі In mappings вкажіть:
. In the *In mappings* field, specify:

* `Source: *Type*`
* `source: *license*`
* `target: *license*`
+
//Це означає, що дані зі змінної license в основному процесі будуть передані до підпроцесу `license-cancellation` і збережені до змінної під таким же іменем.
This means that the data from the variable license in the main process will be passed to the license-cancellation subprocess and stored in a variable with the same name.

+
image:best-practices/edit-grid-rows-action/edit-grid-rows-action-5-1.png[]

[CAUTION]
====
//Якщо на формі бізнес-процесу ви обираєте дію над одним рядком таблиці, використовуючи при цьому контекстне меню "Три крапки" *`&#x22EE;`* (_див. детальніше про моделювання форм у розділі xref:#modeling-forms[]_), то змоделювати бізнес-процес в такому разі можна двома способами:
If you choose an action on a single row of the table using the context menu (three dots) *`&#x22EE;`* (see more about form modeling in xref:#modeling-forms[]), you can model the business process in two ways:

//* з використанням Multi-instance у Call Activity (як показано вище у розділі);
//* з використанням базових налаштувань Call Activity.
* Using Multi-instance in the Call Activity (as shown above in the section).
* Using basic configurations of the Call Activity.

//Базові налаштування Call Activity в такому випадку виглядатимуть майже ідентично до опції з Multi-instance:
The basic configurations of the Call Activity in this case will look almost identical to the Multi-instance option:

//* Вкажіть тип вхідних параметрів -- *`Source expression`*.
* Specify the input parameter type as *`Source expression`*.

//* Вкажіть вираз для отримання даних з форми за допомогою функції `submission()`.
* Specify an expression to retrieve data from the form using the `submission()` function.
+
[source,juel]
----
${submission('defineActionActivity').formData.prop('licenses').elements()[0]}
----
+
// Вкажіть *`Target`* -- *`license`*.
* Specify the *`Target`* as *`license`*.
+
//Це означає, що дані зі змінної license в основному процесі будуть передані до підпроцесу `license-cancellation` і збережені до змінної під таким же іменем.
This means that the data from the variable license in the main process will be passed to the `license-cancellation` subprocess and stored in a variable with the same name.

image:best-practices/edit-grid-rows-action/edit-grid-rows-action-10.png[]

====

//=== Користувацька задача для ануляції ліцензії
=== User task for license cancellation

//Змоделюйте користувацьку задачу (*User Task*), яка надасть можливість для користувача анулювати ліцензію.
Model a User Task that allows the user to cancel a license.

//. Використовуйте шаблон делегата *`User Form`* для створення форми користувача.
. Use the *`User Form`* delegate template to create the user form.
+
//. Вкажіть ідентифікатор форми, яка повинна бути показана користувачу, у цьому випадку -- *`edit-grid-rows-action-cancel-license`*.
. Specify the form ID to be shown to the user, in this case - *`edit-grid-rows-action-cancel-license`*.
+
//. Задача може бути призначена користувачеві (`Assignee`), але в цьому випадку поле можна залишити порожнім, що означає, що будь-який користувач може взяти її до виконання.
. The task can be assigned to a user (`Assignee`), but in this case, the field can be left empty, which means any user can claim and execute it.
+
//. У полі Candidate roles вкажіть роль. Поле вказує на те, що цю задачу зможуть бачити та виконувати користувачі з певною роллю/ролями, у нашому випадку -- *`op-regression`*.
. In the *Candidate roles* field, specify the role. This field indicates that users with a specific role/roles, in our case -- *`op-regression`*, can view and execute this task.
+
//. У полі Form data pre-population передайте дані про ліцензію як змінну *`${license}`*, що будуть виведені на форму для попереднього заповнення даних.
. In the Form data pre-population field, pass the license data as the variable *`${license}`*, which will be displayed on the form for pre-filling the data.

image:best-practices/edit-grid-rows-action/edit-grid-rows-action-6.png[]

//=== Підготовка даних для запису (transient var)
=== Data preparation for recording (transient var)

//Змоделюйте скрипт-задачу (Script Task) та застосуйте скрипт, який зможе отримати дані із попередньої задачі (форми) та підготує їх для запису до БД (у нашому випадку -- до оновлення сутності).
Model a Script Task and apply a script that can retrieve data from the previous task (form) and prepare it for recording in the database (in our case, updating an entity).

image:best-practices/edit-grid-rows-action/edit-grid-rows-action-7.png[]

._Groovy-скрипт для отримання даних з форми cancelLicenseActivity та підготовки їх до запису_
[%collapsible]
._Groovy script to retrieve data from the cancelLicenseActivity form and prepare it for recording_
====
[source,groovy]
----
def canceledLicense = submission('cancelLicenseActivity').formData
        canceledLicense.prop('licensingStatus', 'canceled')
        set_transient_variable('canceledLicense', canceledLicense)
----

//Цей скрипт виконує наступні дії:
This script performs the following actions:

//. Отримує дані форми, що були відправлені користувачем у задачі *`cancelLicenseActivity`*. Результат цього виразу зберігається у змінній *`canceledLicense`*.
. Retrieves the form data that was submitted by the user in the *`cancelLicenseActivity`* task. The result of this expression is stored in the variable *`canceledLicense`*.
+
[source,groovy]
----
submission('cancelLicenseActivity').formData
----
+
//. Встановлює властивість *`licensingStatus`* об'єкта *`canceledLicense`* у значення *`canceled`*. Це означає, що ліцензію відмічено як "_скасовану_".
. Sets the *`licensingStatus`* property of the *`canceledLicense`* object to the value *`canceled`*. This means that the license is marked as "canceled".
+
[source,groovy]
----
canceledLicense.prop('licensingStatus', 'canceled')
----
+
//. Створює тимчасову (transient) змінну з іменем *`'canceledLicense'`*, значення якої встановлюється в об'єкт *`canceledLicense`*. Тимчасова змінна зберігається лише протягом поточного виконання процесу і не зберігається до бази даних.
. Creates a transient variable named '*`canceledLicense`*' with the value set to the *`canceledLicense`* object. Transient variables are only stored during the current execution of the process and are not persisted to the database.
+
[source,groovy]
----
set_transient_variable('canceledLicense', canceledLicense)
----
====

//=== Підписання даних КЕП та накладання системного підпису
=== Data signing with the qualified digital signature and system signature

//Далі змоделюйте відповідні задачі для підписання даних КЕП та системним ключем. Використовуйте для цього делегати *Officer sign task* та *System signature by DSO service відповідно*.
Next, model the corresponding tasks for data signing with a digital signature and system key. Use the *Officer sign task* and *System signature by DSO service* delegates, respectively.

//TIP: Приклади моделювання таких задач ви можете переглянути на сторінці
TIP: You can refer to the Modeling Examples for such tasks at
xref:best-practices/bp-officer-self-register-manual.adoc[].


//=== Зберегти оновлені дані обраного рядка у таблиці на формі до БД
=== Saving the updated data of the selected row in the table on the form to the database.

//Змоделюйте сервісну задачу, яка виконає операцію оновлення даних за обраним записом у БД.
Model a service task that will perform the operation of updating data for the selected record in the database.

//. Використовуйте делегат *Update entity in data factory*, що є класом Java, який містить логіку для виконання цієї задачі.
. Use the *Update entity in data factory* delegate, which is a Java class that contains the logic to perform this task.
+
//Альтернативно, ви можете застосувати загальний конектор до Фабрики даних *Connect to data factory*, використавши метод *`PUT`*.
Alternatively, you can apply the general *Connect to data factory* connector, using the *`PUT`* method.
+
[TIP]
====
//Детальніше про це див. на сторінці
For more information, refer to
xref:bp-modeling/bp/element-templates/bp-element-templates-installation-configuration.adoc[].
====
+
//. Вкажіть *`resource`*, що вказує на ресурс, тобто таблицю яку потрібно оновити, у цьому випадку -- *`licenses`*.
. Specify the *`resource`* that indicates the resource, i.e., the table that needs to be updated, in this case - *`licenses`*.
+
//. Вкажіть `Resource id`, що визначає ідентифікатор ліцензії, яку потрібно оновити. Наприклад:
. Specify the `Resource id` that defines the identifier of the license that needs to be updated. For example:
+
----
${license.prop('licenseId').value()}
----
+
//. У полі *`Payload`* передайте дані, що потрібно оновити для вказаної ліцензії. Ці дані беруться з тимчасової змінної `canceledLicense`, що була встановлена у попередніх кроках процесу. Це можна зробити за допомогою функції `submission()`. Наприклад:
. In the *`Payload`* field, pass the data that needs to be updated for the specified license. This data is taken from the temporary variable `canceledLicense`, which was set in the previous steps of the process. This can be done using the `submission()` function. For example:
+
----
${submission('signCanceledLicenseActivity').formData}
----
+
//. Передайте токен доступу до ресурсу -- *`X-Access-Token`*, отриманий із задачі `signCanceledLicenseActivity`. Це можна зробити за допомогою функції completer(). Наприклад:
. Pass the access token to the resource -- *`X-Access-Token`*, obtained from the `signCanceledLicenseActivity` task. This can be done using the `completer()` function. For example:
+
----
${completer('signCanceledLicenseActivity').accessToken}
----
+
//. Передайте містять ключі для цифрового підпису даних КЕП та системним ключем у полях `X-Digital-Signature source` і `X_Digital-Signature-Derived source` відповідно. Наприклад:
. Pass the keys for the digital signature of the CEP data and the system key in the `X-Digital-Signature source` and `X_Digital-Signature-Derived source` fields, respectively. For example:
+
.КЕП
.Qualified digital signature
----
${sign_submission('signCanceledLicenseActivity').signatureDocumentId}
----
+
.Системний підпис
.System signature
----
${system_signature_ceph_key}
----
+
//. Результат запита збережіть у вихідний параметр *`response`*.
. Save the result of the request in the output parameter *`response`*.

image:best-practices/edit-grid-rows-action/edit-grid-rows-action-8.png[]

//=== Завершення процесу та повернення користувача на початкову форму
=== Completing the process and returning the user to the initial form.

//Після оновлення сутності у Фабриці даних, підпроцес, що викликали, завершується, результат повертається назад до Call Activity, і користувач повертається на початок основного процесу. Переадресація користувача можлива завдяки змодельованим подіям "З'єднання" (*Link event*).
After updating the entity in the Data Factory, the sub-process that invoked it is completed, and the result is returned back to the Call Activity, and the user is returned to the beginning of the main process. User redirection is possible thanks to the modeled *Link events*.

image:best-practices/edit-grid-rows-action/edit-grid-rows-action-9.png[]

//TIP: Детальніше про подію "З'єднання" ви можете дізнатися на сторінці
TIP: For more information about the "Link" event, you can refer to
xref:bp-modeling/bp/bpmn/events/bp-link-events.adoc[].

[#modeling-forms]
//== Моделювання UI-форм до бізнес-процесу
== Modeling UI Forms for business processes

//Розглянемо приклад моделювання користувацької форми для перегляду та виконання дій над певними рядками таблиці за допомогою компонента Edit Grid.
Let's consider an example of modeling a user form for viewing and performing actions on specific rows of a table using the Edit Grid component.

//Також змоделюємо дві кнопки через компонент Button для виконання додаткової логіки.
We will also model two buttons using the Button component to perform additional logic.

[NOTE]
====
//Якщо на формі *`defineActionActivity`* обрано чекбокс з декількома рядками (записами) таблиці, то для кожного з цих рядків запуститься підпроцес відповідно до обраної кнопки на UI-формі (у цьому контексті це мають бути _окремі кнопки_, змодельовані через компонент *Button*). Запуск підпроцесу для кожного з обраних рядків можливий завдяки функції мультиекземпляра *`Multi-instance`* (_див.xref:#call-activity-cancel[]_).
If the multi-row checkbox is selected on the *`defineActionActivity`* form, a subprocess will be launched for each of these rows based on the selected button on the UI form (in this context, these should be _separate buttons_ modeled using the *Button* component). Launching a subprocess for each selected row is possible using the Multi-instance function (see _xref:#call-activity-cancel[]_).

//Якщо ви обрали контекстне меню "Три крапки" навпроти певного рядка, то відповідний підпроцес запуститься лише для даних цього рядка. Який саме підпроцес запуститься -- регулюється логікою кодів дії  (action codes), змодельованих на формі у компоненті *Edit Grid*. Тобто контекстне меню "Три крапки" дозволяє обрати логіку виконання дії над одним рядком таблиці.
If you select the context menu "Three dots" next to a specific row, the corresponding subprocess will only be launched for the data of that row. The specific subprocess to be launched is determined by the action codes logic modeled on the *Edit Grid* component on the form. Therefore, the context menu "Three dots" allows selecting the logic for performing an action on a single table row.
====

//. Перейдіть до конструктора форм у Кабінеті адміністратора регламентів, створіть нову форму та змоделюйте компонент *Edit Grid*, який складається з 5-ти текстових полів (*Text Field*) для таблиці.
. Go to the form builder in the Administrator of Regulations Portal, create a new form, and model the *Edit Grid* component, which consists of 5 text fields (*Text Field*) for the table.
+
//. Перейдіть до налаштувань компонента *Edit Grid*.
. Go to the settings of the *Edit Grid* component.
+
image:best-practices/edit-grid-rows-action/forms/edit-grid-rows-action-form-1.png[]
+
//. Введіть назву (*`Label`*) для цього компонента, що відображатиметься на формі, та активуйте опції `Multiple-record selection` та `Read Only`.
. Enter a name (*`Label`*) for this component, which will be displayed on the form, and activate the options `Multiple-record selection` and `Read Only`.
+
//* `Multiple-record selection` дозволяє користувачам вибирати кілька записів в таблиці одночасно.
* `Multiple-record selection` allows users to select multiple records in the table simultaneously.
//* `Read Only` показує дані через окремий елемент управління в контекстному меню (три вертикальних крапки), який дозволяє переглядати дані без можливості редагування.
* `Read Only` displays data through a separate control element in the context menu (three vertical dots), which allows viewing data without the ability to edit.

+
image:best-practices/edit-grid-rows-action/forms/edit-grid-rows-action-form-2.png[]

+
//. Перейдіть на вкладку *API* та введіть службову назву компонента для використання в API-запитах. У нашому випадку -- це `licences`, що відповідає назві таблиці в БД.
. Switch to the *API* tab and enter a service name for the component to be used in API requests. In our case, it is `licenses`, which corresponds to the table name in the database.
+
image:best-practices/edit-grid-rows-action/forms/edit-grid-rows-action-form-3.png[]
//. Перейдіть на вкладку *Logic* та додайте коди дій (action codes) для опцій контекстного меню "Три крапки", які будуть доступні для виконання дії над певним рядком на формі під час виконання бізнес-процесу.
. Switch to the *Logic* tab and add action codes for the options in the context menu "Three dots" that will be available for performing an action on a specific row on the form during the execution of the business process.
+
[NOTE]
====
//Розробник регламенту повинен уникати моделювання дій за допомогою `action_code` у контекстному меню "три крапки" рядка таблиці, коли EditGrid налаштовано в режимі редагування. Якщо цього не зробити, відредаговані дані можуть залишитися незбереженими, а користувач автоматично перейде за `action_code` до наступного БП.
The regulation developer should avoid modeling actions using the `action_code` in the context menu "Three dots" of a table row when EditGrid is in edit mode. Failure to do so may result in unsaved edited data, and the user will automatically move to the next business process based on the action_code.

//Замість цього, користувача слід направити на форму підпису після редагування даних, щоб забезпечити збереження всіх внесених змін.
Instead, the user should be directed to a signing form after editing the data to ensure that all changes are saved.
====
+
image:best-practices/edit-grid-rows-action/forms/edit-grid-rows-action-form-4.png[]

+
//. Змоделюйте компонент *Button* для додаткової двох додаткових кнопок, щоб мати можливість виконувати дії над декількома рядками таблиці одночасно, коли активована опція `Multiple-record selection` в Edit Grid.
. Model the *Button* component for two additional buttons to be able to perform actions on multiple rows of the table simultaneously when the Multiple-record selection option is activated in Edit Grid.
+
//* Додайте кнопку оновлення терміну дії ліцензії (для одного і більше записів у таблиці, за умови використання чекбоксу `Multiple-record selection` в Edit Grid).
* Add a button to update the license action period (for one or more records in the table, provided the `Multiple-record selection` checkbox is used in Edit Grid).
+
image:best-practices/edit-grid-rows-action/forms/edit-grid-rows-action-form-5.png[]
+
image:best-practices/edit-grid-rows-action/forms/edit-grid-rows-action-form-6.png[]
+
//* Додайте кнопку скасування ліцензії (для одного і більше записів у таблиці, за умови використання чекбоксу `Multiple-record selection` в Edit Grid).
* Add a button to cancel the license (for one or more records in the table, provided the `Multiple-record selection` checkbox is used in Edit Grid).
+
image:best-practices/edit-grid-rows-action/forms/edit-grid-rows-action-form-7.png[]
+
image:best-practices/edit-grid-rows-action/forms/edit-grid-rows-action-form-8.png[]
+
//. Збережіть зміни та застосуйте конфігурацію до майстер-гілки.
. Save the changes and apply the configuration to the master branch.

//TIP: Читайте про можливості Edit Grid у розділі документації
TIP: Read about the capabilities of the Edit Grid component at
xref:bp-modeling/forms/components/edit-grid/edit-grid.adoc[].

//== Використання у Кабінетах користувачів
== Usage in user portals

//Змодельований бізнес-процес можна буде знайти у списку доступних послуг Кабінету посадової особи у демо-реєстрі _consent-data_.
The modeled business process can be found in the list of available services in the User Portal of the authorized person in the _consent-data_ demo registry.

.Бізнес-процес у Кабінеті
.Business process in the user portal
image::release-notes:wn-1-9-4/whats-new-1-9-4-8.png[]

.Виконання дії над одним рядком у таблиці
.Performing an action on a single row in the table
image::release-notes:wn-1-9-4/whats-new-1-9-4-5.png[]

.Виконання дії над декількома рядками у таблиці
.Performing an action on multiple rows in the table
image::release-notes:wn-1-9-4/whats-new-1-9-4-9.png[]





