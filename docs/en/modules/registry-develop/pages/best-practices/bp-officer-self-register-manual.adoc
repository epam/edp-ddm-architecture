//= Самостійна реєстрація користувачів з ручною модерацією
= Officer self-registration with manual moderation
include::platform:ROOT:partial$templates/document-attributes/default-set-en.adoc[]

include::platform:ROOT:partial$admonitions/language-en.adoc[]

//== Загальний опис
== General overview

//Розглянемо опис бізнес-процесу автоматичної реєстрації посадових осіб (надавачів послуг) із ручним підтвердженням даних модератором.
Let us take a look at the business process of automatic registration of Officers (service providers) with manual data verification by a moderator.

//Бізнес-процес складається з двох пулів, що представляють двох учасників: посадову особу-заявника, яка самореєструється, та модератора, який перевіряє дані. Обмін інформацією між учасниками здійснюється через події повідомлень (*Message events*).
The business process consists of two pools representing two participants: the Officer applicant who self-registers and the moderator who verifies the data. Information exchange between participants is carried out through *message events*.

//Заявник вводить особисті дані на формі, які надсилаються модератору для перевірки. Модератор має певний час (_тут -- 2 хвилини_) на прийняття рішення, контрольоване таймером (*Timer boundary event*). Якщо рішення не прийнято вчасно, процес іде за альтернативним потоком та завершується, а користувач не реєструється.
The applicant enters personal data on a form, which is sent to the moderator for verification. The moderator has a specific time frame (_here - 2 minutes_) to make a decision, controlled by a *timer boundary event*. If a decision is not made in time, the process follows an alternative path and terminates, and the user is not registered.

//У разі позитивного рішення, дані підписуються КЕП і системним ключем, після чого зберігаються до системної таблиці (_тут_ -- `officer`) бази даних реєстру, відповідно до створеної попередньо моделі даних. Інформація про рішення надсилається заявнику через подію повідомлення. Якщо рішення негативне, процес іде за альтернативним потоком, і користувача не реєструють.
In case of a positive decision, the data is signed with a qualified electronic signature (QES) and a system key, then stored in the system's database table (_here_ - `officer`) according to the previously created data model. Information about the decision is sent to the applicant through a notification event. If the decision is negative, the process follows an alternative path, and the user is not registered.

//При позитивному рішенні, інформація передається на сервісну задачу із делегатом *Save user roles*, який змінює роль користувача з *`unregistered-officer`* на *`officer`*. Таким чином, користувач реєструється в системі.
Upon a positive decision, the information is passed to a service task with the delegate *Save user roles*, which changes the user's role from *`unregistered-officer`* to *`officer`*. Thus, the user is registered in the system.

//Заявник переходить на форму із повідомленням про успішну самореєстрацію та статусом "`Самореєстрацію пройдено`". Після цього заявник перенаправляється на форму для повторного входу в систему.
The applicant is redirected to a page confirming successful self-registration with the status `Registration complete`. Afterward, the applicant is redirected to a login page.

//Після повторної автентифікації з роллю *`officer`*, посадова особа отримує доступ до усіх послуг, доступних йому у реєстрі. Зареєстрований користувач з роллю `officer` зможе ініціювати, переглядати, редагувати та надавати послуги відповідно до своїх повноважень та обов'язків у системі.
After re-authentication with the role *`officer`*, the Officer gains access to all services available in the registry. A registered user with the role `officer` can initiate, view, edit, and provide services according to their permissions and duties in the system.

//Таким чином, бізнес-процес автоматичної реєстрації посадових осіб (надавачів послуг) із ручним підтвердженням даних модератором спрощує процес реєстрації, забезпечуючи ефективний контроль з боку модератора та зменшуючи час, потрібний для реєстрації користувачів.
In this way, the business process of automatic registration of Officers (service providers) with manual data verification by a moderator streamlines the registration process, ensuring effective control by the moderator and reducing the time required for user registration.

//== Передумови
== Prerequisites

//Для того, щоб бізнес-процес самореєстрації запрацював, необхідно виконати передумови, описані нижче.
To enable the self-registration business process, the following prerequisites must be met:

//=== Увімкнення опції самореєстрації посадових осіб
=== Enabling the Officer self-registration option

//Активуйте опцію самореєстрації надавачів послуг в адміністративній панелі Control Plane.
Enable the option for Officer self-registration in the Control Plane administrative panel.

//TIP: Детальніше про це -- див. на сторінці
TIP: For more details, see
xref:registry-admin/cp-auth-setup/cp-officer-self-registration.adoc[].

//=== Моделювання структур даних
=== Data structure modeling

//Створіть модель даних реєстру за прикладом нижче.
Create a data model for the registry following the example below.

[TIP]
====
//Приклад _.xml_-схеми ви можете знайти у регламенті демо-реєстру *_consent-data_* за посиланням:
//https://admin-tools-consent-data.apps.envone.dev.registry.eua.gov.ua/gerrit.
You can find an example .xml schema in the demo registry regulations.

//хема буде доступна за назвою *_tablesOfficers.xml_*.
The schema will be available under the name *_tablesOfficers.xml_*.
====

//._Референтний приклад моделі даних. Таблиці для збереження самореєстрованих користувачів_
._Reference data model example. Tables for storing self-registered users_
[%collapsible]
====
[source,xml]
----
<changeSet author="registry owner" id="table officers">
        <createTable tableName="officers" ext:historyFlag="true" remarks="Officer's list">
            <column name="officers_id" type="UUID" defaultValueComputed="uuid_generate_v4()">
                <constraints nullable="false" primaryKey="true" primaryKeyName="pk_officers_id"/>
            </column>
            <column name="user_name" type="TEXT" remarks="User's username in Keycloa">
                <constraints nullable="false"/>
            </column>
            <column name="full_name" type="TEXT" remarks="User's full name">
                <constraints nullable="false"/>
            </column>
            <column name="drfo" type="TEXT" remarks="Registration number of the taxpayer's account card">
                <constraints nullable="false"/>
            </column>
            <column name="edrpou" type="TEXT" remarks="User's number at the Unified state register of enterprises and organizations of Ukraine">
                <constraints nullable="false"/>
            </column>
            <column name="realm_roles" type="TEXT" remarks="List of user's  roles in the regulations"/>
            <column name="work_start_date" type="DATE" remarks="Date of employment"/>
            <column name="unit_name" type="TEXT" remarks="Name of the unit according to the hierarchy"/>
            <column name="hierarchy_code" type="TEXT" remarks="Surrogate key derived from structure_code"/>
            <column name="structure_code" type="TEXT" remarks="Unique hierarchy code for the corresponding unit"/>
            <column name="selfregistration_decision" type="BOOLEAN" remarks="Moderator's decision regarding self-registration"/>
        </createTable>
    </changeSet>
----
====

//Ця модель даних створює таблицю *`officers`* у базі даних, яка зберігає інформацію про зареєстрованих користувачів (посадових осіб), які самореєструвалися в системі.
This data model creates a table named *`officers`* in the database, which stores information about registered users (Officers) who have self-registered in the system.

//._Опис стовпців таблиці_
._Description of the table columns_
[%collapsible]
====
//* *`officers_id`* -- це первинний ключ таблиці з унікальним ідентифікатором кожного посадовця, типом UUID, який автоматично генерується за допомогою функції `uuid_generate_v4()`.
* *`officers_id`*: This is the primary key of the table with a unique identifier for each Officer, using the UUID data type, which is automatically generated using the `uuid_generate_v4()` function.
//* *`user_name`* -- імена користувача з системи Keycloak (система управління ідентифікацією та доступом користувачі).
* *`user_name`*: Usernames from the Keycloak system (an identity and user access management system).
//* *`full_name`* -- ПІБ користувача.
* *full_name*: Full name of the user.
//* *`drfo`* : РНОКПП користувача (Реєстраційний номер облікової картки платника податків).
* *drfo*: Registration number of the taxpayer's account card of the user.
* *`edrpou`* : User's number at the Unified state register of enterprises and organizations of Ukraine.
[NOTE,caption=UA-specific]
The *drfo* and *edrpou* are attributes specific to the Ukrainian implementation and may not apply or function as described in other contexts or regions.
Please consult the local guidelines or documentation if you are implementing this outside of Ukraine.
//* *`realm_roles`* -- перелік регламентних ролей користувача.
* *realm_roles*: List of user roles in the regulations.
//* *`work_start_date`* -- дата прийняття користувача на роботу.
* *work_start_date*: Date of employment.
//* *`unit_name`* -- назва підрозділу відповідно до ієрархії організації.
* *`unit_name`*: Name of the unit according to the organization's hierarchy.
//* *`hierarchy_code`* -- сурогатний ключ, складений на основі `structure_code`.
* *hierarchy_code*: Surrogate key generated based on the `structure_code`.
//* *`structure_code`* -- унікальний код ієрархії для відповідного підрозділу.
* *`structure_code`*: Unique hierarchy code for the corresponding unit.
//* *`selfregistration_decision`* -- булеве значення, що відображає рішення модератора щодо самореєстрації користувача.
* *`selfregistration_decision`*: Boolean value reflecting the moderator's decision regarding user self-registration.
====

//== Референтний приклад процесу
== Reference process example

[TIP]
====
//Приклад _.bpmn_-моделі процесу, а також користувацькі _.json_-форми до нього ви можете знайти у регламенті демо-реєстру *_consent-data_* за посиланням:
//https://admin-tools-consent-data.apps.envone.dev.registry.eua.gov.ua/gerrit.
You can find an example BPMN model of the process as well as custom JSON forms for it in the demo registry regulations.

//Процес буде доступний за назвою *_officer-selfregistration-handmoderation.bpmn_*. Назви форм ви можете знайти всередині відповідних користувацьких задач бізнес-процесу у полі *`Form key`*.
The process will be available under the name *_officer-selfregistration-handmoderation.bpmn_*. You can find the form names within the respective business process tasks in the *`Form key`* field.
====

//=== Створення пулів для учасників процесу
=== Creating pools for process participants

//Створіть два пули (Participant) для учасників процесу -- посадової особи-заявника, яка самореєструється, та модератора, який перевіряє дані.
Create two pools (Participants) for process participants -- the Officer-applicant who self-registers and the moderator who verifies the data.

//.Пул процесу для посадової особи-заявника, який самореєструється
.Pool for the Officer-applicant who self-registers:
image::best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-1.png[]

//.Пул процесу для посадової особи-модератора, який перевіряє дані
.Pool for the moderator who verifies the data:
image::best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-2.png[]

//Вкажіть для кожного наступне:
Specify the following for each of the pools:

//* *`Participant Name`* -- назва пулу для процесу.
//* *`Process ID`* -- ідентифікатор процесу в регламенті реєстру.
//* *`Process name`* -- бізнес-назва процесу.
//* Активуйте чекбокс `*Executable*`.
* *`Participant Name`*: process pool name
* *`Process ID`*: Process identifier in the registry regulations.
* *`Process name`*: Business name of the process.
* Activate the *`Executable`* checkbox.

//=== Початок процесу
=== Starting the process

//Змоделюйте стартову подію. Ця подія ініціює автоматичний старт процесу після автентифікації з роллю *`unregistered-officer`*.
Model the starting event. This event initiates the automatic start of the process after authentication with the *`unregistered-officer`* role.

//* Вкажіть назву задачі.
//* Вкажіть ініціатора процесу як *`initiator`*.
* Specify the task name.
* Set the process initiator as *`initiator`*.
+
[TIP]
====
[%collapsible]
//.Що таке ініціатор?
.What is initiator?
=====
//*`"Start initiator = initiator"`* вказує на те, що значення ініціатора (тобто особи чи системи, яка розпочала процес) буде встановлено як *`initiator`*.
* "*`Start initiator = initiator`*" indicates that the initiator's value (i.e., the person or system that initiated the process) will be set as the *`initiator`*.

//У контексті бізнес-процесів, ініціатор -- це той, хто починає процес або відповідає за його запуск. Зазвичай, ініціатор -- це користувач, який викликає дію, або система, яка автоматично розпочинає процес.
In the context of business processes, the initiator is the one who initiates the process or is responsible for its start. Typically, the initiator is a user who triggers an action, or it can be a system that automatically initiates the process.

//У цьому випадку, `initiator` може бути використаний для ідентифікації особи чи системи, що стартували процес, у подальших етапах бізнес-процесу або для контролю доступу до ресурсів.
In this case, the `initiator` can be used to identify the person or system that started the process for further stages of the business process or for access control to resources.
=====
====

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-3.png[]

//=== Надсилання даних з токена для підтвердження реєстрації
=== Sending token data for registration confirmation

//Змоделюйте проміжну подію відправлення повідомлення -- *Message Intermediate Throw Event*.
Model an intermediate message throwing event -- *Message Intermediate Throw Event*.

//TIP: Детальніше про *Message Intermediate Throw Event* ви можете переглянути на сторінці xref:bp-modeling/bp/bpmn/events/message-event.adoc#message-intermediate-throw-event[Моделювання та налаштування проміжної події відправки повідомлення].
TIP: For more details about the *Message Intermediate Throw Event*, you can refer to the page on xref:bp-modeling/bp/bpmn/events/message-event.adoc#message-intermediate-throw-event[Modeling and configuring this type of event in the documentation].

//Ця подія повідомлення являє собою елемент у бізнес-процесі, який відправляє повідомлення з даними (`ПІБ`, `РНОКПП` та `ЄДРПОУ` з токена) про користувача до іншого учасника процесу або іншого процесу. У цьому випадку, вона описує відправлення даних заявника-ініціатора (особи, яка намагається зареєструватися) до модератора для ручного підтвердження даних.
This message event is an element in the business process that sends data (`full name`, `drfo`, and `EDRPOU` from the token) about the user to another process participant or process. In this case, it describes the sending of data from the initiator-applicant (the person trying to register) to the moderator for manual data confirmation.

//Виконайте налаштування події наступним чином: ::
Configure the event as follows: ::

//. У розділі *Implementation* вкажіть:
. In the *Implementation* section:
+
//* Тип -- *`Delegate expression`*.
* Type: *`Delegate expression`*.
//* Вираз -- *`${startProcessByMessageDelegate}`*. Змінна є імплементацією делегата.
* Expression: ${startProcessByMessageDelegate}. The variable is an implementation of the delegate.
+
//. У розділі *Global message reference*:
. In the *Global message reference* section:
+
//* Оберіть *`startModerationBpMessage`* зі списку доступних.
//* У полі `Name` продублюйте значення *`startModerationBpMessage`* для зручності.
* Choose *`startModerationBpMessage`* from the available list.
* Duplicate the value *`startModerationBpMessage`* in the *Name* field for convenience.
+
//. У розділі *Inputs* вкажіть вхідні дані для передачі до іншого процесу:
. In the *Inputs* section, specify the input data to pass to another process:
+
//* Створіть локальну змінну *`messagePayload`*.
//* Визначте для неї тип *`Map`*, тобто ключі-значення.
//* Передайте набір ключів-значень як *`Map entries`* у полях `Key` та *Value*. Зробити це можна наступним чином за допомогою функції `initiator()`:
* Create a local variable *`messagePayload`*.
* Define its type as *`Map`* (key-value pairs).
* Pass a set of key-value pairs as *`Map entries`* in the *Key* and *Value* fields using the `initiator()` function:
+
//** ДРФО/РНОКПП
** drfo/Registration number of the taxpayer's account card (UA-specific)
*** *`Key: drfo`*
*** *`Value: ${initiator().drfo}`*

//** ДРФО/РНОКПП
** drfo/Registration number of the taxpayer's account card (UA-specific)
*** *`Key: edrpou`*
*** *`Value: ${initiator().edrpou}`*

//** ПІБ
** User's full name
*** *`Key: fullName`*
*** *`Value: ${initiator().fullName}`*

//** Ім'я користувача в системі
** User's username in the system
*** *`Key: userName`*
*** *`Value: ${initiator().userName}`*


image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-4.png[]

//=== Отримання даних з токена модератором для підтвердження реєстрації
=== Moderator receiving token data for registration confirmation

//Змоделюйте стартову подію повідомлення -- *Message Start Event*.
Model a message start event -- *Message Start Event*.

//TIP: Детальніше про *Message Start Event* ви можете переглянути на сторінці xref:bp-modeling/bp/bpmn/events/message-event.adoc#message-start-event[Моделювання та налаштування стартової події повідомлення].
TIP: For more detailed information about the *Message Start Event*, you can refer to the page on xref:bp-modeling/bp/bpmn/events/message-event.adoc#message-start-event[Modeling and configuring message start event].

//Ця подія повідомлення являє собою елемент у бізнес-процесі, який отримує повідомлення з даними (`ПІБ`, `РНОКПП` та `ЄДРПОУ` з токена) про користувача до іншого учасника процесу або іншого процесу. У цьому випадку, вона описує отримання даних від заявника-ініціатора (особи, яка намагається зареєструватися) модератором для ручного підтвердження даних.
This event is an element in the business process that receives data (`full name`, `drfo`, and `EDRPOU` from the token) about the user from another process participant or process. In this case, it describes the receipt of data from the initiator-applicant (the person trying to register) by the moderator for manual data confirmation.

//Виконайте налаштування події наступним чином: ::
Configure the event as follows:

//. Визначте ідентифікатор події як `start_message_event`. Він буде використаний у наступній скрипт-задачі.
. Define the event identifier as `start_message_event`. It will be used in the subsequent script task.
//. У розділі *Global message reference*:
. In the *Global message reference* section:
+
//* Оберіть *`startModerationBpMessage`* зі списку доступних.
//* У полі `Name` продублюйте значення *`startModerationBpMessage`* для зручності.
* Choose *`startModerationBpMessage`* from the available list.
* Duplicate the value *`startModerationBpMessage`* in the *Name* field for convenience.

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-5.png[]

//=== Скрипт для підготовки даних до відображення на UI-формі
=== Script for data preparation for display on the UI form

//Створіть скрипт-задачу (Script Task) та додайте Groovy-скрипт, який підготує дані для відображення на UI-формі процесу.
Create a Script Task and add a Groovy script that prepares data for displaying on the UI form of the process.

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-6.png[]

//Відкрийте редактор скриптів та додайте наступний скрипт:
Open the script editor and add the following script:

//._Скрипт для підготовки даних до відображення на UI-формі_
._Script for data preparation for display on UI form_
[%collapsible]
====
[source,groovy]
----
set_transient_variable('payload', S(message_payload('start_message_event').data, 'application/json'))
----

//Цей скрипт виконує наступні дії:
This script performs the following actions:

//. Витягує дані з повідомлення *`start_message_event`* та конвертує їх у формат JSON. Для цього використовується функція *`message_payload('start_message_event').data`*. Функція S забезпечує обробку JSON-формату.
. Extracts data from the *`start_message_event`* message and converts it into JSON format. This is done using the function *`message_payload('start_message_event').data`*. Function S handles the JSON processing.
+
//. Після того, як дані перетворено на JSON, скрипт створює тимчасову змінну *`payload`* та присвоює їй значення цих даних. Функція *`set_transient_variable()`* використовується для створення тимчасової змінної процесу, яка зберігатиме змінну *`payload`*.
. After the data is transformed into JSON, the script creates a temporary variable named *`payload`* and assigns it the value of this data. The function *`set_transient_variable()`* is used to create a process temporary variable that will store the *`payload`* variable.
====

//=== Визначення бізнес-ключа процесу
=== Determining the business key of the process

//Ця задача -- сервісна задача (Service Task), яка використовує делегат *Define process business key*, що виконує певний код або логіку під час виконання цієї задачі.
This task is a service task that utilizes the *Define process business key* delegate, which executes specific code or logic during the execution of this task.

[TIP]
====
[%collapsible]
//.Що таке бізнес-ключ?
.What is a business key?
=====
//_Бізнес-ключ_ або _Ключ бізнес-процесу_ (*Business Key*) -- це специфічний для домену ідентифікатор екземпляра бізнес-процесу у https://camunda.com/bpmn/reference[Camunda BPM]. Він є додатковим атрибутом, що застосовується при моделюванні бізнес-процесів для їх однозначної ідентифікації, а також ідентифікації користувацьких задач процесу.
The _Business key_, or _Process business key_ (*Business Key*), is a domain-specific identifier for an instance of a business process in https://camunda.com/bpmn/reference[Camunda BPM]. It is an additional attribute used during the modeling of business processes to ensure their unique identification, as well as the identification of user tasks within the process.
=====
====

//За допомогою розширення БП задається вхідний параметр `*businessKey*`. Цей параметр отримує значення з тимчасової змінної *`payload`*, яка була створена раніше, та зокрема з атрибута *`fullName`*.
The input parameter *`businessKey`* is set in the BP extension. This parameter receives values from a temporary variable called *`payload`*, which was created earlier, specifically from the attribute *`fullName`*.

//Після виконання цієї задачі, бізнес-ключ процесу буде встановлено як значення *`fullName`* із тимчасової змінної *`payload`*.
After completing this task, the business key of the process will be set as the value of *`fullName`* from the temporary variable *`payload`*.

//У цьому контексті, сервісна задача отримує повне ім'я особи-заявника із JSON-даних, що були передані у повідомленні, та встановлює його як бізнес-ключ для поточного екземпляра процесу:
In this context, the service task receives the full name of the applicant from JSON data transmitted in the message and sets it as the business key for the current process instance:

----
${payload.value.prop('fullName').value()}
----

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-7.png[]

[TIP]
====
//Детальніше про бізнес-ключі ви можете дізнатися на сторінці
For more details about business keys, please see
xref:bp-modeling/bp/modeling-facilitation/bp-business-keys.adoc[].
====

//=== Перегляд даних для реєстрації модератором на UI-формі
=== Reviewing data for moderator registration on the UI form

//Ця задача -- користувацька задача (User Task) з ідентифікатором *`makeDecisionActivity`*, яка призначена для виконання посадовою особою-модератором (*`candidateGroups="officer-moderator"`*).
This task is a user task with the identifier *`makeDecisionActivity`*, intended for execution by an officer-moderator (*`candidateGroups="officer-moderator"`*).

//В задачі використовується параметр *`formKey`* зі значенням *`selfregistration-decision`*, який вказує на UI-форму, що має бути показана модератору для перегляду даних посадової особи-заявника та прийняття рішення про самореєстрацію.
The task uses the *`formKey`* parameter with the value *`selfregistration-decision`*, indicating the UI form to be shown to the moderator for reviewing the data of the officer-applicant and making a decision on self-registration.

//За допомогою розширення-делегата User Form задається вхідний параметр *`Form data pre-population`*, який отримує значення з тимчасової змінної "payload", визначеної у скрипті раніше. Цей параметр передає дані заявника до форми, який відображається модератору.
Using the User Form delegate, the *`Form data pre-population`* input parameter is defined, which receives data from the temporary variable "payload" specified in the earlier script. This parameter passes applicant data to the form displayed to the moderator.

//Після того, як модератор перегляне дані та прийме рішення, процес продовжується далі відповідно до вибору модератора (підтвердження або відхилення самореєстрації).
After the moderator reviews the data and makes a decision, the process continues according to the moderator's choice (confirmation or rejection of self-registration).

//Виконайте налаштування наступним чином: ::
Configure it as follows: ::

//. У полі *`Name`* введіть назву користувацької задачі.
//. Застосуйте шаблон делегата -- *`User Form`*.
//. У полі *`ID`* введіть ідентифікатор задачі -- *`makeDecisionActivity`*.
//. У полі *`Form key`* визначте ключ для поєднання із відповідною змодельованою формою бізнес-процесу -- *`selfregistration-decision`*.
//. У полі `Candidate roles` введіть роль посадової особи-модератора процесу, визначену у регламенті, -- *`officer-moderator`*.
//. У полі *`Form data pre-population`* передайте дані на UI-форму як змінну ${payload}.
. In the *`Name`* field, enter the name of the user task.
. Apply the delegate *`User Form`* template.
. In the *`ID`* field, specify the task identifier as *`makeDecisionActivity`*.
. In the *`Form key`* field, define the key for linking to the corresponding modeled business process form - *`selfregistration-decision`*.
. In the `Candidate roles` field, input the role of the officer-moderator in the process, as defined in the regulations -- *`officer-moderator`*.
. In the *`Form data pre-population`* field, pass data to the UI form as the variable "${payload}."

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-8.png[]

//=== Таймер для прийняття рішення модератором щодо реєстрації
=== Timer for the moderator's decision regarding registration

//Це гранична подія (*Timer Boundary Event*), яка прикріплена до користувацької задачі *`makeDecisionActivity`*. Ця подія містить визначення події таймера (`timerEventDefinition`), яке встановлює таймер із тривалістю 2 хвилини (*`PT2M`*).
This is a *Timer Boundary Event* attached to the User Task *`makeDecisionActivity`*. This event contains a timer event definition that sets a timer with a duration of 2 minutes (*`PT2M`*).

//Коли користувацька задача `makeDecisionActivity` активується, таймер починає відлік 2 хвилин. Якщо модератор не приймає рішення протягом цього часу, таймер спрацьовує, і процес переходить до наступного кроку відповідно до альтернативного потоку (це означає, що користувач не буде зареєстрований).
When the User Task `makeDecisionActivity` is activated, the timer starts counting down from 2 minutes. If the moderator does not make a decision within this time, the timer triggers, and the process proceeds to the next step according to the alternative flow (meaning the user will not be registered).

//Виконайте налаштування наступним чином: ::
Configure it as follows:

//. У полі Name вкажіть назву для події.
//. У розділі Timer:
. In the *Name* field, specify a name for the event.
. In the *Timer* section:
//* У полі *`Type`* (`Timer Definition Type`) вкажіть тип таймера -- *`Duration`* (тривалість).
* In the *`Type`* (`Timer Definition Type`) field, specify the timer type as *`Duration`*.
+
[TIP]
.Детальніше про таймери -- дивіться на сторінках:
.For more details about timers, refer to the following pages:
====
* xref:bp-modeling/bp/bpmn/events/timer-event.adoc[].
* xref:best-practices/bp-timer-launch.adoc[]
====
+
//* У полі *`Value`* вкажіть значення для таймера у певному форматі. Наприклад, *`PT2M`*, тобто 2 хвилини.
* In the *`Value`* field, specify the timer value in a specific format, e.g., *`PT2M`* for 2 minutes.
+
//TIP: Ви можете налаштувати таймер, використовуючи стандартний формат *`ISO 8601`* або `*cron*`-вираз.
TIP: You can configure the timer using the standard *`ISO 8601`* format or a *`cron`* expression.

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-9.png[]

//=== Надсилання повідомлення про те, що рішення про автореєстрацію не прийнято (альтернативний потік)
=== Sending a message that the self-registration decision was not accepted (alternative flow)

//Це кінцева подія (*Message End Event*), яка має визначення події повідомлення (`messageEventDefinition`) і використовує делегат *`${sendMessageDelegate}`*, що відповідає за надсилання повідомлення.
This is an *Message End Event* that has a message event definition and uses the `${sendMessageDelegate}` delegate responsible for sending messages.

//TIP: Детальніше про *Message End Event* ви можете переглянути на сторінці xref:bp-modeling/bp/bpmn/events/message-event.adoc#message-end-event[Моделювання та налаштування кінцевої події повідомлення].
TIP: For more details about the *Message End Event*, you can refer to the xref:bp-modeling/bp/bpmn/events/message-event.adoc#message-end-event[Modeling and configuration of Message End Event page].

//Якщо процес доходить до цієї події, отже рішення про автореєстрацію не було прийнято (наприклад, через те, що спрацював таймер). У цьому випадку, подія надсилає повідомлення з інформацією про те, що рішення не було прийнято, до іншого процесу або учасника, використовуючи делегат *`sendMessageDelegate`*. Інформація про ідентифікатор процесу, з якого було викликано цей процес (*`correlationProcessInstanceId`*), передається як вхідний параметр.
If the process reaches this event, it means that the self-registration decision was not accepted (for example, due to a timer triggering). In this case, the event sends a message with information that the decision was not accepted to another process or participant using the *`sendMessageDelegate`* delegate. Information about the identifier of the process that called this process (*`correlationProcessInstanceId`*) is passed as an input parameter.

//Функція *`process_caller()`* використовується для отримання інформації про той процес, який викликав поточний процес.
The *`process_caller()`* function is used to obtain information about the process that triggered the current process.

//У нашому випадку функція отримує ідентифікатор (*`id`*) процесу, який викликав поточний процес. Цей ідентифікатор передається як вхідний параметр `correlationProcessInstanceId` для делегата `sendMessageDelegate`, який надсилає повідомлення.
In our case, the function retrieves the identifier (*`id`*) of the process that triggered the current process. This identifier is passed as an input parameter (`correlationProcessInstanceId`) to the `sendMessageDelegate` delegate, which sends the message.

//Виконайте налаштування наступним чином: ::
Configuration steps: ::

//. У розділі *Implementation* вкажіть:
. In the *Implementation* section, specify:
//* Тип -- *`Delegate expression`*.
//* Вираз -- *`${sendMessageDelegate}`*. Змінна є імплементацією делегата.
* Type as *`Delegate expression`*.
* Expression as *`${sendMessageDelegate}`*. The variable is an implementation of the delegate.
+
//. У розділі *Global message reference*:
//* Оберіть *`decisionOverdueMessage`* зі списку доступних.
//* У полі `Name` продублюйте значення *`decisionOverdueMessage`* для зручності.
. In the *Global message reference* section:
* Choose *`decisionOverdueMessage`* from the available options.
* Duplicate the *`decisionOverdueMessage`* value in the *Name* field for convenience.
+
//. У розділі *Inputs* вкажіть вхідні дані для передачі до іншого процесу:
. In the *Inputs* section, specify the input data to be passed to another process:
//* Створіть локальну змінну *`correlationProcessInstanceId`*.
//* Визначте для неї тип *`String or Expression`*, тобто рядок або вираз.
//* У полі *`Value`* передайте ідентифікатор процесу, який викликав поточний процес. Зробити це можна наступним чином за допомогою функції *`process_caller()`*:
* Create a local variable called *`correlationProcessInstanceId`*.
* Define its type as *`String or Expression`*.
* In the *Value* field, pass the identifier of the process that triggered the current process using the *`process_caller()`* function:
${process_caller().id}
+
[source,juel]
----
${process_caller().id}
----

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-10.png[]

//=== Отримання повідомлення про те, що рішення про автореєстрацію не прийнято (альтернативний потік)
=== Receiving a message that the self-registration decision was not accepted (alternative flow)

//Ця подія є проміжною подією отримання повідомлення (*Intermediate Message Catch Event*) у процесі BPMN. Вона служить для очікування та перехоплення вхідного повідомлення, яке відправлено іншим процесом або учасником. Зазвичай такі події використовуються для синхронізації або координації між різними процесами чи учасниками у бізнес-процесі.
This event is an *Intermediate Message Catch Event* in the BPMN process. It is used to wait for and catch an incoming message sent by another process or participant. Such events are typically used for synchronization or coordination between different processes or participants in a business process.

//TIP: Детальніше про *Intermediate Message Catch Event* ви можете переглянути на сторінці xref:bp-modeling/bp/bpmn/events/message-event.adoc#message-intermediate-catch-event[Моделювання та налаштування проміжної події отримання повідомлення].
TIP: For more details about the *Intermediate Message Catch Event*, you can refer to the xref:bp-modeling/bp/bpmn/events/message-event.adoc#message-intermediate-catch-event[Modeling and configuration of intermediate message catch event] page.

//Виконайте налаштування події наступним чином: ::
Configuration steps for the event: ::

//У розділі *Global message reference*:
In the *Global message reference* section:

//. Оберіть *`decisionOverdueMessage`* зі списку доступних.
//. У полі `Name` продублюйте значення *`decisionOverdueMessage`* для зручності.
. Choose *`decisionOverdueMessage`* from the available options.
. Duplicate the *`decisionOverdueMessage`* value in the *Name* field for convenience.

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-11.png[]

//=== Виведення інформації про завершення процесу на форму (альтернативний потік)
=== Displaying information about process completion on a form (alternative flow)

//Ця задача є користувацькою задачею (*User Task*) і призначена для надання інформації користувачеві про те, що процес реєстрації завершився через вичерпання часу, відведеного на прийняття рішення.
This task is a user task intended to provide information to the user that the registration process has ended due to a timeout for decision-making.

//Ця задача призначена для ініціатора процесу (*`camunda:assignee="${initiator}"`*), який є заявником. Форма, пов'язана з цією задачею, має ключ *`selfregistration-decision-overdue`* (`camunda:formKey="selfregistration-decision-overdue"`), який відображає форму з інформацією про завершення процесу по вичерпанню часу.
This task is assigned to the process initiator (*`camunda:assignee="${initiator}"`*), who is the applicant. The form associated with this task has the key *`selfregistration-decision-overdue`* (`camunda:formKey="selfregistration-decision-overdue"`), which displays information about the process completion due to a timeout.

//Виконайте налаштування наступним чином: ::
Configuration steps: ::

//. У полі `Name` введіть назву користувацької задачі.
//. Застосуйте шаблон делегата для цієї задачі -- *User Form*.
//. Поєднайте користувацьку задачу із UI-формою за допомогою параметра *`Form key`*. Введіть значення *`selfregistration-decision-overdue`*.
//. У полі *`Assignee`* вкажіть змінну для особи, якій призначається поточна задача, -- *`${initiator}`*.
. In the *Name* field, enter the name of the user task.
. Apply the delegate template for this task -- *User Form*.
. Link the User Task to a UI form using the *`Form key`* parameter. Enter the value.
. In the *`Assignee`* field, specify the variable for the person to whom the current task is assigned - *`${initiator}`*.

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-11-1.png[]

//Далі відбувається завершення процесу відповідно до кінцевої події в альтернативному потоці.
The process then concludes based on the end event in the alternative flow.

//=== Підписання даних КЕП
=== Signing data with a Qualified Electronic Signature (QES)

//Ця задача є користувацькою задачею (User Task) у бізнес-процесі BPMN і призначена для підпису рішення заявника за допомогою кваліфікованого електронного підпису (КЕП).
This task is a user task within the BPMN business process and is designed for signing the applicant's decision using a Qualified Electronic Signature (QES).

//Ця задача призначається для користувача, який виконав задачу `makeDecisionActivity`. Форма, пов'язана із цією задачею, має ключ *`selfregistration-sign-decision`*, який відображає форму для підпису рішення КЕП. Вхідні дані для форми передаються із результатів форми задачі *`makeDecisionActivity`*.
This task is assigned to the user who performed the `makeDecisionActivity` task. The form associated with this task has the key *`selfregistration-sign-decision`*, which displays the QES decision signing form. The input data for the form is passed from the results of the *`makeDecisionActivity`* task.

//Після того, як користувач підпише рішення, процес продовжиться за основним потоком.
After the user signs the decision, the process will continue along the main flow.

//Виконайте налаштування наступним чином: ::
Configuration steps: ::

//. У полі *`Name`* введіть назву користувацької задачі.
//. Застосуйте шаблон делегата -- *`Officer Sign Task`*.
//. У полі *`ID`* введіть ідентифікатор задачі -- *`signDecisionActivity`*.
//. У полі *`Form key`* визначте ключ для поєднання із відповідною змодельованою формою бізнес-процесу -- *`selfregistration-sign-decision`*.
. In the *`Name`* field, enter the name of the user task.
. Apply the delegate template for this task -- *`Officer Sign Task`*.
. In the *`ID`* field, enter the task identifier as *`signDecisionActivity`*.
. In the *`Form key`* field, specify the key to link to the corresponding modeled business process form - *`selfregistration-sign-decision`*.
//. У полі `Assignee` вкажіть, кому призначається задача для виконання. Використайте для цього функцію *`completer()`*:
. In the *Assignee* field, specify who the task is assigned to for execution. Use the *`completer()`* function to assign it to the user who completed the makeDecisionActivity task:
${completer('makeDecisionActivity').userName}
+
[source,juel]
----
${completer('makeDecisionActivity').userName}
----
//. У полі *`Form data pre-population`* передайте дані на UI-форму через функцію `submission()`:
. In the *`Form data pre-population`* field, pass the data to the UI form using the `submission()` function:
+
[source,juel]
----
${submission('makeDecisionActivity').formData}.
----

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-12.png[]

//=== Підписання даних системним ключем
=== Signing data with a system key

//Ця задача є сервісною задачею (*Service Task*) у бізнес-процесі BPMN і призначена для підпису даних системним ключем, тобто автоматичним підписом з боку системи.
This task is a Service Task within the BPMN business process and is designed for signing data with a system key, i.e., an automatic signature by the system.

//Ця задача використовує делегат *`digitalSystemSignatureDelegate`*, який відповідає за логіку підпису системним ключем.
This task uses the *`digitalSystemSignatureDelegate`* delegate, which is responsible for the logic of signing with the system key.

//Вхідні параметри для цього завдання включають *`x_access_token`*  та *`payload`*. `x_access_token` отримується від користувача, який завершив задачу *`signDecisionActivity`*, а `payload` містить дані форми з результатів цього завдання.
Input parameters for this task include *`x_access_token`* and *`payload`*. `x_access_token` is obtained from the user who completed the *`signDecisionActivity`* task, and `payload` contains the form data from the results of that task.

//Задача генерує вихідний параметр *`subject_system_signature_ceph_key`*, який містить згенерований ключ зберігання системного підпису.
The task generates an output parameter *`subject_system_signature_ceph_key`*, which contains the generated system signature storage key.

//Виконайте налаштування наступним чином: ::
Configuration steps: ::

//. Змоделюйте сервісну задачу (Service Task) для підпису даних системним ключем.
//. Використовуйте делегат *System signature by DSO service* із каталогу шаблонів для накладання системного підпису.
//. Вхідні дані передайте функцію submission у відповідному полі:
. Model a service task for signing data with a system key.
. Use the *System signature by DSO service* delegate from the template catalog for applying the system signature.
. Pass input data to the submission function in the appropriate field:
${submission('signDecisionActivity').formData}
+
----
${submission('signDecisionActivity').formData}
----
//. Передайте токен виконавця останньої користувацької задачі у бізнес-процесі: *`${completer('signDecisionActivity').accessToken}`*.
. Pass the token of the last user task executor in the business process using: *`${completer('signDecisionActivity').accessToken}`*.
+
//. Відповідь запишіть у змінну `*subject_system_signature_ceph_key*`.
. Store the response in the *`subject_system_signature_ceph_key`* variable.

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-13.png[]

//=== Створення запису у базі даних реєстру
=== Creating a record in the registry database

//Ця задача створює користувача в системній таблиці бази даних реєстру. Вона використовує шаблон делегата `dataFactoryConnectorCreateDelegate` для виконання дій. Задача отримує вхідні параметри з попередніх задач, такі як ключі та дані форми, та передає їх для створення користувача.
This task creates a user record in the system's database table. It uses the `dataFactoryConnectorCreateDelegate` delegate to perform the actions. The task receives input parameters from previous tasks, such as keys and form data, and passes them to create the user.

//Вхідні параметри включають: ::
Input parameters include: ::

//* *`x_digital_signature_derived_ceph_key`* -- ключ, що походить від підписаного документа.
//* *`resource`* -- ресурс, що буде створений (у цьому випадку, `officers`).
//* *`x_access_token`* -- токен доступу виконавця задачі `signDecisionActivity`.
//* *`x_digital_signature_ceph_key`* -- системний ключ документа із підписом від задачі `signDecisionActivity`.
//* *`payload`* -- дані форми з завдання `signDecisionActivity`.
* *`x_digital_signature_derived_ceph_key`*: The key derived from the signed document.
* *`resource`*: The resource to be created (in this case, `officers`).
* *`x_access_token`*: The access token of the `signDecisionActivity` task executor.
* *`x_digital_signature_ceph_key`*: The system key of the document signed in the `signDecisionActivity` task.
* *`payload`*: The form data from the `signDecisionActivity` task.

//Виконайте налаштування наступним чином: ::
Configuration steps: ::

//. Створіть сервісну задачу (*Service Task*).
//. Використовуйте делегат *Create entity in data factory*, щоб створити сутність у базі даних.
//. Вкажіть ресурс/API-ендпоінт *`officers`*, що відповідає назві таблиці із даними, яку ви визначили при створенні моделі даних реєстру -- *`officers`*.
//. Вхідні дані передайте через функцію *`submission()`* у відповідному полі:
. Create a service task.
. Use the *Create entity in data factory* delegate to create an entity in the database.
. Specify the resource/API endpoint as *`officers`*, which corresponds to the name of the data model table you defined when creating the registry data model - *`officers`*.
. Pass input data through the *`submission()`* function in the appropriate field:
+
[source,juel]
----
${submission('signDecisionActivity').formData}
----
//. Передайте токен виконавця останньої користувацької задачі у бізнес-процесі: *`${completer('signDecisionActivity').accessToken}`*.
//. Вкажіть джерело системного підпису. Для цього використовуйте функцію `sign_submission()`: +
//*`${sign_submission('signDecisionActivity').signatureDocumentId}`*.
//. Вкажіть як змінну *`${subject_system_signature_ceph_key}`* ключ Ceph-документа, який містить інформацію про підписані дані.
//. Запишіть відповідь до результівної змінної, наприклад, `response`.
. Pass the token of the last user task executor in the business process using: *`${completer('signDecisionActivity').accessToken}`*.
. Specify the source of the system signature using the `sign_submission()` function:
*`${sign_submission('signDecisionActivity').signatureDocumentId}`*.
. Specify *`${subject_system_signature_ceph_key`*} as the variable that holds the Ceph document key containing information about the signed data.
. Store the response in a result variable, for example,`response`.

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-14.png[]

//=== Визначення статусу виконання процесу
=== Determining the execution status of the process

//Ця задача встановлює результат виконання процесу "Самореєстрацію пройдено" за допомогою шаблону делегата *`defineBusinessProcessStatusDelegate`*. Задача приймає вхідні дані з попередньої задачі та передає результат до наступного етапу процесу.
This task sets the result of the "Self-registration completed" process execution using the *`defineBusinessProcessStatusDelegate`* delegate template. The task accepts input data from the previous task and passes the result to the next stage of the process.

//Встановіть результат виконання: ::
Set the execution result as follows: ::

//. Оберіть шаблон делегата *Define business process status* у списку доступних.
//. У полі Status введіть статус -- `Самореєстрацію пройдено`.
. Select the delegate template *Define business process status* from the available list.
. In the *Status* field, enter the status as `Self-registration completed`.

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-15.png[]

//=== Відправлення рішення назад до процесу заявника реєстрації
=== Sending the decision back to the applicant registration process

//Ця задача є завершальною подією (*Message End Event*) у процесі підтвердження самореєстрації модератором. Вона виконує наступні функції:
This task serves as the concluding event (*Message End Event*) in the moderator's self-registration confirmation process. It performs the following functions:

//. Встановлює зв'язок з процесом реєстранта через параметр *`correlationProcessInstanceId`*, що отримує значення з ID процесу-викликача (*`${process_caller().id}`*).
. Establishes a connection with the registrant process using the *`correlationProcessInstanceId`* parameter, which obtains its value from the ID of the calling process (*`${process_caller().id}`*).
+
//. Передає дані про рішення відносно самореєстрації через параметр *`messageData`*. Цей параметр містить відомості про позитивне чи негативне рішення (*`${submission('signDecisionActivity').formData.prop('selfregistrationDecision').value()}`*).
. Transfers decision-related data regarding self-registration through the *`messageData`* parameter. This parameter contains information about a positive or negative decision (*`${submission('signDecisionActivity').formData.prop('selfregistrationDecision').value()}`*).
+
//. Використовує делегат *`${sendMessageDelegate}`* для відправки повідомлення з вищезазначеними даними.
. Utilizes the delegate *`${sendMessageDelegate}`* to send a message with the aforementioned data.

//TIP: Детальніше про *Message End Event* ви можете переглянути на сторінці xref:bp-modeling/bp/bpmn/events/message-event.adoc#message-end-event[Моделювання та налаштування кінцевої події повідомлення].
TIP: For more details on the *Message End Event*, please refer to the xref:bp-modeling/bp/bpmn/events/message-event.adoc#message-end-event[Modeling and configuring the message end event] page.

//Виконайте наступні налаштування: ::
Configure the following settings: ::

//. У розділі *Implementation* вкажіть:
. In the *Implementation* section, specify:
//* Тип -- *`Delegate expression`*.
//* Вираз -- *`${sendMessageDelegate}`*. Змінна є імплементацією делегата.
* Type: *`Delegate expression`*.
* Expression: *`${sendMessageDelegate}`*. This variable represents the delegate implementation.
+
//. У розділі *Global message reference*:
//* Оберіть *`decisionMessage`* зі списку доступних.
//* У полі `Name` продублюйте значення *`decisionMessage`* для зручності.
. In the *Global message reference* section:
* Choose *`decisionMessage`* from the available list.
* Duplicate the value *`decisionMessage`* in the *Name* field for convenience.
+
//. У розділі *Inputs* вкажіть вхідні дані для передачі до іншого процесу:
//* Створіть локальну змінну *`correlationProcessInstanceId`*.
. In the *Inputs* section, specify the input data to be sent to another process:
* Create a local variable *`correlationProcessInstanceId`*.
+
//** Визначте для неї тип *`String or Expression`*, тобто рядок або вираз.
//** У полі *`Value`* передайте ідентифікатор процесу, який викликав поточний процес. Зробити це можна наступним чином за допомогою функції *`process_caller()`*:
** Define its type as *`String or Expression`*, i.e., a string or expression.
** In the *`Value`* field, pass the identifier of the process that invoked the current process. You can do this using the *`process_caller()`* function:
+
[source,juel]
----
${process_caller().id}
----
+
//* Створіть локальну змінну *`messageData`*.
//** Визначте для неї тип *`Map`*, тобто ключі-значення.
//** Передайте набір ключів-значень як *`Map entries`* у полях `Key` та *Value*. Зробити це можна наступним чином за допомогою функції `submission()`:
* Create a local variable *`messageData`*.
** Define its type as *`Map`*, i.e., key-value pairs.
** Pass a set of key-value pairs as *`Map entries`* in the `Key` and *Value* fields. You can do this using the `submission()` function:
+
//*** *`Key: isDecisionPositive`* (вказує на ключ до позитивного результату, який підтверджує реєстрацію посадової особи)
//*** *`Value: ${submission('signDecisionActivity').formData.prop('selfregistrationDecision').value()}`*
*** *`Key: isDecisionPositive`* (indicates the key for a positive result confirming the Officer's registration)
*** *`Value: ${submission('signDecisionActivity').formData.prop('selfregistrationDecision').value()}`*

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-16.png[]

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-16-1.png[]

//=== Отримання повідомлення про те, що рішення про автореєстрацію прийнято та записано до Фабрики даних
=== Receiving a message confirming self-registration decision and recording it in the Data Factory

//Ця подія є проміжною подією отримання повідомлення (*Intermediate Message Catch Event*) у процесі BPMN. Вона служить для очікування та перехоплення вхідного повідомлення, яке відправлено іншим процесом або учасником. Зазвичай такі події використовуються для синхронізації або координації між різними процесами чи учасниками у бізнес-процесі.
This event serves as an *Intermediate Message Catch Event* in the BPMN process. It is used to wait for and intercept an incoming message sent by another process or participant. Typically, such events are used for synchronization or coordination between different processes or participants in a business process.

//TIP: Детальніше про *Intermediate Message Catch Event* ви можете переглянути на сторінці xref:bp-modeling/bp/bpmn/events/message-event.adoc#message-intermediate-catch-event[Моделювання та налаштування проміжної події отримання повідомлення].
TIP: For more details on the *Intermediate Message Catch Event*, you can refer to the xref:bp-modeling/bp/bpmn/events/message-event.adoc#message-intermediate-catch-event[Modeling and configuring the intermediate message catch event] page.

//Виконайте налаштування події наступним чином: ::
Configuration steps: ::

//У розділі *Global message reference*:
//. Оберіть *`decisionMessage`* зі списку доступних.
//. У полі `Name` продублюйте значення *`decisionMessage`* для зручності.
In the *Global message reference* section:
. Select *`decisionMessage`* from the available list.
. Duplicate the value *`decisionMessage`* in the `Name` field for convenience.

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-17.png[]

//=== Моделювання XOR-шлюзу та додавання логіки через вирази умови
=== Modeling a XOR gateway and adding logic through condition expressions

//Змоделюйте XOR-шлюз, який на основі певної умови визначатиме, за яким потоком далі піде бізнес-процес.
Model an XOR gateway that, based on a certain condition, will determine the next flow of the business process.

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-18.png[]

//Якщо рішення про реєстрацію негативне і передається повідомленням від процесу модератора як ключ *`${!isDecisionPositive}`*, тоді процес піде за альтернативним потоком, а користувач не пройде реєстрацію. Роль такого користувача не зміниться й залишиться *`unregistered-officer`*.
If the decision regarding registration is negative and is conveyed by a message from the moderator's process as the key *`${!isDecisionPositive}`*, then the process will follow an alternative flow, and the user will not complete the registration. The role of such a user will remain *`unregistered-officer`*.

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-18-1.png[]

//Якщо рішення про реєстрацію позитивне і передається повідомленням від процесу модератора як ключ *`${isDecisionPositive}`*, тоді процес піде за основним потоком, а користувач пройде реєстрацію. Роль такого користувача зміниться у наступній сервісній задачі з *`unregistered-officer`* на *`officer`*.
If the decision regarding registration is positive and is conveyed by a message from the moderator's process as the key *`${isDecisionPositive}`*, then the process will follow the main flow, and the user will complete the registration. The role of such a user will change in the subsequent service task from *`unregistered-officer`* to *`officer`*.

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-18-2.png[]

//=== Виведення інформації на форму про відсутність дозволу на реєстрацію (альтернативний потік)
== Displaying information on the lack of registration permission (alternative flow)

//Ця задача є користувацькою задачею (*User Task*) і призначена для надання інформації користувачеві про відсутність дозволу на реєстрацію.
This task is a user task and is intended to provide information to the user about the lack of registration permission.

//Ця задача призначена для ініціатора процесу (*`camunda:assignee="${initiator}"`*), який є заявником. Форма, пов'язана з цією задачею, має ключ *`selfregistration-denied-handmoderation`* (`camunda:formKey="selfregistration-denied-handmoderation"`), який відображає форму з інформацією про відсутність дозволу на реєстрацію.
This task is assigned to the process initiator (*`camunda:assignee="${initiator}"`*), who is the applicant. The form associated with this task has the key *`selfregistration-denied-handmoderation`* `(`camunda:formKey="selfregistration-denied-handmoderation`"`), which displays information about the lack of registration permission.

//Виконайте налаштування наступним чином: ::
Configuration steps: ::

//. У полі `Name` введіть назву користувацької задачі.
//. Застосуйте шаблон делегата для цієї задачі -- *User Form*.
//. Поєднайте користувацьку задачу із UI-формою за допомогою параметра *`Form key`*. Введіть значення *`selfregistration-denied-handmoderation`*.
//. У полі *`Assignee`* вкажіть змінну для особи, якій призначається поточна задача, -- *`${initiator}`*.
. In the `Name` field, enter the name of the user task.
. Apply the delegate template for this task -- *User Form*.
. Associate the user task with the UI form using the *`Form key`* parameter. Enter the value *`selfregistration-denied-handmoderation`*.
. In the *Assignee* field, specify the variable for the person assigned to the current task - *`${initiator}`*.

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-19.png[]

//Далі встановлюється результат виконання, що реєстрацію не пройдено й відбувається завершення процесу відповідно до кінцевої події в альтернативному потоці.
Next, set the outcome that the registration was not completed, and the process concludes according to the end event in the alternative flow.

//=== Видалення ролі unregistered-officer та призначення ролі officer посадовій особі
=== Removing the unregistered-officer role and assigning the Officer role to the Officer

//Після підтвердження реєстрації, дані передаються до сервісної задачі, яка використовує делегат *`Save user roles`* для перепризначення ролей користувачам та збереження їх до БД Keycloak.
After confirming the registration, data is passed to a service task that uses the *`Save user roles`* delegate to reassign roles to users and save them to the Keycloak database.

//Ця задача виконує наступні дії:
This task performs the following actions:

//. Видаляє роль *`unregistered-officer`* у користувача, який проходить самореєстрацію.
//. Додає роль officer до користувача після успішної самореєстрації.
. Removes the *`unregistered-officer`* role from the user who completes self-registration.
. Adds the officer role to the user after successful self-registration.

//Задача використовує делегат *`${keycloakSaveUserRoleConnectorDelegate}`*, який взаємодіє з Keycloak для зміни ролей користувача. Інформація про ролі та інші параметри передаються через input-параметри:
The task uses the *`${keycloakSaveUserRoleConnectorDelegate}`* delegate, which interacts with Keycloak to change the user's roles. Role information and other parameters are passed through input parameters:

//* *`realm`* встановлюється як *`OFFICER`*.
//* *`roles`* містить список ролей, які будуть додані користувачу (у цьому випадку -- *`officer`*).
//* *`username`* отримує значення імені користувача, який проходить самореєстрацію (*`${initiator().userName}`*).
//* *`roleType`* встановлюється на *`ALL ROLES`*, що вказує на те, що зміни будуть застосовані до всіх ролей користувача.
* *realm* is set to *`OFFICER`*.
* *roles* contains a list of roles to be added to the user (in this case, *`officer`*).
* *`username`* receives the value of the username of the user completing self-registration (*`${initiator().userName}`*).
* *`roleType`* is set to *`ALL ROLES`*, indicating that changes will be applied to all user roles.

image:bp-modeling/bp/element-temp/service-task/save-user-roles/delegate-save-user-roles-1.png[]

//TIP: Детальніше про делегат ви можете переглянути на сторінці xref:bp-modeling/bp/element-templates/bp-element-templates-installation-configuration.adoc#save-user-roles[Збереження ролей користувачів до Keycloak (Save user roles)].
TIP: For more details about the delegate, you can refer to the xref:bp-modeling/bp/element-templates/bp-element-templates-installation-configuration.adoc#save-user-roles[Save user roles to Keycloak] page.

//=== Виведення на форму інформації по успішне завершення процесу реєстрації
=== Displaying information on successful registration process completion

//Ця задача (*User Task*) відображає інформаційне повідомлення для користувача після успішної самореєстрації. Користувач повинен переглянути інформацію та підтвердити її перегляд. Задача використовує шаблон форми *`User form`* та ключ форми *`selfregistration-success`* для відображення відповідного інтерфейсу користувача. Задача призначена для виконання ініціатором процесу самореєстрації (*`${initiator}`*).
This user task displays an informational message to the user after a successful self-registration. The user should review the information and confirm its viewing. The task uses the *`User Form`* template and the form key *`selfregistration-success`* to display the corresponding user interface. The task is assigned to the initiator of the self-registration process (*`${initiator}`*).

//Виконайте наступні налаштування: ::
Configuration steps: ::

//. У полі `Name` введіть назву користувацької задачі.
//. Застосуйте шаблон делегата для цієї задачі -- *User Form*.
//. Поєднайте користувацьку задачу із UI-формою за допомогою параметра *`Form key`*. Введіть значення *`selfregistration-success`*.
//. У полі *`Assignee`* вкажіть змінну для особи, якій призначається поточна задача, -- *`${initiator}`*.
. In the *Name* field, enter the name of the user task.
. Apply the delegate template for this task -- *User Form*.
. Associate the user task with the UI form using the *`Form key`* parameter. Enter the value *`selfregistration-success`*.
. In the *Assignee* field, specify the variable for the person assigned to the current task - *`${initiator}`*.

image:best-practices/officer-auto-register/manual-moderation/officer-self-register-manual-mod-20.png[]

//=== Встановлення результату виконання та завершення процесу
=== Setting the execution result and completing the process

//У наступних задачах встановіть результат виконання процесу, використавши для цього сервісну задачу та делегат *Define business process status*, та закінчіть процес подією завершення (*End event*).
In the following tasks, set the execution result of the process using a service task and the *Define business process status* delegate, and conclude the process with an End event.
