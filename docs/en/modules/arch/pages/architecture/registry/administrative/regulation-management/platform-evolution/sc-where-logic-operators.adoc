:toc-title: On this page:
:toc: auto
:toclevels: 5
:experimental:
:sectnums:
:sectnumlevels: 5
:sectanchors:
:sectlinks:
:partnums:

= Managing logical operators in search conditions

NOTE: üåê This document is available in both English and Ukrainian. Use the language toggle in the top right corner to switch between versions.

== General description

This article covers implementation of a possibility for a modeler to manage logical operators, `OR` or `AND`, for combining the search parameters, and the order of their defining.
//–£ —Ü—ñ–π —Å—Ç–∞—Ç—Ç—ñ –±—É–¥–µ —Ä–æ–∑–≥–ª—è–Ω—É—Ç–∞ —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—è –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ –º–æ–¥–µ–ª—é–≤–∞–ª—å–Ω–∏–∫–∞ –∫–µ—Ä—É–≤–∞—Ç–∏ —è–∫–∏–º –ª–æ–≥—ñ—á–Ω–∏–º –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º, OR —á–∏ AND, –±—É–¥—É—Ç—å –æ–±'—î–¥–Ω—É–≤–∞—Ç–∏—Å—å –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –ø–æ—à—É–∫—É —Ç–∞ –≤ —è–∫–æ–º—É –ø–æ—Ä—è–¥–∫—É –≤–æ–Ω–∏ –±—É–¥—É—Ç—å –≤–∏–∑–Ω–∞—á–∞—Ç–∏—Å—è.

== Actors and user roles
//== –ê–∫—Ç–æ—Ä–∏ —Ç–∞ —Ä–æ–ª—ñ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤
* Registry developer
//* –†–æ–∑—Ä–æ–±–Ω–∏–∫ —Ä–µ–≥–ª–∞–º–µ–Ω—Ç—É

== General provisions
//== –ó–∞–≥–∞–ª—å–Ω—ñ –ø—Ä–∏–Ω—Ü–∏–ø–∏ —Ç–∞ –ø–æ–ª–æ–∂–µ–Ω–Ω—è

* The behavior and the contract of existing search criteria do not change.
//* –ü–æ–≤–µ–¥—ñ–Ω–∫–∞ —ñ –∫–æ–Ω—Ç—Ä–∞–∫—Ç —ñ—Å–Ω—É—é—á–∏—Ö –∫—Ä–∏—Ç–µ—Ä—ñ—ó–≤ –ø–æ—à—É–∫—É –Ω–µ –∑–º—ñ–Ω—é—î—Ç—å—Å—è.
* Reverse compatibility of search criteria configuration is maintained.
//* –ó–±–µ—Ä—ñ–≥–∞—î—Ç—å—Å—è –∑–≤–æ—Ä–æ—Ç–Ω–∞ —Å—É–º—ñ—Å–Ω—ñ—Å—Ç—å –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó –∫—Ä–∏—Ç–µ—Ä—ñ—ó–≤ –ø–æ—à—É–∫—É.

== Functional scenarios
//== –§—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—å–Ω—ñ —Å—Ü–µ–Ω–∞—Ä—ñ—ó

* Setting up search criteria
//* –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –∫—Ä–∏—Ç–µ—Ä—ñ—ó–≤ –ø–æ—à—É–∫—É
* Generation of search criteria services
//* –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è —Å–µ—Ä–≤—ñ—Å—ñ–≤ –∫—Ä–∏—Ç–µ—Ä—ñ—ó–≤ –ø–æ—à—É–∫—É

== Current implementation
//== –ü–æ—Ç–æ—á–Ω–∞ —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—è

In the search criteria, there is a possibility to set the fields for searching using the `searchType` attribute of the `ext:column` tag.
//–í –∫—Ä–∏—Ç–µ—Ä—ñ—è—Ö –ø–æ—à—É–∫—É —î –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å –∑–∞–¥–∞–≤–∞—Ç–∏ –ø–æ–ª—è, –ø–æ —è–∫–∏–º –±—É–¥–µ –≤—ñ–¥–±—É–≤–∞—Ç–∏—Å—è –ø–æ—à—É–∫, –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é –∞—Ç—Ä–∏–±—É—Ç–∞ `searchType` —Ç–µ–≥—É `ext:column`.

For example, for a search criterion defined as follows:
//–ù–∞–ø—Ä–∏–∫–ª–∞–¥, –¥–ª—è –∫—Ä–∏—Ç–µ—Ä—ñ—é –ø–æ—à—É–∫—É –≤–∏–∑–Ω–∞—á–µ–Ω–æ–≥–æ –Ω–∞—Å—Ç—É–ø–Ω–∏–º —á–∏–Ω–æ–º

[source, xml]
----
 <changeSet author="registry owner" id="create SC">
    <ext:createSearchCondition name="dictionary">
        <ext:table name="dict" alias="d">
            <ext:column name="name" searchType="startsWith" />
            <ext:column name="live" searchType="equal" />
            <ext:column name="id" searchType="equal" />
            <ext:column name="description"/>
        </ext:table>
    </ext:createSearchCondition>
</changeSet>
---- 

when calling, provided that all parameters have been passed, the following search string is generated that combines all the parameters using the `AND' operator.
//–ø—Ä–∏ –≤–∏–∑–æ–≤—ñ, –∑–∞ —É–º–æ–≤–∏ —â–æ –ø–µ—Ä–µ–¥–∞–Ω—ñ –≤—Å—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏, –±—É–¥–µ —Å—Ñ–æ—Ä–º–æ–≤–∞–Ω–æ –Ω–∞—Å—Ç—É–ø–Ω–∏–π —Ä—è–¥–æ–∫ –ø–æ—à—É–∫—É —è–∫–∏–π –æ–±'—î–¥–Ω–∞—î –≤—Å—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º `AND`

[source, sql]
----
name like '$1%' AND live = $2 AND id = $3
---- 

According to the API search criteria contract, the search parameters are optional. Therefore, if a parameter is not passed, it is not included into the search string. For example, if the `id` parameter is not passed, then the search string is generated without it.
//–ó–∞ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–º API –∫—Ä–∏—Ç–µ—Ä—ñ—ó–≤ –ø–æ—à—É–∫—É, –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –ø–æ—à—É–∫—É —î –Ω–µ–æ–±–æ–≤'—è–∑–∫–æ–≤–∏–º–∏, —Ç–æ–º—É —è–∫—â–æ –ø–∞—Ä–∞–º–µ—Ç—Ä –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω–∏–π –≤—ñ–Ω –Ω–µ –ø–æ—Ç—Ä–∞–ø–ª—è—î –¥–æ —Ä—è–¥–∫–∞ –ø–æ—à—É–∫—É. –ù–∞–ø—Ä–∏–∫–ª–∞–¥, —è–∫—â–æ –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω–∏–π –ø–∞—Ä–∞–º–µ—Ç—Ä `id`, —Ç–æ —Ä—è–¥–æ–∫ –ø–æ—à—É–∫—É —Å—Ñ–æ—Ä–º—É—î—Ç—å—Å—è –±–µ–∑ –Ω—å–æ–≥–æ

[source, sql]
----
name like '$1%' AND live = $2
---- 

In any case, all parameters are combined by the `AND' operator, and the regulation modeler cannot change this.
//–í –±—É–¥—å —è–∫–æ–º—É —Ä–∞–∑—ñ –≤—Å—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –æ–±'—î–¥–Ω—É—é—Ç—å—Å—è –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º `AND`, —Ç–∞ –º–æ–¥–µ–ª—é–≤–∞–ª—å–Ω–∏–∫ —Ä–µ–≥–ª–∞–º–µ–Ω—Ç—É –Ω–µ –º–∞—î –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ —Ü–µ –∑–º—ñ–Ω–∏—Ç–∏.

== Target design
//== –¶—ñ–ª—å–æ–≤–∏–π –¥–∏–∑–∞–π–Ω

=== Schema and Liquibase tag extension module
//=== –°—Ö–µ–º–∞ —Ç–∞ –º–æ–¥—É–ª—å —Ä–æ–∑—à–∏—Ä–µ–Ω–Ω—è —Ç–µ–≥—ñ–≤ Liquibase

In the scheme of extended tags, the `ext:logicOperator` element of new `tableLogicOperatorType` type is added to the allowed child elements of the `ext:table` tag with the `tableSearchConditionType` type (the one used for tables, not the tag having the same name used in the CTE and having a different type). It has one mandatory `type` attribute, the type of `or` or `and` logical operator , and can contain `ext:column` and `ext:logicOperator` elements, i.e. itself.
//–í —Å—Ö–µ–º—ñ —Ä–æ–∑—à–∏—Ä–µ–Ω–∏—Ö —Ç–µ–≥—ñ–≤ –¥–æ –¥–æ–∑–≤–æ–ª–µ–Ω–∏—Ö –¥–æ—á—ñ—Ä–Ω—ñ—Ö –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ —Ç–µ–≥—É `ext:table` –∑ —Ç–∏–ø–æ–º `tableSearchConditionType` (—Ç–æ–π —â–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –¥–ª—è —Å–∞–º–µ —Ç–∞–±–ª–∏—Ü—å, –∞ –Ω–µ –æ–¥–Ω–æ–π–º–µ–Ω–Ω–∏–π —Ç–µ–≥ —â–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –≤ CTE —ñ –º–∞—î —ñ–Ω—à–∏–π —Ç–∏–ø) –¥–æ–¥–∞—î—Ç—å—Å—è –µ–ª–µ–º–µ–Ω—Ç `ext:logicOperator` –Ω–æ–≤–æ–≥–æ —Ç–∏–ø—É `tableLogicOperatorType`. –í—ñ–Ω –º–∞—î –æ–¥–∏–Ω –æ–±–æ–≤'—è–∑–∫–æ–≤–∏–π –∞—Ç—Ä–∏–±—É—Ç `type` - —Ç–∏–ø –ª–æ–≥—ñ—á–Ω–æ–≥–æ –æ–ø–µ—Ä–∞—Ç–æ—Ä—É `or` —á–∏ `and`, —Ç–∞ –º–æ–∂–µ –≤–º—ñ—â—É–≤–∞—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç–∏ `ext:column` —Ç–∞ `ext:logicOperator` —Ç–æ–±—Ç–æ —Å–∞–º —Å–µ–±–µ.

.Changes to the Liquibase extended tag scheme
//.–ó–º—ñ–Ω–∏ —Å—Ö–µ–º–∏ —Ä–æ–∑—à–∏—Ä–µ–Ω–∏—Ö —Ç–µ–≥—ñ–≤ Liquibase
[source, xml]
----
<xsd:complexType name="tableLogicOperatorType">
    <xsd:sequence>
        <xsd:choice minOccurs="1" maxOccurs="unbounded">
            <xsd:element name="column" type="columnSearchConditionType" maxOccurs="unbounded"/>
            <xsd:element name="logicOperator" type="tableLogicOperatorType" maxOccurs="unbounded"/>
        </xsd:choice>
    </xsd:sequence>		
    <xsd:attribute name="type" type="logicOperatorType" use="required"/>
</xsd:complexType>
....
<xsd:complexType name="tableSearchConditionType">
    <xsd:sequence>
        <xsd:choice minOccurs="1" maxOccurs="unbounded">
            <xsd:element name="column" type="columnSearchConditionType" maxOccurs="unbounded"/>
            <xsd:element name="function" type="functionType" maxOccurs="unbounded"/>
            <xsd:element name="logicOperator" type="tableLogicOperatorType" maxOccurs="unbounded"/>
        </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="required"/>
    <xsd:attribute name="alias" type="xsd:string" use="optional"/>
</xsd:complexType>

----

The possibility to write all the information about `ext:logicOperator` tags required for service generation in the `ddm_liquibase_metadata` metadata table when processing the _createSearchCondition_ tag is added to the Liquibase tag extension module.
//–í –º–æ–¥—É–ª—å —Ä–æ–∑—à–∏—Ä–µ–Ω–Ω—è —Ç–µ–≥—ñ–≤ Liquibase –¥–æ–¥–∞—î—Ç—å—Å—è –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å –∑–∞–ø–∏—Å—É –≤—Å—ñ—î, –Ω–µ–æ–±—Ö—ñ–¥–Ω–æ—ó –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü—ñ—ó —Å–µ—Ä–≤—ñ—Å—É, —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó –ø—Ä–æ —Ç–µ–≥–∏ `ext:logicOperator` –≤ —Ç–∞–±–ª–∏—Ü—é –º–µ—Ç–∞–¥–∞–Ω–∏—Ö `ddm_liquibase_metadata`, –ø—Ä–∏ –æ–±—Ä–æ–±—Ü—ñ —Ç–µ–≥—É _createSearchCondition_.

Placing the `ext:column` tags without the `searchType` attribute inside the `ext:logicOperator` tag is prohibited.
//–†–æ–∑–º—ñ—â–µ–Ω–Ω—è —Ç–µ–≥—ñ–≤ `ext:column` –±–µ–∑ –∞—Ç—Ä–∏–±—É—Ç—É `searchType` –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ —Ç–µ–≥—É `ext:logicOperator` –∑–∞–±–æ—Ä–æ–Ω—è—î—Ç—å—Å—è.

=== Service generator
//=== –°–µ—Ä–≤—ñ—Å –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä

The `ext:logicOperator` tag controls which column conditions are bracketed and which operator is used to combine these bracketed conditions. That is, opening a tag is equivalent to the opening bracket, and closing a tag is equivalent to the closing bracket in the resulting request to the database, and the `type` attribute indicates which logical operator to use.
//–¢–µ–≥ `ext:logicOperator` –∫–µ—Ä—É—î —Ç–∏–º, —É–º–æ–≤–∏ –ø–æ —è–∫–∏–º –∫–æ–ª–æ–Ω–∫–∞–º –±–µ—Ä—É—Ç—å—Å—è –≤ –¥—É–∂–∫–∏ —Ç–∞ —è–∫–∏–π –æ–ø–µ—Ä–∞—Ç–æ—Ä –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è –¥–ª—è –ø–æ—î–¥–Ω–∞–Ω–Ω—è —Ü–∏—Ö —É–º–æ–≤ —É –¥—É–∂–∫–∞—Ö. –¢–æ–±—Ç–æ –≤—ñ–¥–∫—Ä–∏—Ç—Ç—è —Ç–µ–≥—É –µ–∫–≤—ñ–≤–∞–ª–µ–Ω—Ç–Ω–æ –≤—ñ–¥–∫—Ä–∏—Ç—Ç—é –¥—É–∂–∫–∏ —Ç–∞ –∑–∞–∫—Ä–∏—Ç—Ç—è —Ç–µ–≥—É –∑–∞–∫—Ä–∏—Ç—Ç—é –¥—É–∂–∫–∏ –≤ —Ä–µ–∑—É–ª—å—Ç—É—é—á–µ–º—É –∑–∞–ø–∏—Ç—ñ –¥–æ –ë–î, –∞ –∞—Ç—Ä–∏–±—É—Ç `type` –≤–∫–∞–∑—É—î –Ω–∞ —Ç–µ —è–∫–∏–π –ª–æ–≥—ñ—á–Ω–∏–π –æ–ø–µ—Ä–∞—Ç–æ—Ä –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏.

When implementing the algorithm, the following rules shall be kept in mind:
//–ü—Ä–∏ —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó –∞–ª–≥–æ—Ä–∏—Ç–º—É –ø–æ—Ç—Ä—ñ–±–Ω–æ –º–∞—Ç–∏ –Ω–∞ —É–≤–∞–∑—ñ –Ω–∞—Å—Ç—É–ø–Ω—ñ –ø—Ä–∞–≤–∏–ª–∞:

* First-level `ext:table` search conditions are combined using the `and` operator, just like before the changes.
//* –£–º–æ–≤–∏ –ø–æ—à—É–∫—É –ø–µ—Ä—à–æ–≥–æ —Ä—ñ–≤–Ω—è `ext:table` –æ–±'—î–¥–Ω—É—é—Ç—å—Å—è –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º `and`, —Ç–∞–∫ —Å–∞–º–æ —è–∫ —ñ –¥–æ –∑–º—ñ–Ω.
* Search conditions between different tables are combined using the `and` operator.
//* –ú—ñ–∂ —Ä—ñ–∑–Ω–∏–º–∏ —Ç–∞–±–ª–∏—Ü—è–º–∏ —É–º–æ–≤–∏ –ø–æ—à—É–∫—É –æ–±'—î–¥–Ω—É—é—Ç—å—Å—è –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º `and`.
* If no conditions are passed for any of the columns inside the `ext:logicOperator` element during a call, then this element is not processed.
//* –Ø–∫—â–æ –ø—Ä–∏ –≤–∏–∫–ª–∏–∫—É –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω–æ —É–º–æ–≤–∏ –¥–ª—è –∂–æ–¥–Ω–æ—ó –∑ –∫–æ–ª–æ–Ω–æ–∫ —â–æ –∑–Ω–∞—Ö–æ–¥—è—Ç—å—Å—è –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ –µ–ª–µ–º–µ–Ω—Ç—É `ext:logicOperator` —Ç–æ –≤—ñ–Ω –Ω–µ –æ–±—Ä–æ–±–ª—è—î—Ç—å—Å—è.

For example, when calling for the following search criterion
//–ù–∞–ø—Ä–∏–∫–ª–∞–¥ –ø—Ä–∏ –≤–∏–∑–æ–≤—ñ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –∫—Ä–∏—Ç–µ—Ä—ñ—é –ø–æ—à—É–∫—É
[source, xml]
----
<changeSet author="registry owner" id="create SC registration_equal_laboratory_id_solution">
    <ext:createSearchCondition name="registration_equal_laboratory_id_solution">
        <ext:table name="registration" alias="r">
            <ext:column name="registration_id" />
            <ext:column name="registration_no" searchType="equal"/>
            <ext:column name="created_date" />
            <ext:logicOperator type="or">
                <ext:column name="solution_date" searchType="equal" />
                <ext:column name="laboratory_id" searchType="equal" />
                <ext:logicOperator type="and">
                    <ext:column name="name" searchType="equal" />
                    <ext:column name="surname" searchType="equal" />
                </ext:logicOperator>
            </ext:logicOperator>
        </ext:table>
        <ext:table name="solution_type" alias="s">
            <ext:logicOperator type="or">
                <ext:column name="name" alias="solution_name" searchType="equal" />
                <ext:column name="constant_code" alias="solution_code" searchType="equal" />
            </ext:logicOperator>
        </ext:table>
        <ext:join type="inner">
            <ext:left alias="r">
                <ext:column name="solution_type_id" />
            </ext:left>
            <ext:right alias="s">
                <ext:column name="solution_type_id" />
            </ext:right>
        </ext:join>
    </ext:createSearchCondition>
</changeSet>
----
the following search string should be generated, provided that all parameters are passed:
//–ø–æ–≤–∏–Ω–µ–Ω –≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏—Å—å —Ç–∞–∫–∏–π —Ä—è–¥–æ–∫ –ø–æ—à—É–∫—É, –∑–∞ —É–º–æ–≤–∏ —â–æ –ø–µ—Ä–µ–¥–∞–Ω—ñ –≤—Å—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏:

[source, sql]
----
                        -- <ext:table name="registration" alias="r">
                        --     <ext:column name="registration_id" />
                        --     <ext:column name="created_date" />
registration_no=$0      --     <ext:column name="registration_no" searchType="equal"/>
AND
(                       --     <ext:logicOperator type="or">
    solution_date=$1    --         <ext:column name="solution_date" searchType="equal" />
    OR
    laboratory_id=$2    --         <ext:column name="laboratory_id" searchType="equal" />
    OR
    (                   --         <ext:logicOperator type="and">
        firstname=$3    --             <ext:column name="firstname" searchType="equal" />
        AND    
        surname=$4      --             <ext:column name="surname" searchType="equal" />
    )                   --         </ext:logicOperator>
)                       --     </ext:logicOperator>
                        -- </ext:table>
AND
                        -- <ext:table name="solution_type" alias="s">
(                       --     <ext:logicOperator type="or">
    name=$5             --         <ext:column name="name" alias="solution_name" searchType="equal" />
    OR
    constant_code=$6    --         <ext:column name="constant_code" alias="solution_code" searchType="equal" />
)                       --     </ext:logicOperator>
                        -- </ext:table>
----


=== System components and their designation in the solution design
//=== –ö–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ —Å–∏—Å—Ç–µ–º–∏ —Ç–∞ —ó—Ö –ø—Ä–∏–∑–Ω–∞—á–µ–Ω–Ω—è –≤ —Ä–∞–º–∫–∞—Ö –¥–∏–∑–∞–π–Ω—É —Ä—ñ—à–µ–Ω–Ω—è
This section gives a list of system components that are engaged or need to be changed/created in the framework of the implementation of functional requirements according to the technical design of the solution.
//–£ –¥–∞–Ω–æ–º—É —Ä–æ–∑–¥—ñ–ª—ñ –Ω–∞–≤–µ–¥–µ–Ω–æ –ø–µ—Ä–µ–ª—ñ–∫ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç —Å–∏—Å—Ç–µ–º–∏, —è–∫—ñ –∑–∞–¥—ñ—è–Ω—ñ –∞–±–æ –ø–æ—Ç—Ä–µ–±—É—é—Ç—å –∑–º—ñ–Ω/—Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –≤ —Ä–∞–º–∫–∞—Ö —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—å–Ω–∏—Ö –≤–∏–º–æ–≥ –∑–≥—ñ–¥–Ω–æ –∑ —Ç–µ—Ö–Ω—ñ—á–Ω–∏–º –¥–∏–∑–∞–π–Ω–æ–º —Ä—ñ—à–µ–Ω–Ω—è.

|===
|Component|Service name|Designation / Changes
//|–ö–æ–º–ø–æ–Ω–µ–Ω—Ç|–°–ª—É–∂–±–æ–≤–∞ –Ω–∞–∑–≤–∞|–ü—Ä–∏–∑–Ω–∞—á–µ–Ω–Ω—è / –°—É—Ç—å –∑–º—ñ–Ω
|Service Generator
//|–°–µ—Ä–≤—ñ—Å –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä
|service-generation-utility
|Generation of Java projects for services
//|–ì–µ–Ω–µ—Ä–∞—Ü—ñ—è Java-–ø—Ä–æ–µ–∫—Ç—ñ–≤ –¥–ª—è —Å–µ—Ä–≤—ñ—Å—ñ–≤

|Liquibase extended tagging scheme
//|–°—Ö–µ–º–∞ —Ä–æ–∑—à–∏—Ä–µ–Ω–∏—Ö —Ç–µ–≥—ñ–≤ Liquibase
|liquibase-ext-schema
|Scheme validation
//|–í–∞–ª—ñ–¥–∞—Ü—ñ—è —Å—Ö–µ–º–∏

|Liquibase tag extension module
//|–ú–æ–¥—É–ª—å —Ä–æ–∑—à–∏—Ä–µ–Ω–Ω—è —Ç–µ–≥—ñ–≤ Liquibase
|liquibase-ddm-ext
|Processing of extended tags at the regulations deployment stage
//|–û–±—Ä–æ–±–∫–∞ —Ä–æ–∑—à–∏—Ä–µ–Ω–∏—Ö —Ç–µ–≥—ñ–≤ –Ω–∞ –µ—Ç–∞–ø—ñ —Ä–æ–∑–≥–æ—Ä—Ç–∞–Ω–Ω—è —Ä–µ–≥–ª–∞–º–µ–Ω—Ç—É

|===

== Registry regulations modeling

=== Modeling search conditions

The regulations administrator gets a possibility to control which logical operator, OR or AND, to use for combining the search parameters and in which order they are determined.
//–ê–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä—É —Ä–µ–≥–ª–∞–º–µ–Ω—Ç—É –Ω–∞–¥–∞—î—Ç—å—Å—è –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å –∫–µ—Ä—É–≤–∞—Ç–∏ —è–∫–∏–º –ª–æ–≥—ñ—á–Ω–∏–º –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º, OR —á–∏ AND, –±—É–¥—É—Ç—å –æ–±'—î–¥–Ω—É–≤–∞—Ç–∏—Å—å –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –ø–æ—à—É–∫—É —Ç–∞ –≤ —è–∫–æ–º—É –ø–æ—Ä—è–¥–∫—É –≤–æ–Ω–∏ –±—É–¥—É—Ç—å –≤–∏–∑–Ω–∞—á–∞—Ç–∏—Å—è.

.Registry regulations structure
//.–°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ä–µ–≥–ª–∞–º–µ–Ω—Ç—É —Ä–µ—î—Å—Ç—Ä—É
[plantuml, registry-sc-regulation-structure, svg]
----
@startsalt
{
{T
+ <&folder> registry-regulation
++ <&folder> bpmn
++ <&folder> dmn
++ <&folder> <b>data-model</b>
+++ <&file> <b>searchConditions.xml</b>
++ ...
}
}
@endsalt
----

.Configuration example
//.–ü—Ä–∏–∫–ª–∞–¥ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó
[source, xml]
----
 <changeSet author="registry owner" id="create or/and SC">
    <ext:createSearchCondition name="dictionary">
        <ext:table name="dict" alias="d">
            <ext:logicOperator type="or">
                <ext:logicOperator type="and">
                    <ext:column name="name" searchType="startsWith" />
                    <ext:column name="live" searchType="equal" />
                </ext:logicOperator>
                <ext:column name="id" searchType="equal" />
            </ext:logicOperator>
            <ext:column name="description"/>
        </ext:table>
    </ext:createSearchCondition>
</changeSet>
----


=== Validation of registry regulations
//=== –í–∞–ª—ñ–¥–∞—Ü—ñ—è —Ä–µ–≥–ª–∞–º–µ–Ω—Ç—É —Ä–µ—î—Å—Ç—Ä—É
As part of the implementation of the solution, the xml scheme of extended liquibase tags used for validation will be extended.
//–í —Ä–∞–º–∫–∞—Ö —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó —Ä—ñ—à–µ–Ω–Ω—è, –±—É–¥–µ —Ä–æ–∑—à–∏—Ä–µ–Ω–∞ xml —Å—Ö–µ–º–∞ —Ä–æ–∑—à–∏—Ä–µ–Ω–∏—Ö —Ç–µ–≥—ñ–≤ liquibase –ø–æ —è–∫—ñ–π –ø—Ä–æ—Ö–æ–¥–∏—Ç—å –≤–∞–ª—ñ–¥–∞—Ü—ñ—è.

== High-level development plan
//== –í–∏—Å–æ–∫–æ—Ä—ñ–≤–Ω–µ–≤–∏–π –ø–ª–∞–Ω —Ä–æ–∑—Ä–æ–±–∫–∏
=== Technical assessments
//=== –¢–µ—Ö–Ω—ñ—á–Ω—ñ –µ–∫—Å–ø–µ—Ä—Ç–∏–∑–∏
* _BE_

=== Development plan
//=== –ü–ª–∞–Ω —Ä–æ–∑—Ä–æ–±–∫–∏
* Extension of the Liquibase extended tags scheme.
//* –†–æ–∑—à–∏—Ä–µ–Ω–Ω—è —Å—Ö–µ–º–∏ —Ä–æ–∑—à–∏—Ä–µ–Ω–∏—Ö —Ç–µ–≥—ñ–≤ Liquibase.
* Liquibase tag extension module extension.
//* –†–æ–∑—à–∏—Ä–µ–Ω–Ω—è –º–æ–¥—É–ª—è —Ä–æ–∑—à–∏—Ä–µ–Ω–Ω—è —Ç–µ–≥—ñ–≤ Liquibase.
* Extension of service generator.
//* –†–æ–∑—à–∏—Ä–µ–Ω–Ω—è —Å–µ—Ä–≤—ñ—Å –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—É.
* Development of instructions for the regulations developer and reference examples.
//* –†–æ–∑—Ä–æ–±–∫–∞ —ñ–Ω—Å—Ç—Ä—É–∫—Ü—ñ–π –¥–ª—è —Ä–æ–∑—Ä–æ–±–Ω–∏–∫–∞ —Ä–µ–≥–ª–∞–º–µ–Ω—Ç—É —Ç–∞ —Ä–µ—Ñ–µ—Ä–µ–Ω—Ç–Ω–∏—Ö –ø—Ä–∏–∫–ª–∞–¥—ñ–≤.