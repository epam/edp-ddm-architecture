:toc-title: On this page:
:toc: auto
:toclevels: 5
:experimental:
:sectnums:
:sectnumlevels: 5
:sectanchors:
:sectlinks:
:partnums:

//= Практики розробки та контролю якості програмного забезпечення
= Software development and quality control practices

//Approaches, methods, and standards of software development
//== Підходи, методики та стандарти розробки програмного забезпечення
== Approaches, methodologies, and standards of software development

//=== Підходи та методики розробки
=== Development approaches and methodologies

//Під час розробки компонентів інформаційної системи впроваджені наступні методики та підходи:
The following methodologies and approaches are implemented during the development of information systems components:

//. Використання об'єктно-орієнтованого підходу у розробці програмного забезпечення;
//. Впровадження віртуалізації на основі контейнерів;
//. Автоматизація розгортання з допомогою GitOps-підходу;
//. Організація документації як коду;
//. Уніфікація та стандартизація програмних компонентів;
//. Декомпозиція підсистем на модулі;
//. Оцінка ризиків та моделювання загроз безпеки;
//. Виконання функціонального та нефункціонального тестування.
. Utilization of object-oriented approach in software development;
. Implementation of container-based virtualization;
. Automation of deployment using the GitOps approach;
. Documentation organization following the code organization example;
. Unification and standardization of software components;
. Subsystem decomposition into modules;
. Risk assessment and security threat modeling;
. Execution of functional and non-functional testing.

////
Approaches and methods of software development

During the development of the information system components, we implement the following methods and approaches:

* Utilization of an object-oriented approach in software development;
* Implementation of container-based virtualization;
* Deployment automation using the GitOps approach;
* Treating documentation as code;
* Unification and standardization of software components;
* Decomposition of subsystems into modules;
* Risk assessment and security threat modeling;
* Execution of functional and non-functional testing.
////

//Coding standards
//=== Стандарти Кодування
=== Coding standards

//==== Стандарти та рекомендації з дизайну
==== Design standards and recommendations

////
. Stick to the "Zen of Python" philosophy:

* Beautiful is better than ugly.
* Explicit is better than implicit.
* Simple is better than complex.
* Complex is better than complicated.
* Flat is better than nested.
* Sparse is better than dense.
* Readability counts.
* Special cases aren't special enough to break the rules.
* Although practicality beats purity.
* Errors should never pass silently.
* Unless explicitly silenced.
* In the face of ambiguity, refuse the temptation to guess.
* There should be one-- and preferably only one --obvious way to do it.
* Although that way may not be obvious at first unless you're Dutch.
* Now is better than never.
* Although never is often better than *right* now.
* If the implementation is hard to explain, it's a bad idea.
* If the implementation is easy to explain, it may be a good idea.
* Namespaces are one honking great idea -- let's do more of those!
////

//. Дотримуйтеся філософії "Zen of Python":
. Adhere to the "Zen of Python" philosophy:
+
//* Вищість гарного над потворним.
//* Перевага явного перед неявним.
//* Простота переважає складність.
//* Складність є кращою, ніж заплутаність.
//* Плоска структура краща за вкладену.
//* Розрідженість переважає щільність.
//* Важливість легкості читання.
//* Особливі випадки не є настільки особливими, щоб порушувати правила.
//* Однак практичність важливіша за бездоганність.
//* Помилки не мають залишатись непомітними.
//* Якщо приховування помилок не зазначено явно.
//* При стиканні з неоднозначностями, відкиньте спокусу вгадувати.
//* Має існувати один і, бажано, _лише_ один очевидний спосіб зробити це.
//* Хоча він може бути не очевидним, якщо ви не голландець.
//* Час діяти -- зараз.
//* Хоча "ніколи" часто краще, ніж _просто_ зараз.
//* Якщо важко пояснити реалізацію -- задум поганий.
//* Якщо реалізацію можна легко пояснити, тоді, _можливо_, задум добрий.
//* Простори імен -- це велика перевага, створюймо їх більше!
* Beautiful is better than ugly.
* Explicit is better than implicit.
* Simple is better than complex.
* Complex is better than complicated.
* Flat is better than nested.
* Sparse is better than dense.
* Readability counts.
* Special cases aren't special enough to break the rules.
* Although practicality beats purity.
* Errors should never pass silently.
* Unless explicitly silenced.
* In the face of ambiguity, refuse the temptation to guess.
* There should be one--and preferably only one--obvious way to do it.
* Although that way may not be obvious at first unless you're Dutch.
* Now is better than never.
* Although never is often better than right now.
* If the implementation is hard to explain, it's a bad idea.
* If the implementation is easy to explain, it may be a good idea.
* Namespaces are one honking great idea -- let's do more of those!
+
//. Опція https://en.wikipedia.org/wiki/Fail-fast[Fail fast] найчастіше є найкращим рішенням.
. The https://en.wikipedia.org/wiki/Fail-fast[Fail fast] option is often the best solution.
//. Використовуйте "Return early" для перевірки вхідних параметрів.
. Use "Return early" to validate input parameters.
//. Використовуйте Правило скаутів: "Залишаємо код у стані, кращому ніж ми його знайшли".
. Apply the "Scout rule": "Leave the code better than you found it."
//. Уникайте використання _break, continue, return_ у складних конструкціях.
. Avoid using break, continue, and return in complex constructs.
//. Завжди використовуйте фігурні дужки у циклах та умовах.
. Always use curly braces in loops and conditions.
//. Уникайте створення методів з понад чотирма вхідними параметрами.
. Avoid creating methods with more than four parameters.
//. Уникайте створення методів, що модифікують вхідний параметр.
. Avoid creating methods that modify input parameters.
//. Логування об'єктів має здійснюватися без трансформації об'єктів, з огляду на NPE.
. Logging of objects should occur without object transformation, considering NPE (NullPointerException).

//==== Стандарти стилістики коду (Code Style)
==== Code styling standards (code style)

//. Табуляція: використовуйте чотири пробіли.
. Tabulation: use four spaces.
//. Використовуйте статичні імпорти лише під час роботи з DSL.
. Use static imports only when working with DSL.
//. Замінюйте загальні імпорти ("*") на специфічні.
. Replace wildcard imports ("*") with specific ones.
//. Виділяйте новими рядками лише групи логічно пов'язаних полів, а не кожне поле окремо.
. Separate logical groups of fields with new lines, rather than each field individually.
//. Визначайте поля класу перед полями об'єкта.
. Declare class fields before object fields.
//. При виборі імен змінних орієнтуйтеся на їх функцію, а не на тип. Наприклад, `StringBuilder stringbuilder = new StringBuilder()` -- погано, `StringBuilder fields = new StringBuilder()` -- добре.
. When choosing variable names, focus on their function rather than type. For example, `StringBuilder stringbuilder = new StringBuilder()` is poor practice, whereas `StringBuilder fields = new StringBuilder()` is good.
//. Віддавайте перевагу назвам класів, які починаються з доменного значення. Наприклад: `UserService`, `UserKafkaService` (технологічна складова може йти посередині).
. Prefer class names that start with a domain value. For example: `UserService`, `UserKafkaService` (technology component may go in the middle).

//==== Стандарти роботи з Git
==== Git workflow standards

// У репозиторії не повинно бути специфічних даних, таких як локальні шляхи або налаштування, характерні для конкретного розробника (properties).
. The repository should not contain specific data, such as local paths or settings specific to individual developers (properties).
//. При створенні Git-повідомлень:
. When creating Git commit messages:
+
//* Номер завдання з Jira має бути вказаний на початку у квадратних дужках.
* The Jira task number should be mentioned at the beginning in square brackets.
//* Повідомлення має відповідати на питання: "Що змінив цей commit?".
* The message should answer the question: "What does this commit change?"
//* Якщо опис commit потребує більш детального пояснення, то слід використати короткий заголовок на першому рядку, а потім на новому рядку додати детальний опис (Git вміє з цим працювати).
* If the commit description requires further elaboration, use a short headline on the first line, followed by a detailed description on a new line (Git handles this well).
//* Крапку в кінці повідомлення не ставимо.
* Do not end the commit message with a period.

//==== Вимоги до роботи з POM
==== POM (project object model) working requirements

//. Використовуйте батьківський _pom.xml_ для:
. Use the parent _pom.xml_ for:
//* визначення версії залежності;
//* управління плагінами.
* Defining dependency versions;
* Managing plugins.
+
//. При перенесенні версії бібліотеки до налаштувань (_.properties_), необхідно додати суфікс `.version`. Наприклад, `<querydsl.version>`...`</querydsl.version>`.
. When moving library versions to settings (_.properties_), add the `.version` suffix. For example, `<querydsl.version>`...`</querydsl.version>`.

[#unit-testing-standards]
//==== Стандарти модульного тестування
==== Modular testing standards

//. Рекомендується використовувати підхід _ААА_ -- _ArrangeActAssert_.
. It is recommended to utilize the _AAA_ (_ArrangeActAssert_) approach.
//. Немає потреби в коментарях (_given, when, then_), відділення порожніми рядками є достатнім.
. Comments (_given, when, then_) are unnecessary; separation by empty lines is sufficient.
//. Використовуйте анотацію `@DisplayName` в *JUnit 5* для надання більш детальної інформації.
. Use the `@DisplayName` annotation in *JUnit 5* to provide detailed information.
//. Уникайте "throws Exception" у декларації тестів.
. Avoid using "throws Exception" in test declarations.
//. Не рекомендується використовувати _PowerMock_.
. Usage of _PowerMock_ is not recommended.
//. Для mock-об'єктів додавайте відповідний префікс `mock`. Наприклад, `mockRepository`.
. For mock objects, add the appropriate `mock` prefix, e.g., `mockRepository`.
//. Уникайте беззмістовних повідомлень у перевірках. Наприклад, `Assertions.assertNotNull(object, "Shouldn't be null")`.
. Avoid meaningless messages in assertions, e.g., `Assertions.assertNotNull(object, "Shouldn’t be null`").

//==== Вимога до підтримки "Чистоти" коду
==== Clean code requirement

//При розробці коду дотримуйтеся підходу "*Clean code*" ("чистий код"), що передбачає створення якісного, добре написаного коду.
During code development, adhere to the principles of *Clean Code*, which emphasizes creating quality, well-written code.

//Код вважається "добрим", якщо він:
Code is considered "good" if it:

//* відповідає вимогам, тобто пройшов тести;
//* чітко виражає всі замисли дизайну, які були задумані;
//* не містить дублювання;
//* мінімізує кількість компонентів.
* Meets requirements and has passed tests;
* Clearly expresses all intended design concepts;
* Does not contain duplication;
* Minimizes the number of components.

//==== Використання метрик SQALE для оцінки та управління технічним боргом
==== Using SQALE metrics for technical debt assessment and management

//У процесі розробки програмного забезпечення зміни в одній частині коду часто вимагають супутніх змін в інших сегментах коду або документації. Цей процес відомий як накопичення "_технічного боргу_". Термін "технічний борг" також охоплює інші незавершені, але необхідні зміни, що являє собою "борг", який необхідно погасити у визначений момент у майбутньому.
In software development, changes in one part of the code often require related changes in other code segments or documentation. This process is known as accumulating "_technical debt_". The term "technical debt" also encompasses other necessary but unfinished changes that constitute a "debt" to be repaid at a later time.

Для вимірювання та керування обсягами технічного боргу застосовується методологія *SQALE*.
The *SQALE* methodology is used to measure and manage the volume of technical debt.

//== Методології розробки програмного забезпечення
== Software development methodologies

//Розробка Платформи здійснюється за допомогою методології *Agile software development*.
The Platform development follows the *Agile software development* methodology.

//*Agile software development* (_або гнучка методологія розробки програмного забезпечення_) -- це клас методологій, що ґрунтується на ітеративній розробці. Вона передбачає, що вимоги та рішення еволюціонують у процесі співпраці між самоорганізованими багатофункціональними командами.
*Agile software development* is a class of methodologies based on iterative development. It assumes that requirements and decisions evolve through collaboration among self-organizing cross-functional teams.

//=== Структура виконавців системи (Delivery)
=== System delivery structure

//==== Команди розробки та управління
==== Development and management teams

//* Управлінська команда (Management)
* Management Team
//* Платформна команда (Platform Team)
* Platform Team
//** Три Scrum-команди
//** Сервісна команда Платформи (Platform Service Team)
** Three Scrum eams
** Platform Service Team
//* Команда системних архітекторів (SA Team)
* System Architects Team
//* Центр компетенцій та команда реєстрів (Competence Center and Register Team)
* Competence Center and Register Team
//* Команда управління сервісами (Service Management Team)
* Service Management Team

//==== Впровадження Agile-методології
==== Adoption of Agile methodology

//У рамках використання Agile-методології, основним підходом виступає *Scrum*.
Within the Agile methodology, the primary approach is *Scrum*.

//*Scrum* -- це методика управління проєктами, що зорієнтована на гнучку розробку програмного забезпечення і наголошує на високому рівні якості розробки.
*Scrum* is a project management methodology oriented toward flexible software development, emphasizing high development quality.

//Враховуючи, що Платформа є масштабним та технічно складним продуктом, при розробці якого бере участь велика кількість команд та спеціалістів, використовується підхід *LeSS* (Large Scale Scrum). *LeSS* -- це великомасштабний Scrum, призначений для багатьох команд, які працюють над одним продуктом.
Given the Platform's scale and technical complexity involving numerous teams and specialists, the *LeSS* (Large Scale Scrum) approach is used. *LeSS* is a large-scale Scrum designed for multiple teams working on a single product.

//Такий підхід передбачає _тривалість спринту два тижні_.
This approach involves _two-week sprint_ durations.

//*Scrum-майстром* виступає спеціаліст з управлінської команди -- *Delivery Manager*.
The *Scrum Master* is a specialist from the Management Team acting as a *Delivery Manager*.

//Оцінка зусиль, необхідних для виконання завдань, вимірюється в одиницях *story points*. Кожне завдання, яке може бути подроблене на менші частини, фіксується в Jira backlog та розподіляється між розробниками відповідних команд управлінською командою.
Effort estimation, measured in *story points*, is used for task completion. Each task that can be divided into smaller parts is logged in the Jira backlog and allocated among the respective teams by the Management Team.

//Процес планування проводиться управлінською командою за участю провідних розробників і, за необхідності, усіх членів команди розробників.
The planning process is conducted by the Management Team with the participation of lead developers and, if necessary, all members of the development team.
//Для оцінки складності завдань використовується метод _планування покером_ -- *Planning poker*, який передбачає оцінювання складності задач консенсусно.
Planning poker, which entails consensus-based complexity estimation, is used.
//Виходячи з песимістичних очікувань, задається термін виконання задач, що дає запас часу на їх виконання та забезпечує гнучкість при виникненні ускладнень.
A pessimistic outlook is used to set task completion deadlines, allowing for time buffers and flexibility in case of complications.

//У процесі роботи зі Scrum, впроваджено підхід управління залежностями, що передбачає активний аналіз та мінімізацію ризиків, пов'язаних із внутрішньокомандною або міжкомандною залежністю.
The Scrum process incorporates a dependency management approach involving active analysis and minimization of risks related to intra-team or inter-team dependencies.

//==== Інструменти співпраці між командами
==== Inter-Team collaboration tools

//* Система управління задачами (Ticket management system) Jira.
//* База знань для формування документації (Knowledge base) Confluence.
//* Git-репозиторії для взаємодії з вихідним кодом.
* Using Jira as a ticket management system.
* Using Confluence as a knowledge base for documentation.
* Using Git repositories for source code collaboration.

//==== Використання Scrum-артефактів
==== Usage of Scrum artifacts

//===== Артефакт Definition of Ready (DoR)
===== Definition of Ready (DoR) artifact

//*Definition of Ready (DoR)* у Scrum-фреймворку -- це критерії готовності задачі (користувацької історії -- User Story) до початку роботи над нею. Вони визначають умови, за яких користувацьку історію можна прийняти до виконання і включити у спринт. Для команди важливо мати чіткі DoR для елементів беклогу.
In the Scrum framework, the *Definition of Ready (DoR)* represents the criteria a task (User Story) must fulfill before work begins. These conditions determine when a User Story is ready for execution and inclusion in a sprint. Having clear DoR for backlog items is important for the team.

//Критерії готовності включають наступне:
The readiness criteria include:

//* Історія та задача для беклогу спринту чітко визначені та оцінені на вищому рівні.
* User Story/task is clearly defined and estimated at a high level.
//* Технічні пріоритети встановлені на основі залежностей або технічних можливостей.
* Technical priorities are set based on dependencies or technical capabilities.
//* Історія/задача включає детальний опис, критерії прийняття у форматі списку, нефункціональні вимоги, та ризики.
* User story/task includes a detailed description, acceptance criteria in list format, non-functional requirements, and risks.
//* Керівники/архітектори розуміють, що і як слід робити, і мають можливі запитання для уточнення.
* Managers/architects understand what and how to do and have clarifying questions.
//* Історія/задача знаходиться в одному зі статусів: "В аналізі", "Відкрито", "Заблоковано".
* User story/task is in one of the statuses: "In Analysis," "Open," "Blocked."
//* Історія/задача має посилання на відповідне завдання Epic.
* User story/task has a link to the corresponding Epic.
//* Історія/задача призначена відповідальній за її виконання команді.
* User story/task is assigned to the responsible development team.
//* В історії/задачі зазначена фаза розробки проєкту.
* Development phase of the project is specified for the story/task.
//* Історія/задача незалежна.
* User story/task is independent.
//* Історія/задача затверджена та пріоритезована замовником на основі заявлених вимог під час сесії грумінгу (grooming session).
* User story/task is approved and prioritized by the client based on stated requirements during grooming sessions.
//* Усі блокуючі фактори для історій/задач спринту вирішені.
* All blocking factors for sprint stories/tasks are resolved.
//* Критерії прийняття чітко описані та зрозумілі з точки зору розробки та тестування для команди розробників та контролю якості.
* Acceptance criteria are clearly described and understood from a development and testing perspective for the development and quality control teams.
//* Назва історії/завдання може містити певний префікс для позначення конкретного завдання/історії: [SPIKE], [POC], [DESIGN].
* Story/task name may contain specific prefixes for designation: [SPIKE], [POC], [DESIGN].
//* Кожна історія/задача -- це тестована функціональна одиниця, і тестувальник розуміє, як вона повинна бути перевірена, і що слід зробити перед цим (налаштування цільового середовища, підготовка тестових даних і т.д.).
* Each user story/task is a tested functional unit, and the tester understands how to verify it and what to do before (setting up the test environment, preparing test data, etc.).
//* Історія/задача знаходиться в статусі "Готова до розробки".
* User story/task is in the "Ready for Development" status.
//* Усі підзадачі детально визначені (один-два дні для розробки кожної) й призначені виконавцям.
* All sub-tasks are well-defined (one or two days of development for each) and assigned to executors.
//* Усі підзадачі повинні мати один з префіксів, залежно від спеціалізації: [UX], [BA], [BE], [FE], [DB], [DEVOPS], [QA], [TW], [AUTO].
* Each sub-task should have one of the following prefixes based on specialization: [UX], [BA], [BE], [FE], [DB], [DEVOPS], [QA], [TW], [AUTO].
//* Для історій/задач з моделюванням даних -- в описі має бути посилання на сторінку в Knowledge Base з затвердженою моделлю даних.
* For data modeling user stories/tasks, a link to the Knowledge Base page with approved data models should be provided.
//* Для історій/задач з моделюванням бізнес-процесів -- має бути доступним посилання на сторінку в Knowledge Base, яка містить наступну інформацію:
* For business process modeling user stories/tasks, a link to the Knowledge Base page should be available, containing the following information:
+
//** Опис точок інтеграції.
//** Опис полів форми.
//** Опис потоку користувачів.
//** Макети UX/UI.
** Integration point description.
** Form field description.
** User flow description.
** UX/UI layouts.

//===== Артефакт DoD
===== Definition of Done (DoD) artifact

//Означення виконаної роботи (Definition of Done) -- це встановлені умови, при виконанні яких задача або користувацька історія можуть бути визнані виконаними ("Done").
//Ці критерії розробляються для користувацької історії, аби команда розробників мала чітке уявлення про очікуваний результат роботи.
Definition of Done (DoD) is a set of conditions under which a task or user story can be considered completed ("Done").
These criteria are developed for user stories to provide the development team with a clear understanding of the expected outcome of the work.

//*Критерії успішності:*
*Success Criteria*:

//. Розробка завершена:
. Development completed:
+
//* проведено перевірку коду відповідно до внутрішніх стандартів;
* Code review conducted according to internal standards;
//* код успішно застосовано (merged) до Master-гілки;
* Code successfully applied (merged) to the Master branch;
//* проведено статичний аналіз коду та його розгортання (критичні проблеми відсутні -- покриття Unit-тестами > 80%);
* Static code analysis and deployment completed (no critical issues – Unit test coverage > 80%);
//* функціональність відтестована у середовищі "UAT-Integration";
* Functionality tested in the "UAT-Integration" environment;
//* проведено автоматичне сканування безпеки з допомогою SAST, SCA та DAST-сканерів.
* Automated security scanning performed using SAST, SCA, and DAST scanners.
+
//. Успішно пройдено тестування розробки в середовищі "UAT-Integration".
. Successful development testing in the "UAT-Integration" environment.
//. Успішно пройдено ручне тестування.
. Successful manual testing.
//. Розроблено автотести, які передано на CI/CD (досягнуто всіх критеріїв приймання).
. Automated tests developed and passed on to CI/CD (meeting all acceptance criteria).
//. Зареєстровано час виконання історій/задач в Jira.
. Execution time of user stories/tasks recorded in Jira.
//. Результат історії/задачі можна продемонструвати Замовнику в середовищі UAT.
. Outcome of story/task can be demonstrated to the Client in the UAT environment.
//. Статус історії/задачі в Jira встановлено як "Закрито".
. Status of user story/task set to "Closed" in Jira.
//. У разі виявлення дефектів, створено, відсортовано, призначено та заплановано усі виявлені дефекти.
. In case of defects identified, all detected defects created, sorted, assigned, and planned.

//==== Підходи до управління релізом ІС
==== Approaches to Information System (IS) release management

//Як підхід управління релізом системи використовується семантичне версіонування Платформи та компонентів Платформи.
Semantic versioning of the Platform and Platform components is used as the approach to system release management.

//Загальний підхід використовує три основні типи релізу:
The general approach includes three main release types:

//* *MAJOR*, основна версія -- включає несумісні зміни API.
* *MAJOR* -- major version, including incompatible API changes.
//* *MINOR*, мінорна версія -- включає додавання функціональних можливостей зворотно сумісним способом.
* *MINOR* -- minor version, including backward-compatible functional additions.
//* Версія *PATCH* або *HOTFIX* -- включає виправлення помилок із можливістю зворотної сумісності.
* *PATCH* or *HOTFIX* -- version including error fixes with backward compatibility.

//Релізи Платформи та компонентів Платформи є незалежними.
Platform and Platform component releases are independent.

//===== Спринти та нумерація релізів
===== Sprint and Release numbering

//Тривалість спринту складає два тижні.
Sprint duration is two weeks.

//Шаблон нумерації релізів Платформи та компонентів Платформи на цей час є наступним: `1.X.X`,
//де `X` -- розширення функціональності, версія релізу.
//Наприклад, наприклад, `1.9.5`.
The release numbering template for the Platform and Platform components is currently as follows: `1.X.X`, where `X` represents the functionality extension, release version. For example, `1.9.5`.

//Після кожного релізу новий Jenkins-pipeline створюється із назвою release-`1-X-X` за допомогою *EDP Admin Console*.
After each release, a new Jenkins pipeline is created with the name release-`1-X-X` using the *EDP Admin Console*.

//== Контроль якості коду (code quality)
== Code quality control

//Для забезпечення високої якості коду при розробці програмного забезпечення використовуються спеціалізовані методики та інструменти, відомі як контроль якості коду (*Code Quality*).
Specialized methodologies and tools known as Code quality control are used to ensure high-quality code during software development.

//=== Статичний аналіз коду
=== Static code analysis

//Основним методом, який використовують розробники, є _статичний аналіз коду_.
The primary method utilized by developers is _static code analysis_.

//Статичний аналіз коду -- це методика аналізу програмного забезпечення, який проводиться без фактичного виконання програми. Під аналіз піддається початковий код, який тестується за допомогою спеціального програмного забезпечення.
Static code analysis is a software analysis methodology performed without actual program execution. The initial code is subjected to testing using specialized software.

//Наступні інструменти використовуються для проведення статичного аналізу коду:
The following tools are employed for conducting static code analysis:

//* *IntelliJ IDEA* -- це інтегроване середовище розробки. Воно аналізує код у відкритих файлах і виділяє проблемні ділянки в процесі введення. Також IntelliJ IDEA дозволяє вручну запустити перевірку або набір перевірок на вибраному обсязі файлів, надаючи можливість отримати детальний звіт про всі проблеми, виявлені в коді.
* *IntelliJ IDEA* -- an integrated development environment that analyzes code in open files, highlighting problematic areas during input. IntelliJ IDEA also allows manual initiation of checks or a set of checks on a selected set of files, providing a detailed report on all issues found in the code.

//* *SonarQube* -- це платформа з відкритим кодом, розроблена для постійного аналізу і перевірки якості коду, що дозволяє виявляти помилки та вразливості безпеки за допомогою статичного аналізу коду. Інструмент використовується на етапах Jenkins pipelines при створенні запиту на злиття змін до master-гілки, а також під час злиття гілки розробника до master-гілки.
* *SonarQube* -- an open-source platform designed for continuous analysis and code quality checking, detecting errors and security vulnerabilities through static code analysis. The tool is used in Jenkins pipelines when creating pull requests for changes to the master branch, as well as during the merging of a developer's branch into the master branch.

//* *Semgrep* -- це аналізатор статичного коду, який дозволяє виявляти потенційні помилки та вразливості в програмах Java.
* *Semgrep* -- a static code analyzer that identifies potential errors and vulnerabilities in Java programs.

//* *Yelp Detect-secrets* -- це аналізатор коду, що допомагає виявляти секрети, що були випадково збережені в коді.
* *Yelp Detect-secrets* -- a code analyzer that helps detect inadvertently stored secrets in the code.

//* *Checkmarx KICS (Keeping Infrastructure as Code Secure)* -- це рішення з відкритим кодом для статичного аналізу інфраструктури, описаної кодом.
* *Checkmarx KICS (Keeping Infrastructure as Code Secure)* -- an open-source solution for static analysis of infrastructure described in code.

//* *Trivy* -- це статичний сканер Docker-образів, що виявляє вразливості та помилки конфігурації.
* *Trivy* -- a static scanner for Docker images that detects vulnerabilities and configuration errors.

//=== Покриття коду тестами (Code coverage)
=== Code coverage testing

//Розробники використовують метод аналізу покриття коду тестами.
//Покриття тестами за метриками інструментів аналізу *code coverage* має бути _більшим за 80%_.
Developers employ *code coverage* testing to ensure high-quality code. *Code coverage* metrics from analysis tools should exceed 80%.

//Для перевірки покриття коду тестами використовуються наступні інструменти:
The following tools are used to check code coverage through testing:

//* *IntelliJ IDEA* -- інтегроване середовище розробки ПЗ.
* *IntelliJ IDEA* -- an integrated development environment for software.
+
//Покриття коду в IntelliJ IDEA дозволяє бачити, наскільки ваш код був виконаний. Інструмент також дозволяє перевірити, наскільки ваш код охоплюється модульними тестами, щоб ви могли оцінити, наскільки ефективні ці тести.
Code coverage in IntelliJ IDEA allows you to see how your code has been executed. The tool also allows you to assess how well your code is covered by unit tests, enabling you to evaluate their effectiveness.
+
//IntelliJ IDEA застосовує декілька локальних плагінів для цих потреб, наприклад, EMMA, JaCoCo тощо.
IntelliJ IDEA applies several local plugins for these purposes, such as EMMA, JaCoCo, and others.

//* *SonarQube* -- платформа з відкритим кодом, розроблена для постійного аналізу (continuous inspection) та перевірки якості коду для автоматичного огляду зі статичним аналізом коду для виявлення помилок, та вразливостей безпеки.
* *SonarQube* -- an open-source platform designed for continuous inspection and code quality checking, offering automated code review with static code analysis for error and security vulnerability detection.

//=== Модульне тестування (Unit Testing)
=== Unit testing

//Для забезпечення високої якості та "чистоти" написаного розробниками коду, використовується метод модульного тестування.
//Покриття коду модульними тестами має бути _більшим за 80%_.
To ensure high quality and "cleanliness" of code written by developers, the method of *unit testing* is used. Code coverage by unit tests should exceed 80%.

//Модульне тестування (англ. -- _Unit Testing_) -- це метод тестування програмного забезпечення, який полягає в окремому тестуванні кожного модуля коду програми. Модулем називають найменшу частину програми, яка може бути протестованою. У процедурному програмуванні модулем вважають окрему функцію або процедуру.
_Unit testing_ is a software testing method that involves testing each module of a program's code individually. A module refers to the smallest part of the program that can be tested. In procedural programming, a module can refer to an individual function or procedure.

//Тобто, при проєктуванні та розробці використовується підхід декомпозиції частин ІС на окремі модулі, кожен з яких окремо підлягає поглибленому тестуванню.
In the design and development process, the approach of decomposing parts of the information system into separate modules is employed, each of which is thoroughly tested.

//Для виконання модульного тестування, розробники використовують наступні інструменти:
For conducting unit testing, developers use the following tools:

* JUnit;
* AssertJ;
* Wiremock;
* MockMvc;
* Spring-boot-test.

//TIP: Стандарти та рекомендації щодо проведення розробниками модульного тестування при розробці цієї інформаційної системи описані у розділі xref:#unit-testing-standards[] поточного документа.
TIP: Standards and recommendations for conducting unit testing by developers in the development of this information system are described in xref:#unit-testing-standards[] section of this document.

//=== Покриття автоматизованими тестами
=== Automated testing coverage

//_Автоматизоване тестування програмного забезпечення_ -- частина процесу тестування на етапі контролю якості в процесі розробки програмного забезпечення. Воно використовує програмні засоби для виконання тестів і перевірки результатів виконання, що допомагає скоротити час тестування і спростити його процес.
_Automated software testing_ is a part of the quality control process in software development. It utilizes software tools to execute tests and verify execution results, helping to reduce testing time and simplify the process.

//Для проведення належних процедур з автоматизованого тестування, використовується набір професійних засобів/інструментів.
To carry out proper automated testing procedures, a set of professional tools/instruments is used.

//==== Інструменти тестування Платформи
==== Platform testing tools

//Перелік інструментів, які залучені для тестування Платформи, наведений у таблиці "Інструменти тестування Платформи" (_див. нижче_).
The list of tools involved in Platform testing is provided in the "Platform testing tools" table (_see below_).

//Визначено декілька категорій інструментів:
Several categories of tools are identified:

//* _Інструменти збереження та обміну інформації_ -- інструменти, призначені для збереження та створення проєктної документації, та служать єдиним місцем входу до проєкту.
* _Information Storage and Exchange Tools_ -- tools intended for storing and creating project documentation, serving as a single entry point to the project.
//* _Інструменти тестування_ -- інструменти, що використані під час ручного та автоматизованого тестування.
* _Testing Tools_ -- tools used during manual and automated testing.
//* _Інструменти моніторингу_ -- інструменти, що використовуються для моніторингу стану платформи та відображення його на налаштованих попередньо моніторах.
* _Monitoring Tools_ -- tools used for monitoring the platform's status and displaying it on configured monitors.

//.Інструменти тестування Платформи
.Platform testing tools
[width="100%",cols="45%,55%",options="header",]
|===
//|*Категорія* |*Назва інструменту*
|*Category* |*Tool name*
//|*Інструменти збереження та обміну інформації* |
|*Information storage and exchange tools* |
//|Система збереження вимог |JIRA, Confluence
|Requirement management system |JIRA, Confluence
//|Система збереження тест-кейсів |JIRA Plugins
|Test case management system |JIRA Plugins
//|Система збереження дефектів |JIRA
|Defect management system |JIRA
|*Інструменти тестування* |
|*Testing tools* |
//|API-контракти |SoapUi, RestAssured, Postman
|API Contracts |SoapUi, RestAssured, Postman
//|SOAP-контракти |SoapUI,JAX-WS
|SOAP Contracts |SoapUI,JAX-WS
//|Web-додатків |Selenium WebDriver, Cucumber або похідні
|Web applications |Selenium WebDriver, Cucumber або похідні
//|Desktop-систем (Camunda) |TBD
|Desktop system (Camunda) |TBD
//|Тестування даних |WireMock (маскування даних)
|Data testing |WireMock (data masking)
//|Інтеграція з Трембітою |SoapUi
|Integration with Trembita (UA-specific) |SoapUi
//|Тестування навантаження |Gatling
|Load testing |Gatling
//|Тестування безпеки a|
|Security testing a|
* owasp zap -- DAST

* trivy -- continer security/SCA

* secrets scanner -- detect-secrets from yelp

* Iaac security -- kics from checkmarx

* semgrep from owasp -- SAST

//|Тестування доступності вебконтенту |Wave (Web Accessibility Evaluation Tool)
|Web content accessibility testing |Wave (Web Accessibility Evaluation Tool)
//|*Інструменти моніторингу* |
|*Monitoring tools* |
//|Система моніторингу |Prometheus
|Monitoring system |Prometheus
//|Система візуалізації даних |Grafana
|Data visualization system |Grafana
|===

//TIP: Загальний обсяг функціонального та нефункціонального тестування, а також методологія (стратегія) тестування інформаційної системи детально описані у розділі xref:testing:functional-testing/functional-testing.adoc[]
TIP: The overall scope of functional and non-functional testing, as well as the testing methodology (strategy) of the information system, is detailed in the xref:testing:functional-testing/functional-testing.adoc[] section.

//=== Перевірка вихідного коду (Code review)
=== Source code review (Code review)

//*Code Review* -- це систематичний процес перевірки вихідного коду програми, який використовується під час розробки інформаційної системи. Цей процес спрямований не лише на виявлення помилок, але також слугує важливим етапом розробки програмного забезпечення, що сприяє покращенню якості коду.
*Code Review* is a systematic process of examining program source code used during the development of the information system. This process is aimed not only at error detection but also serves as a crucial stage in software development, enhancing code quality.

//==== Процес огляду коду в контексті розробки інформаційної системи
==== Code review process in the context of information system development

//* При розгортанні компонентів інформаційної системи застосовується *GitOps*-підхід, заснований на процесах *CI/CD*. Однією з ключових особливостей цього підходу, включаючи аспект безпеки, є те, що _Git служить єдиною точкою входу_ для внесення будь-яких змін до системи.
* During the deployment of information system components, a *GitOps* approach is employed, based on *CI/CD* processes. One of the key features of this approach, including security aspects, is that _Git serves as the sole entry point_ for making any changes to the system.

//* Розробник спочатку вносить зміни до своєї власної гілки захищеного віддаленого VCS-репозиторію, виконуючи команди `git commit` і `git push`.
* A developer initially makes changes to their own protected remote VCS repository branch, using the `git commit` and `git push` commands.

//* Наступним кроком є створення запита на злиття змін із гілки розробника до `master`-гілки репозиторію -- це називається *Merge Request* або *MR*.
* The next step involves creating a *Merge Request* (*MR*) to merge changes from the developer's branch into the `master` branch of the repository.

//* Після цього члени команди розробників проводять огляд коду, що є колективним процесом. Його метою є перевірка написаного коду з метою виявлення помилок та надання пропозицій щодо його виправлення або покращення.
* Subsequently, members of the development team conduct code reviews, which is a collective process. Its purpose is to review the written code to identify errors and provide suggestions for correction or improvement.

//* Для злиття коду до `master`-гілки потрібно отримати принаймні одне підтвердження від головного розробника команди.
* To merge code into the `master` branch, at least one approval from the lead developer of the team is required.

//* Злиття змін, що були обговорені в рамках створеного Merge Request, здійснює уповноважена особа з відповідними правами доступу.
* The merging of changes discussed within the created Merge Request is carried out by an authorized person with appropriate access rights.

//==== Рефакторинг коду (Code refactoring)
==== Code refactoring

//Для покращення якості та оптимізації коду використовується стандартна методика -- *Code refactoring*.
Standard methodology, *Code refactoring*, is employed to improve code quality and optimization.

//*Code refactoring*, як правило, проводиться у двох випадках:
*Code refactoring* is typically conducted in two scenarios:

//* рефакторинг коду в рамках code review для виправлення критичних помилок та покращення роботи застосунків;
* Code refactoring within a code review to address critical errors and improve application functionality.
//* рефакторинг коду як частина оптимізації системи (некритичні задачі).
* Code refactoring as part of system optimization (non-critical tasks).

//Оптимізація вихідного коду визначається, але не обмежується наступними критеріями:
Optimization of source code is determined by, but not limited to, the following criteria:

//* найменування (naming);
* Naming;
//* "чистота коду" ("Clean code");
* Clean code principles;
//* оптимізація продуктивності (performance optimization): ОЗУ, ЦП, кількість запитів за секунду тощо;
* Performance optimization: RAM, CPU, queries per second, etc.;
//* оптимізація коду;
* Code optimization;
//* Спрощення API-контрактів.
* Simplification of API contracts.


//== Контроль за виконанням нефункціональних вимог
== Monitoring non-functional requirements compliance

//Розробка Платформи провадиться із дотриманням наступних принципів (_нефункціональних вимог_):
The development of the Platform adheres to the following principles (_non-functional requirements_):

//* ефективність роботи (Performance efficiency);
* Performance efficiency;
//* безпека (Security);
* Security;
//* надійність (Reliability);
* Reliability;
//* переносимість (Portability);
* Portability;
//* працездатність (Operability);
* Operability;
//* змінність (Modifiability);
* Modifiability;
//* здатність до контролю/перевіреність (Verifiability);
* Verifiability;
//* інтеграційна взаємодія (Interoperability).
* Interoperability.