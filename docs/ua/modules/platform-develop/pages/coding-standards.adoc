:toc-title: ЗМІСТ
:toc: auto
:toclevels: 5
:experimental:
:important-caption:     ВАЖЛИВО
:note-caption:          ПРИМІТКА
:tip-caption:           ПІДКАЗКА
:warning-caption:       ПОПЕРЕДЖЕННЯ
:caution-caption:       УВАГА
:example-caption:           Приклад
:figure-caption:            Зображення
:table-caption:             Таблиця
:appendix-caption:          Додаток
:sectnums:
:sectnumlevels: 5
:sectanchors:
:sectlinks:
:partnums:

= Опис систем класифікації та кодування

== Підходи та стандарти розробки програмного забезпечення

=== Підходи та методи розробки програмного забезпечення

При розробці компонентів інформаційної системи було впроваджено наступні методи та підходи:

* об’єктно-орієнтований підхід до розробки програмного забезпечення;
* віртуалізація на базі контейнерів;
* автоматизація розгортання з використанням GitOps-підходу;
* документація як код;
* уніфікація та стандартизація програмних компонентів;
* декомпозиція підсистем на модулі;
* оцінка ризиків та моделювання загроз безпеки;
* функціональне та нефункціональне тестування.

=== Стандарти кодування

==== Стандарти та рекомендації дизайну

* Дотримуватися філософії «Zen of Python» («Дзен Пайтона»):
** Гарне краще за потворне.
** Явне краще за неявне.
** Просте краще за складне.
** Складне краще за заплутане.
** Плоске краще за вкладене.
** Розріджене краще за щільне.
** Легкість читання має значення.
** Особливі випадки не є настільки особливими, щоб порушувати правила.
** Хоча практичність є важливішою за бездоганність.
** Помилки ніколи не повинні проходити непомітно.
** Якщо їх приховування не прописано явно.
** Зустрівши неоднозначність, опирайтесь спокусі вгадати.
** Має бути один і, бажано, _тільки_ один очевидний спосіб зробити це.
** Хоча спочатку він може бути й не очевидним, якщо ви не голландець.
** Зараз краще, ніж ніколи.
** Хоча ніколи, найчастіше,— краще, ніж _просто_ зараз.
** Якщо реалізацію важко пояснити— задум поганий.
** Якщо реалізацію легко пояснити— _можливо_, задум добрий.
** Простори імен -- чудова річ, тож робімо їх більше!

* «Fail fast» найчастіше найкраща опція (_деталі – за посиланням: https://en.wikipedia.org/wiki/Fail-fast_).
* «Return early» для валідації вхідних параметрів.
* Правило бойскаута: «Ми лишаємо код в кращому стані ніж він був».
* Не використовувати _break, continue, return_ в складних конструкціях.
* Завжди використовувати фігурні дужки в циклах та умовах (conditions).
* Уникати написання методів, де більше чотирьох вхідних параметрів.
* Уникати написання методів, де модифікується вхідний параметр.
* Логування об’єктів має відбуватись без трансформацій об’єктів з огляду на NPE.

==== Стандарти стилістики коду (Code Style)

* Табуляція: чотири пробіли.
* Статичні імпорти можуть використовуватись тільки у випадках роботи з DSL.
* Імпорти *«*»* мають бути трансформовані в специфічні імпорти.
* Новими рядками слід виділяти тільки групи логічно пов’язаних полів, а не кожне поле окремо.
* Спочатку визначаються поля класу, а потім поля об’єкта.
* Імена змінним слід давати згідно змісту змінної, а не її типу (`StringBuilder stringbuilder = new StringBuilder()` – погано, `StringBuilder fields = new StringBuilder()` – добре).
* Необхідно надавати перевагу назвам класів, які починаються з доменного значення. Наприклад: `UserService`, `UserKafkaService` (технологічна складова може йти посередині).

==== Стандарти роботи з Git

* В репозиторії не має бути специфічних даних (локальні шляхи, специфічні для програміста налаштування (properties)).
* Git-повідомлення:
** Спочатку має бути номер Jira в квадратних дужках.
** Повідомлення має відповідати на питання: «що цей commit зробив?».
** Якщо опис commit має бути довгим, то необхідно помістити на першому рядку короткий опис, а з нового рядка – додати детальне повідомлення (git вміє з цим працювати).
** Крапку в кінці не ставимо.

==== Вимоги до роботи з POM

* Використовувати parent _pom.xml_ для:
** зазначення версії залежності;
** управління плагінами;
* При виносі версії бібліотеки до налаштувань (.properties), необхідно додати суфікс «.`version`». Наприклад, `<querydsl.version>`...`</querydsl.version>`.

==== Стандарти модульного тестування

* Використовувати шаблон/підхід _ААА (ArrangeActAssert)_.
* Не треба коментарів (_given, when, then_), відділення порожнім рядком є достатнім.
* Використовувати анотацію @DisplayName в JUnit 5 для надання більшої інформації.
* Варто уникати «throws Exception» в декларації тестів.
* Не використовувати _PowerMock._
* Для mock-об’єктів варто додавати відповідний префікс «mock». Наприклад, mockRepository.
* Уникати беззмістовних повідомлень в asserts. Наприклад, `Assertions.assertNotNull(object, Shouldn't be null`);

==== Вимога тримати код «чистим»

При кодуванні використовується підхід «Clean Code» («чистий код»), тобто хороший, якісно написаний код програми.

«Хорошим» вважається код, що відповідає наступним критеріям:

* відповідає вимогам (виконує тести);
* виражає всі ідеї дизайну, які в нього вклали;
* не містить дублювання;
* мінімізує кількість компонентів.

==== Використання метрик SQALE для оцінки та управління технічним боргом

В розробці програмного забезпечення, як тільки з'являються зміни в програмному коді, часто з'являється необхідність вносити пов'язані з ними зміни до інших частин коду або документації. Це поняття іменується *«технічним боргом»*. Також під «технічним боргом» маються на увазі інші необхідні, але незавершені зміни, що враховуються боргом, який може виникнути та повинен бути погашеним у визначений момент у майбутньому.

Для оцінки масштабів та управління технічним боргом, використовується методологія *SQALE*.

== МЕТОДОЛОГІЇ РОЗРОБКИ ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ

Розробка інформаційної системи провадилась із використанням методології *Agile software development*.

Гнучка розробка програмного забезпечення (англ. _Agile software development, agile-методи_)– клас методологій розробки програмного забезпечення, що базується на ітеративній розробці, в якій вимоги та розв'язки еволюціонують через співпрацю між багатофункціональними командами здатними до самоорганізації.


=== Структура видачі ІС (Delivery)

==== Команди розробки

* Управління (Management)
* Команда Платформи (Platform Team)
** Три скрам команди та Сервіс команда платформи
* Команда Архітекторів (SA Team)
* Центр компетенций та команда реєстрів (Competence center and Register Team)
* Сервіс менеджмент тім (Service Management Team)

==== Реалізація Agile-методології

Основним підходом при використанні методології Agile є *Scrum*.

*Скрам* (англ. _Scrum_)— підхід управління проєктами для гнучкої розробки програмного забезпечення. Скрам чітко робить акцент на якісному контролі процесу розробки.

Програмна платформа для управління державними електронними реєстрами є великим та технічно складним продуктом, що потребує концентрації значних зусиль декількох команд розробників, менеджерів та аналітиків, а тому основним підходом при роботі зі Scrum-фреймворком вибрано *LeSS*. LeSS – це Скрам, що застосовується до багатьох команд, що працюють спільно над одним великим продуктом.

Тривалість *спринту* для при такому підході становить *два тижні*.

*Скрам-мастером* виступає особа із команди менеджерів. За замовчуванням, функції скрам-мастера на проєкті виконує *Delivery Manager*.

Оцінка зусиль, необхідних для виконання пріоритетного завдання, вимірюється в одиницях *https://www.mountaingoatsoftware.com/blog/what-are-story-points[story points]* виконавцем задачі. За кожним завданням закріплюється задача (що, як правило, ділиться на окремі менші частини), яка розміщується в Jira backlog (*backlog* — це документ, який має список вимог до функціональності, які упорядковані згідно зі ступенем важливості. Product backlog представляє список того, що повинно бути реалізовано. Елементи цього списку називаються «історіями» (_user story_) або елементами backlog-у (_backlog items_). Product backlog відкритий для редагування усім учасникам Scrum-процесу) та керується командою менеджменту, рівномірно призначаючись розробникам різних команд.

Процес планування виконується командою менеджменту спільно із провідними розробниками своїх напрямів (часто – із залученням усіх членів команди розробників) за допомогою https://uk.wikipedia.org/wiki/Покер_планування[покеру планування або Скрам-покеру] (*Planning poker*), який є консенсусним, ігровимметодом для оцінки складності виконання задачі в розробці програмного забезпечення. Оцінка термінів виконання завдань здійснюється, виходячи з песимістичних очікувань, що дає запас часу на виконання задачі та певну варіативність, у випадку ускладнень.

При роботі зі Scrum, також впроваджено підхід управління залежностями (*Dependency management*) – це процес активного аналізу, вимірювання та роботи з метою мінімізації зривів/невдач, спричинених внутрішньокомандною та/або міжкомандною залежністю.

==== Інструменти співпраці між командами

. Система управління задачами (Ticket management system) Jira.
. База знань для формування документації (Knowledge base) Confluence.

====  Використання артефактів Scrum

===== Артефакт DoR

*Definition of Ready (DoR)* – у фреймворку Scrum – критерій готовності задачі (User Story – користувацька історія) до взяття в роботу. Це умови, при яких User Story можна брати в роботу та включати до спринту. Команді важливо бачити чіткі DoR для елементів беклогу.

*Критерії готовності:*

* історія та задача для беклогу спринту визначені та оцінені верхньорівнево;
* технічні пріоритети визначені (на основі залежностей або технічних можливостей);
* історія/задача містить: детальний опис, критерії приймання (формат списку), нефункціональні вимоги, ризики;
* керівники/архітектори розуміють, що і як слід робити, і мають (якщо такі є) запитання для роз’яснення;
* історія/задача в одному зі статусів «В аналізі», «Відкрито», «Заблоковано»;
* історія/задача має посилання на відповідне завдання EPIC;
* історія/задача закріплена за відповідальною за її вирішення командою: Low-code/Data/Infrastructure/BA/Management/Cross-cut;
* історія/задача має зазначену фазу розробки проєкту;
* історія/задача є незалежною;
* історія/задача затверджена та пріоритезована Замовником на основі заявлених вимог, під час сесії грумінгу (grooming session);
* усі блокувальники для історій/задач спринту вирішені;
* критерії приймання чітко прописані та зрозумілі з точки зору розробки та тестування (для команди розробників та контролю якості);
* назва історії/завдання може містити певний префікс для відображення конкретного завдання/історії: [SPIKE], [POC], [DESIGN];
* кожна історія/задача – це тестована функціональна одиниця, і тестувальник розуміє, як необхідно перевіряти функціональність, і що слід зробити перед цим (налаштування цільового середовища, підготовка тестових даних тощо);
* історія/задача знаходиться у статусі «Готова до розробки»;
* усі підзадачі мають хорошу деталізацію (один-два дні для розробки кожної) і призначаються виконавцям;
* усі підзадачі повинні мати один із таких префіксів, залежно від спеціалізації: [UX], [BA], [BE], [FE], [DB], [DEVOPS], [QA], [TW], [AUTO];
* для історій/задач із моделюванням даних – в описі має бути посилання на сторінку в Knowledge Base до затвердженої моделі даних;
* для історій/задач з моделювання бізнес-процесів – має бути доступне посилання на сторінку в Knowledge Base з наступною інформацією:

** опис точок інтеграції;
** опис полів форми;
** опис потоку користувачів;
** макети UX/UI.

===== Артефакт DoD

Definition of Done -- це умови для задачі або користувальницької історії, дотримання яких дозволяє вважати реалізацію успішною («Done»). Такі умови пишуть для User Story, щоб команда розробки краще розуміла, яким повинен бути підсумковий результат виконання задачі.

*Критерії успішності:*

. розробка завершена:

* перевірка коду пройшла (дотримуються внутрішні стандарти коду)
* код злито до Master-гілки;
* статичний аналіз коду та розгортання пройдено (критичні проблеми не знайдено; покриття Unit-тестами > 80%);
* функціональність перевірена в середовищі «UAT-Integration»;
* перевірка безпеки автоматичними SAST, SCA та DAST сканерами пройдена;

[start=2]
. тест розробки пройдено в середовищі «UAT-Integration»;
. ручне тестування пройдено;
. автотести розроблені та передані на CI/CD (досягнуто всіх критеріїв приймання)
. час на виконання історій/задач відмічений в Jira
. результат історії/задачі можна продемонструвати Замовнику в середовищі UAT;
. статус історії/задачі в Jira позначений як «Закрито»;
. у разі виявлення дефектів – усі дефекти створюються, сортуються, призначаються, плануються.

==== Підходи до управління релізом ІС

В якості підходу управління релізом ІС використовується семантичне версіонування Платформи та компонентів Платформи.

Загальнис підхід використовує три основні типи релізу:

* *MAJOR* – основна версія – включає несумісні зміни API.
* *MINOR* – мінорна версія – включає додавання функціональних можливостей зворотньо сумісним способом.
* Версія *PATCH* або *HOTFIX* – включає виправлення помилок із можливістю зворотньої сумісності.

Релізи Платформи та компонентів Платформи є незалежними.

===== Спринти та нумерація релізів

Тривалість спринту складає два тижні.

Шаблон нумерації релізів Платформи та компонентів Платформи на цей час є наступним: 1.X.0, де X – розширення функціональності (мінорні зміни до Платформи).

Після кожного релізу новий Jenkins-pipeline створюється із назвою release-1-X-0 за допомогою EDP Admin Console.

== КОНТРОЛЬ ЯКОСТІ РОЗРОБКИ (CODE QUALITY)

Для забезпечення загальної якості написаного коду при розробці програмного забезпечення використовуються методики та інструменти контролю якості розробки, що іменуються Code Quality.

=== Cтатичний аналіз коду

Розробниками використовується *метод статичного аналізу коду*.

Статичний аналіз коду (англ. _static code analysis_) — аналіз програмного забезпечення, який здійснюють без реального виконання програм, що досліджуються. Аналізу піддають початковий код, що тестується спеціальним програмним забезпеченням (ПЗ).

Для перевірки якості коду цим методом використовуються наступні інструменти:

* *IntelliJ IDEA* - інтегроване середовище розробки ПЗ.

IntelliJ IDEA аналізує код у файлах, відкритих у редакторі, і виділяє проблемний код під час введення. Крім того, інструмент дозволяє вручну запустити необхідну перевірку або набір перевірок щодо вибраного обсягу файлів. У цьому випадку є можливість отримати вичерпний звіт про всі проблеми, виявлені у файлах із вихідним кодом.

* *SonarQube* –платформа з відкритим кодом, розроблена для постійного аналізу (continuous inspection) та перевірки якості коду для автоматичного огляду зі статичним аналізом коду для виявлення помилок, та вразливостей безпеки.

____
Інструмент використовується в кроках (steps) Jenkins pipelines при створенні запиту на злиття змін, внесених розробником, до master-гілки системи контролю версій, а також при злитті самої гілки розробника до master-гілки (сам процес Merge).
____

* *Semgrep* - це аналізатор статичного коду, який виявляє можливі помилки та вразливості в програмах Java.
* *Yelp Detect-secrets* - аналізатор коду що дозволяє виявляти секрети які були збережені в коді.
* *Сheckmarx kics (keeping infrastructure as code secure)* - рішення з відкритим кодом для статичного аналізу інфраструктури як коду.
* *Trivy –* статичний сканер Doker образів для виявлення вразливостей та помилок конфігурації

=== Покриття коду тестами (Code coverage)

Розробниками використовується *метод аналізу покриття коду тестами.* Покриття тестами за метриками інструментів аналізу code coverage має бути не менш як 80%.

Для перевірки покриття коду тестами використовуються наступні інструменти:

* *IntelliJ IDEA* - інтегроване середовище розробки ПЗ.

Покриття коду в IntelliJ IDEA дозволяє бачити, наскільки ваш код був виконаний. Інструмент також дозволяє перевірити, наскільки ваш код охоплюється модульними тестами, щоб ви могли оцінити, наскільки ефективні ці тести.

IntelliJ IDEA застосовує декілька локальних плагінів для цих потреб (наприклад, EMMA, JaCoCo тощо).

* *SonarQube* –платформа з відкритим кодом, розроблена для постійного аналізу (continuous inspection) та перевірки якості коду для автоматичного огляду зі статичним аналізом коду для виявлення помилок, та вразливостей безпеки.


=== Модульне тестування (Unit Testing)

Для забезепечення високої якості та «чистоти» написаного розробниками коду, використовується метод модульного тестування. Покриття коду модульними тестами має бути не меншим як 80%.

Модульне тестування (англ. – _Unit Testing_) — це метод тестування програмного забезпечення, який полягає в окремому тестуванні кожного модуля коду програми. Модулем називають найменшу частину програми, яка може бути протестованою. У процедурному програмуванні модулем вважають окрему функцію або процедуру.

Тобто, при проєктуванні та розробці використовується підхід декомпозиції частин ІС на окремі модулі, кожен з яких окремо підлягає поглибленому тестуванню.

Для виконання модульного тестування, розробники використовують наступні інструменти:

* JUnit;
* AssertJ;
* Wiremock;
* MockMvc;
* Spring-boot-test.

_Стандарти та рекомендації щодо проведення розробниками модульного тестування при розробці цієї інформаційної системи описані в *підрозділі 1.2.5 «Стандарти модульного тестування»* поточного документа._

=== Покриття автоматизованими тестами

*Автоматизоване тестування програмного забезпечення*– частина процесу тестування на етапі контролю якості в процесі розробки програмного забезпечення. Воно використовує програмні засоби для виконання тестів і перевірки результатів виконання, що допомагає скоротити час тестування і спростити його процес.

Для проведення належних процедур з автоматизованого тестування, використовується набір професійних засобів/інструментів.

==== Інструменти тестування Платформи

Перелік інструментів, що задіяні для тестування Платформи, наведений у таблиці «Інструменти тестування Платформи».

Визначено декілька категорій інструментів:

* _Інструменти збереження та обміну інформації -_ інструменти, призначені для збереження та створення проєктної документації, та служать єдиним місцем входу до проєкту.
* _Інструменти тестування -_ інструменти, що використані під час ручного та автоматизованого тестування.
* _Інструменти моніторингу -_ інструменти, що використовуються для моніторингу стану платформи та відображення його на налаштованих попередньо моніторах.

.Інструменти тестування Платформи
[width="100%",cols="45%,55%",options="header",]
|===
|*Категорія* |*Назва інструменту*
|*Інструменти збереження та обміну інформації* |
|Системазбереження вимог |JIRA, Confluence
|Системазбереження тест-кейсів |JIRA Plugins
|Системазбереження дефектів |JIRA
|*Інструменти тестування* |
|API-контракти |SoapUi, RestAssured, Postman
|SOAP-контракти |SoapUI,JAX-WS
|Web-додатків |Selenium WebDriver, Cucumber або похідні
|Desktop-систем (Camunda) |TBD
|Тестування даних |WireMock (маскування даних)
|Інтеграція з Трембітою |SoapUi
|Тестування навантаження |Gatling
|Тестування безпеки a|
owasp zap - DAST

trivy - continer security/SCA

secrets scanner - detect-secrets from yelp

Iaac security - kics from checkmarx

semgrep from owasp - SAST

|Тестуваннядоступності веб-контенту |Wave (Web Accessibility Evaluation Tool)
|*Інструментимоніторингу* |
|Системамоніторингу |Prometheus
|Система візуалізації даних |Grafana
|===

TIP: Загальний обсяг функціонального та нефункціонального тестування, а також методологія (стратегія) тестування інформаційної системи детально описані у розділі xref:testing:functional-testing/functional-testing.adoc[]

=== Перевірка вихідного коду (Code review)

Однією з методик, що використовується при розробці інформаційної системи, є *Code Review* – систематична перевірка вихідного коду програми, призначений не лише для виявлення помилок, але є й одним з етапів розробки програмного забезпечення для покращення загальної якості програмного коду.

==== Процес перевірки коду в рамках розробки інформаційної системи

* При розгортанні компонентів інформаційної системи, використовується GitOps-підхід на базі процесів CI/CD, визначальною рисою якого (в тому числі і з точки зору безпеки) є те, що Git – єдина точка входу для внесення будь-яких змін до системи.
* Таким чином, розробник вносить зміни спочатку до власної гілки віддаленого захищеного VCS-репозиторію, виконуючи команди git commit та git push.
* Наступним кроком створюється запит на злиття змін власної гілки розробника до master-гілки репозиторію – Merge Request (MR).
* Далі члени команди розробників проводять процедуру code review (це колективний процес), тобто перевіряють написаний код з метою віднайдення помилок та надання зауважень до виправлення або покращення деяких моментів.
* Для злиття коду до master-гілки необхідно отримати хоча б одне підтвердження від провідного розробника (Lead) команди.
* Злиття змін, розглянутих в рамках створеного Merge Request, виконує уповноважена особа з відповідними правами доступу.

==== Рефакторінг коду (Code refactoring)

Для покращення якості та оптимізації коду використовується стандартна *методика code refactoring*.

Code refactoring, як правило, проводиться у двох випадках:

- рефакторінг коду в рамках code review для виправлення критичних помилок та покращення роботи застосунків;

- рефакторінг коду як частина оптимізації системи (некритичні задачі).

Оптимізація вихідного коду визначається, але не обмежується наступними критеріями:

* найменування (naming);
* «Чистота коду» («Clean code»);
* оптимізація продуктивності (performance optimization): ОЗУ, ЦП, кількість запитів за секунду тощо;
* оптимізація коду;
* Спрощення контрактів API.

== Контроль за виконанням нефункціональних вимог

Розробка Платформи провадилась із дотриманням наступних принципів (нефункціональних вимог):

* ефективність роботи (Performance efficiency);
* безпека (Security);
* надійність (Reliability);
* переносимість (Portability);
* працездатність (Operability);
* змінність (Modifiability);
* здатність до контролю/перевіреність (Verifiability);
* інтеграційна взаємодія (Interoperability).