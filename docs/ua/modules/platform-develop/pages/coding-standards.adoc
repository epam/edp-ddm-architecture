:toc-title: ЗМІСТ
:toc: auto
:toclevels: 5
:experimental:
:important-caption:     ВАЖЛИВО
:note-caption:          ПРИМІТКА
:tip-caption:           ПІДКАЗКА
:warning-caption:       ПОПЕРЕДЖЕННЯ
:caution-caption:       УВАГА
:example-caption:           Приклад
:figure-caption:            Зображення
:table-caption:             Таблиця
:appendix-caption:          Додаток
:sectnums:
:sectnumlevels: 5
:sectanchors:
:sectlinks:
:partnums:

= Практики розробки та контролю якості програмного забезпечення

//Approaches, methods, and standards of software development
== Підходи, методики та стандарти розробки програмного забезпечення

=== Підходи та методики розробки

Під час розробки компонентів інформаційної системи впроваджені наступні методики та підходи:

. Використання об'єктно-орієнтованого підходу у розробці програмного забезпечення;
. Впровадження віртуалізації на основі контейнерів;
. Автоматизація розгортання з допомогою GitOps-підходу;
. Організація документації як коду;
. Уніфікація та стандартизація програмних компонентів;
. Декомпозиція підсистем на модулі;
. Оцінка ризиків та моделювання загроз безпеки;
. Виконання функціонального та нефункціонального тестування.

////
Approaches and methods of software development

During the development of the information system components, we implement the following methods and approaches:

* Utilization of an object-oriented approach in software development;
* Implementation of container-based virtualization;
* Deployment automation using the GitOps approach;
* Treating documentation as code;
* Unification and standardization of software components;
* Decomposition of subsystems into modules;
* Risk assessment and security threat modeling;
* Execution of functional and non-functional testing.
////

//Coding standards
=== Стандарти Кодування

==== Стандарти та рекомендації з дизайну

////
. Stick to the "Zen of Python" philosophy:

* Beautiful is better than ugly.
* Explicit is better than implicit.
* Simple is better than complex.
* Complex is better than complicated.
* Flat is better than nested.
* Sparse is better than dense.
* Readability counts.
* Special cases aren't special enough to break the rules.
* Although practicality beats purity.
* Errors should never pass silently.
* Unless explicitly silenced.
* In the face of ambiguity, refuse the temptation to guess.
* There should be one-- and preferably only one --obvious way to do it.
* Although that way may not be obvious at first unless you're Dutch.
* Now is better than never.
* Although never is often better than *right* now.
* If the implementation is hard to explain, it's a bad idea.
* If the implementation is easy to explain, it may be a good idea.
* Namespaces are one honking great idea -- let's do more of those!
////

. Дотримуйтеся філософії "Zen of Python":

* Вищість гарного над потворним.
* Перевага явного перед неявним.
* Простота переважає складність.
* Складність є кращою, ніж заплутаність.
* Плоска структура краща за вкладену.
* Розрідженість переважає щільність.
* Важливість легкості читання.
* Особливі випадки не є настільки особливими, щоб порушувати правила.
* Однак практичність важливіша за бездоганність.
* Помилки не мають залишатись непомітними.
* Якщо приховування помилок не зазначено явно.
* При стиканні з неоднозначностями, відкиньте спокусу вгадувати.
* Має існувати один і, бажано, _лише_ один очевидний спосіб зробити це.
* Хоча він може бути не очевидним, якщо ви не голландець.
* Час діяти -- зараз.
* Хоча "ніколи" часто краще, ніж _просто_ зараз.
* Якщо важко пояснити реалізацію -- задум поганий.
* Якщо реалізацію можна легко пояснити, тоді, _можливо_, задум добрий.
* Простори імен -- це велика перевага, створюймо їх більше!

. Опція https://en.wikipedia.org/wiki/Fail-fast[Fail fast] найчастіше є найкращим рішенням.
. Використовуйте "Return early" для перевірки вхідних параметрів.
. Використовуйте Правило скаутів: "Залишаємо код у стані, кращому ніж ми його знайшли".
. Уникайте використання _break, continue, return_ у складних конструкціях.
. Завжди використовуйте фігурні дужки у циклах та умовах.
. Уникайте створення методів з понад чотирма вхідними параметрами.
. Уникайте створення методів, що модифікують вхідний параметр.
. Логування об'єктів має здійснюватися без трансформації об'єктів, з огляду на NPE.

==== Стандарти стилістики коду (Code Style)

. Табуляція: використовуйте чотири пробіли.
. Використовуйте статичні імпорти лише під час роботи з DSL.
. Замінюйте загальні імпорти ("*") на специфічні.
. Виділяйте новими рядками лише групи логічно пов'язаних полів, а не кожне поле окремо.
. Визначайте поля класу перед полями об'єкта.
. При виборі імен змінних орієнтуйтеся на їх функцію, а не на тип. Наприклад, `StringBuilder stringbuilder = new StringBuilder()` -- погано, `StringBuilder fields = new StringBuilder()` -- добре.
. Віддавайте перевагу назвам класів, які починаються з доменного значення. Наприклад: `UserService`, `UserKafkaService` (технологічна складова може йти посередині).

==== Стандарти роботи з Git

. У репозиторії не повинно бути специфічних даних, таких як локальні шляхи або налаштування, характерні для конкретного розробника (properties).
. При створенні Git-повідомлень:
* Номер завдання з Jira має бути вказаний на початку у квадратних дужках.
* Повідомлення має відповідати на питання: "Що змінив цей commit?".
* Якщо опис commit потребує більш детального пояснення, то слід використати короткий заголовок на першому рядку, а потім на новому рядку додати детальний опис (Git вміє з цим працювати).
* Крапку в кінці повідомлення не ставимо.

==== Вимоги до роботи з POM

. Використовуйте батьківський _pom.xml_ для:
* визначення версії залежності;
* управління плагінами.

. При перенесенні версії бібліотеки до налаштувань (_.properties_), необхідно додати суфікс `.version`. Наприклад, `<querydsl.version>`...`</querydsl.version>`.

[#unit-testing-standards]
==== Стандарти модульного тестування

. Рекомендується використовувати підхід _ААА_ -- _ArrangeActAssert_.
. Немає потреби в коментарях (_given, when, then_), відділення порожніми рядками є достатнім.
. Використовуйте анотацію `@DisplayName` в *JUnit 5* для надання більш детальної інформації.
. Уникайте "throws Exception" у декларації тестів.
. Не рекомендується використовувати _PowerMock_.
. Для mock-об'єктів додавайте відповідний префікс `mock`. Наприклад, `mockRepository`.
. Уникайте беззмістовних повідомлень у перевірках. Наприклад, `Assertions.assertNotNull(object, "Shouldn't be null")`.

==== Вимога до підтримки "Чистоти" коду

При розробці коду дотримуйтеся підходу "*Clean code*" ("чистий код"), що передбачає створення якісного, добре написаного коду.

Код вважається "добрим", якщо він:

* відповідає вимогам, тобто пройшов тести;
* чітко виражає всі замисли дизайну, які були задумані;
* не містить дублювання;
* мінімізує кількість компонентів.

==== Використання метрик SQALE для оцінки та управління технічним боргом

У процесі розробки програмного забезпечення зміни в одній частині коду часто вимагають супутніх змін в інших сегментах коду або документації. Цей процес відомий як накопичення "_технічного боргу_". Термін "технічний борг" також охоплює інші незавершені, але необхідні зміни, що являє собою "борг", який необхідно погасити у визначений момент у майбутньому.

Для вимірювання та керування обсягами технічного боргу застосовується методологія *SQALE*.

== Методології розробки програмного забезпечення

Розробка Платформи здійснюється за допомогою методології *Agile software development*.

*Agile software development* (_або гнучка методологія розробки програмного забезпечення_) -- це клас методологій, що ґрунтується на ітеративній розробці. Вона передбачає, що вимоги та рішення еволюціонують у процесі співпраці між самоорганізованими багатофункціональними командами.

=== Структура виконавців системи (Delivery)

==== Команди розробки та управління

* Управлінська команда (Management)
* Платформна команда (Platform Team)
** Три Scrum-команди
** Сервісна команда Платформи (Platform Service Team)
* Команда системних архітекторів (SA Team)
* Центр компетенцій та команда реєстрів (Competence Center and Register Team)
* Команда управління сервісами (Service Management Team)

==== Впровадження Agile-методології

У рамках використання Agile-методології, основним підходом виступає *Scrum*.

*Scrum* -- це методика управління проєктами, що зорієнтована на гнучку розробку програмного забезпечення і наголошує на високому рівні якості розробки.

Враховуючи, що Платформа є масштабним та технічно складним продуктом, при розробці якого бере участь велика кількість команд та спеціалістів, використовується підхід *LeSS* (Large Scale Scrum). *LeSS* -- це великомасштабний Scrum, призначений для багатьох команд, які працюють над одним продуктом.

Такий підхід передбачає _тривалість спринту два тижні_.

*Scrum-майстром* виступає спеціаліст з управлінської команди -- *Delivery Manager*.

Оцінка зусиль, необхідних для виконання завдань, вимірюється в одиницях *story points*. Кожне завдання, яке може бути подроблене на менші частини, фіксується в Jira backlog та розподіляється між розробниками відповідних команд управлінською командою.

Процес планування проводиться управлінською командою за участю провідних розробників і, за необхідності, усіх членів команди розробників.
Для оцінки складності завдань використовується метод _планування покером_ -- *Planning poker*, який передбачає оцінювання складності задач консенсусно.
Виходячи з песимістичних очікувань, задається термін виконання задач, що дає запас часу на їх виконання та забезпечує гнучкість при виникненні ускладнень.

У процесі роботи зі Scrum, впроваджено підхід управління залежностями, що передбачає активний аналіз та мінімізацію ризиків, пов'язаних із внутрішньокомандною або міжкомандною залежністю.

==== Інструменти співпраці між командами

* Система управління задачами (Ticket management system) Jira.
* База знань для формування документації (Knowledge base) Confluence.
* Git-репозиторії для взаємодії з вихідним кодом.

==== Використання Scrum-артефактів

===== Артефакт Definition of Ready (DoR)

*Definition of Ready (DoR)* у Scrum-фреймворку -- це критерії готовності задачі (користувацької історії -- User Story) до початку роботи над нею. Вони визначають умови, за яких користувацьку історію можна прийняти до виконання і включити у спринт. Для команди важливо мати чіткі DoR для елементів беклогу.

Критерії готовності включають наступне:

* Історія та задача для беклогу спринту чітко визначені та оцінені на вищому рівні.
* Технічні пріоритети встановлені на основі залежностей або технічних можливостей.
* Історія/задача включає детальний опис, критерії прийняття у форматі списку, нефункціональні вимоги, та ризики.
* Керівники/архітектори розуміють, що і як слід робити, і мають можливі запитання для уточнення.
* Історія/задача знаходиться в одному зі статусів: "В аналізі", "Відкрито", "Заблоковано".
* Історія/задача має посилання на відповідне завдання Epic.
* Історія/задача призначена відповідальній за її виконання команді.
* В історії/задачі зазначена фаза розробки проєкту.
* Історія/задача незалежна.
* Історія/задача затверджена та пріоритезована замовником на основі заявлених вимог під час сесії грумінгу (grooming session).
* Усі блокуючі фактори для історій/задач спринту вирішені.
* Критерії прийняття чітко описані та зрозумілі з точки зору розробки та тестування для команди розробників та контролю якості.
* Назва історії/завдання може містити певний префікс для позначення конкретного завдання/історії: [SPIKE], [POC], [DESIGN].
* Кожна історія/задача -- це тестована функціональна одиниця, і тестувальник розуміє, як вона повинна бути перевірена, і що слід зробити перед цим (налаштування цільового середовища, підготовка тестових даних і т.д.).
* Історія/задача знаходиться в статусі "Готова до розробки".
* Усі підзадачі детально визначені (один-два дні для розробки кожної) й призначені виконавцям.
* Усі підзадачі повинні мати один з префіксів, залежно від спеціалізації: [UX], [BA], [BE], [FE], [DB], [DEVOPS], [QA], [TW], [AUTO].
* Для історій/задач з моделюванням даних -- в описі має бути посилання на сторінку в Knowledge Base з затвердженою моделлю даних.
* Для історій/задач з моделюванням бізнес-процесів -- має бути доступним посилання на сторінку в Knowledge Base, яка містить наступну інформацію:

** Опис точок інтеграції.
** Опис полів форми.
** Опис потоку користувачів.
** Макети UX/UI.

===== Артефакт DoD

Означення виконаної роботи (Definition of Done) -- це встановлені умови, при виконанні яких задача або користувацька історія можуть бути визнані виконаними ("Done"). 
Ці критерії розробляються для користувацької історії, аби команда розробників мала чітке уявлення про очікуваний результат роботи.

*Критерії успішності:*

. Розробка завершена:

* проведено перевірку коду відповідно до внутрішніх стандартів;
* код успішно застосовано (merged) до Master-гілки;
* проведено статичний аналіз коду та його розгортання (критичні проблеми відсутні -- покриття Unit-тестами > 80%);
* функціональність відтестована у середовищі "UAT-Integration";
* проведено автоматичне сканування безпеки з допомогою SAST, SCA та DAST-сканерів.

. Успішно пройдено тестування розробки в середовищі "UAT-Integration".
. Успішно пройдено ручне тестування.
. Розроблено автотести, які передано на CI/CD (досягнуто всіх критеріїв приймання).
. Зареєстровано час виконання історій/задач в Jira.
. Результат історії/задачі можна продемонструвати Замовнику в середовищі UAT.
. Статус історії/задачі в Jira встановлено як "Закрито".
. У разі виявлення дефектів, створено, відсортовано, призначено та заплановано усі виявлені дефекти.

==== Підходи до управління релізом ІС

Як підхід управління релізом системи використовується семантичне версіонування Платформи та компонентів Платформи.

Загальний підхід використовує три основні типи релізу:

* *MAJOR*, основна версія -- включає несумісні зміни API.
* *MINOR*, мінорна версія -- включає додавання функціональних можливостей зворотно сумісним способом.
* Версія *PATCH* або *HOTFIX* -- включає виправлення помилок із можливістю зворотної сумісності.

Релізи Платформи та компонентів Платформи є незалежними.

===== Спринти та нумерація релізів

Тривалість спринту складає два тижні.

Шаблон нумерації релізів Платформи та компонентів Платформи на цей час є наступним: `1.X.X`,
де `X` -- розширення функціональності, версія релізу.
Наприклад, наприклад, `1.9.5`.

Після кожного релізу новий Jenkins-pipeline створюється із назвою release-`1-X-X` за допомогою *EDP Admin Console*.

== Контроль якості коду (code quality)

Для забезпечення високої якості коду при розробці програмного забезпечення використовуються спеціалізовані методики та інструменти, відомі як контроль якості коду (*Code Quality*).

=== Статичний аналіз коду

Основним методом, який використовують розробники, є _статичний аналіз коду_.

Статичний аналіз коду -- це методика аналізу програмного забезпечення, який проводиться без фактичного виконання програми. Під аналіз піддається початковий код, який тестується за допомогою спеціального програмного забезпечення.

Наступні інструменти використовуються для проведення статичного аналізу коду:

* *IntelliJ IDEA* -- це інтегроване середовище розробки. Воно аналізує код у відкритих файлах і виділяє проблемні ділянки в процесі введення. Також IntelliJ IDEA дозволяє вручну запустити перевірку або набір перевірок на вибраному обсязі файлів, надаючи можливість отримати детальний звіт про всі проблеми, виявлені в коді.

* *SonarQube* -- це платформа з відкритим кодом, розроблена для постійного аналізу і перевірки якості коду, що дозволяє виявляти помилки та вразливості безпеки за допомогою статичного аналізу коду. Інструмент використовується на етапах Jenkins pipelines при створенні запиту на злиття змін до master-гілки, а також під час злиття гілки розробника до master-гілки.

* *Semgrep* -- це аналізатор статичного коду, який дозволяє виявляти потенційні помилки та вразливості в програмах Java.

* *Yelp Detect-secrets* -- це аналізатор коду, що допомагає виявляти секрети, що були випадково збережені в коді.

* *Checkmarx KICS (Keeping Infrastructure as Code Secure)* -- це рішення з відкритим кодом для статичного аналізу інфраструктури, описаної кодом.

* *Trivy* -- це статичний сканер Docker-образів, що виявляє вразливості та помилки конфігурації.

=== Покриття коду тестами (Code coverage)

Розробники використовують метод аналізу покриття коду тестами.
Покриття тестами за метриками інструментів аналізу *code coverage* має бути _не меншим за 80%_.

Для перевірки покриття коду тестами використовуються наступні інструменти:

* *IntelliJ IDEA* -- інтегроване середовище розробки ПЗ.
+
Покриття коду в IntelliJ IDEA дозволяє бачити, наскільки ваш код був виконаний. Інструмент також дозволяє перевірити, наскільки ваш код охоплюється модульними тестами, щоб ви могли оцінити, наскільки ефективні ці тести.
+
IntelliJ IDEA застосовує декілька локальних плагінів для цих потреб, наприклад, EMMA, JaCoCo тощо.

* *SonarQube* -- платформа з відкритим кодом, розроблена для постійного аналізу (continuous inspection) та перевірки якості коду для автоматичного огляду зі статичним аналізом коду для виявлення помилок, та вразливостей безпеки.

=== Модульне тестування (Unit Testing)

Для забезпечення високої якості та "чистоти" написаного розробниками коду, використовується метод модульного тестування.
Покриття коду модульними тестами має бути _не меншим за 80%_.

Модульне тестування (англ. -- _Unit Testing_) -- це метод тестування програмного забезпечення, який полягає в окремому тестуванні кожного модуля коду програми. Модулем називають найменшу частину програми, яка може бути протестованою. У процедурному програмуванні модулем вважають окрему функцію або процедуру.

Тобто, при проєктуванні та розробці використовується підхід декомпозиції частин ІС на окремі модулі, кожен з яких окремо підлягає поглибленому тестуванню.

Для виконання модульного тестування, розробники використовують наступні інструменти:

* JUnit;
* AssertJ;
* Wiremock;
* MockMvc;
* Spring-boot-test.

TIP: Стандарти та рекомендації щодо проведення розробниками модульного тестування при розробці цієї інформаційної системи описані у розділі xref:#unit-testing-standards[] поточного документа.

=== Покриття автоматизованими тестами

_Автоматизоване тестування програмного забезпечення_ -- частина процесу тестування на етапі контролю якості в процесі розробки програмного забезпечення. Воно використовує програмні засоби для виконання тестів і перевірки результатів виконання, що допомагає скоротити час тестування і спростити його процес.

Для проведення належних процедур з автоматизованого тестування, використовується набір професійних засобів/інструментів.

==== Інструменти тестування Платформи

Перелік інструментів, які залучені для тестування Платформи, наведений у таблиці "Інструменти тестування Платформи" (_див. нижче_).

Визначено декілька категорій інструментів:

* _Інструменти збереження та обміну інформації_ -- інструменти, призначені для збереження та створення проєктної документації, та служать єдиним місцем входу до проєкту.
* _Інструменти тестування_ -- інструменти, що використані під час ручного та автоматизованого тестування.
* _Інструменти моніторингу_ -- інструменти, що використовуються для моніторингу стану платформи та відображення його на налаштованих попередньо моніторах.

.Інструменти тестування Платформи
[width="100%",cols="45%,55%",options="header",]
|===
|*Категорія* |*Назва інструменту*
|*Інструменти збереження та обміну інформації* |
|Система збереження вимог |JIRA, Confluence
|Система збереження тест-кейсів |JIRA Plugins
|Система збереження дефектів |JIRA
|*Інструменти тестування* |
|API-контракти |SoapUi, RestAssured, Postman
|SOAP-контракти |SoapUI,JAX-WS
|Web-додатків |Selenium WebDriver, Cucumber або похідні
|Desktop-систем (Camunda) |TBD
|Тестування даних |WireMock (маскування даних)
|Інтеграція з Трембітою |SoapUi
|Тестування навантаження |Gatling
|Тестування безпеки a|
* owasp zap -- DAST

* trivy -- continer security/SCA

* secrets scanner -- detect-secrets from yelp

* Iaac security -- kics from checkmarx

* semgrep from owasp -- SAST

|Тестування доступності вебконтенту |Wave (Web Accessibility Evaluation Tool)
|*Інструментимоніторингу* |
|Система моніторингу |Prometheus
|Система візуалізації даних |Grafana
|===

TIP: Загальний обсяг функціонального та нефункціонального тестування, а також методологія (стратегія) тестування інформаційної системи детально описані у розділі xref:testing:functional-testing/functional-testing.adoc[]

=== Перевірка вихідного коду (Code review)

*Code Review* -- це систематичний процес перевірки вихідного коду програми, який використовується під час розробки інформаційної системи. Цей процес спрямований не лише на виявлення помилок, але також слугує важливим етапом розробки програмного забезпечення, що сприяє покращенню якості коду.

==== Процес огляду коду в контексті розробки інформаційної системи

* При розгортанні компонентів інформаційної системи застосовується *GitOps*-підхід, заснований на процесах *CI/CD*. Однією з ключових особливостей цього підходу, включаючи аспект безпеки, є те, що _Git служить єдиною точкою входу_ для внесення будь-яких змін до системи.

* Розробник спочатку вносить зміни до своєї власної гілки захищеного віддаленого VCS-репозиторію, виконуючи команди `git commit` і `git push`.

* Наступним кроком є створення запита на злиття змін із гілки розробника до `master`-гілки репозиторію -- це називається *Merge Request* або *MR*.

* Після цього члени команди розробників проводять огляд коду, що є колективним процесом. Його метою є перевірка написаного коду з метою виявлення помилок та надання пропозицій щодо його виправлення або покращення.

* Для злиття коду до `master`-гілки потрібно отримати принаймні одне підтвердження від головного розробника команди.

* Злиття змін, що були обговорені в рамках створеного Merge Request, здійснює уповноважена особа з відповідними правами доступу.

==== Рефакторинг коду (Code refactoring)

Для покращення якості та оптимізації коду використовується стандартна методика -- *Code refactoring*.

*Code refactoring*, як правило, проводиться у двох випадках:

* рефакторинг коду в рамках code review для виправлення критичних помилок та покращення роботи застосунків;
* рефакторинг коду як частина оптимізації системи (некритичні задачі).

Оптимізація вихідного коду визначається, але не обмежується наступними критеріями:

* найменування (naming);
* "чистота коду" ("Clean code");
* оптимізація продуктивності (performance optimization): ОЗУ, ЦП, кількість запитів за секунду тощо;
* оптимізація коду;
* Спрощення API-контрактів.


== Контроль за виконанням нефункціональних вимог

Розробка Платформи провадиться із дотриманням наступних принципів (_нефункціональних вимог_):

* ефективність роботи (Performance efficiency);
* безпека (Security);
* надійність (Reliability);
* переносимість (Portability);
* працездатність (Operability);
* змінність (Modifiability);
* здатність до контролю/перевіреність (Verifiability);
* інтеграційна взаємодія (Interoperability).