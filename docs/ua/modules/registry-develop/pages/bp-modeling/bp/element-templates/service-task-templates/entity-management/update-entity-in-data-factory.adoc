= Оновлення сутності у Фабриці даних: _Update entity in data factory_
include::platform:ROOT:partial$templates/document-attributes/default-set-ua.adoc[]

== Загальна інформація

Інтеграційне розширення *Update entity in data factory* дозволяє налаштовувати завдання для оновлення записів у базі даних у бізнес-процесі. Це розширення допомагає автоматизувати процеси оновлення даних, забезпечуючи належне оброблення запитів та передачу їх до наступних етапів бізнес-процесу. Розширення додає різні властивості до завдання типу *Service Task*.

.Короткі відомості про делегат
|===
|Назва | Пояснення

|Бізнес-назва інтеграційного розширення
|*Update entity in data factory*

|Службова назва інтеграційного розширення
|*`${dataFactoryConnectorUpdateDelegate}`*

|Назва файлу у бібліотеці розширень
|*_dataFactoryConnectorUpdateDelegate.json_*
|===

== Перед початком

include::partial$admonitions/install-element-templates.adoc[]

== Налаштування

Делегат *Update entity in data factory* призначений для використання у сервісних завданнях (Service Task) бізнес-процесу. Він дозволяє налаштувати автоматичне оновлення даних у базі даних.

NOTE: Делегат *Update entity in data factory* використовує HTTP-метод `PUT`, який передбачає обов'язкове оновлення усіх полів сутності. Іншими словами, сутність щоразу перезаписується. Якщо потрібно оновити якісь конкретні поля (одне або більше), використовуйте делегат xref:bp-modeling/bp/element-templates/service-task-templates/entity-management/update-entity-in-data-factory-partially.adoc[]. Він використовує метод `PATCH`.

=== Налаштування завдання

. Створіть завдання типу *Service Task* у вашому бізнес-процесі.
. Назвіть завдання, наприклад, `Оновлення даних у БД`.
. Застосуйте шаблон делегата, обравши *Update entity in data factory* зі списку в налаштуваннях завдання.
+
//TODO: add image
image:registry-develop:bp-modeling/bp/element-temp/service-task/entity-management/update-entity/update-entity-1.png[]

=== Налаштування делегата

Виконайте наступні налаштування:

Resource ::
У полі *Resource* вкажіть ендпоінт / таблицю, в якій необхідно оновити дані. Наприклад, `entity-build-acts`.

Resource id ::
У полі *Resource id* вкажіть ідентифікатор сутності, яку потрібно оновити. Наприклад:
+
----
${submission('UserTask_SignUpdateBuildInfo').formData.prop('building').prop('entityId').value()}
----
+
[NOTE]
====
Цей вираз виконує такі дії:

. `submission('UserTask_SignUpdateBuildInfo')`:
- Отримує дані форми, яка була заповнена користувачем у завданні з ID `UserTask_SignUpdateBuildInfo`.

. `formData`:
- Звертається до даних форми, отриманих у попередньому кроці.

. `prop('building')`:
- Знаходить властивість (поле) форми з назвою `building`.

. `prop('entityId')`:
- Знаходить властивість (поле) `entityId` всередині поля `building`.

. `value()`:
- Отримує значення властивості `entityId`.
====

Payload ::
У полі *Payload* зазначте дані для оновлення у форматі JSON. Наприклад, `${payload}`.
+
[NOTE]
====
Ви можете отримати значення `payload` зі скрипту. Наприклад:

[source,groovy]
----
def formDataForm = submission('UserTask_SignUpdateBuildInfo').formData

def buildTypeId = formDataForm.prop('buildType').prop("buildTypeId").value()

def data = [:]
data['buildType'] = buildTypeId;
data['buildNumber'] = formDataForm.prop('buildNumber').value()
data['sectionNumber'] = formDataForm.prop('sectionNumber').value()
data['flatNumber'] = formDataForm.prop('flatNumber').value()
data['autoGeneratedNumber'] = formDataForm.prop('building').prop('autoGeneratedNumber').value()

def payload = S(data, 'application/json')
set_transient_variable('payload', payload)
----

Скрипт отримує дані з форми, формує об'єкт `payload` у форматі JSON, який містить інформацію про тип будівлі, номер будівлі, номер секції, номер квартири та автоматично згенерований номер. Цей об'єкт `payload` зберігається як транзитна змінна для подальшого використання у процесі, наприклад, для оновлення даних у базі даних.

Деталі скрипту: ::
. *Отримання даних форми*:
+
```groovy
def formDataForm = submission('UserTask_SignUpdateBuildInfo').formData
```
- Отримує дані форми, яка була заповнена користувачем у завданні `UserTask_SignUpdateBuildInfo`. Дані форми зберігаються у змінній `formDataForm`.

. *Отримання конкретного значення з форми*:
+
```groovy
def buildTypeId = formDataForm.prop('buildType').prop("buildTypeId").value()
```
- Отримує значення властивості `buildTypeId`, яка знаходиться всередині властивості `buildType`. Це значення зберігається у змінній `buildTypeId`.

. *Формування об'єкта `data`*:
+
```groovy
def data = [:]
data['buildType'] = buildTypeId;
data['buildNumber'] = formDataForm.prop('buildNumber').value()
data['sectionNumber'] = formDataForm.prop('sectionNumber').value()
data['flatNumber'] = formDataForm.prop('flatNumber').value()
data['autoGeneratedNumber'] = formDataForm.prop('building').prop('autoGeneratedNumber').value()
```

* Створюється порожній об'єкт `data` у вигляді map (словника).
* Додаються наступні поля у цю мапу:
- `buildType` з отриманим значенням `buildTypeId`.
- `buildNumber` з значенням поля `buildNumber` з форми.
- `sectionNumber` з значенням поля `sectionNumber` з форми.
- `flatNumber` з значенням поля `flatNumber` з форми.
- `autoGeneratedNumber` з значенням поля `autoGeneratedNumber` всередині властивості `building` з форми.

. *Створення об'єкта `payload` у форматі JSON*:
+
```groovy
def payload = S(data, 'application/json')
```
- Перетворює об'єкт `data` у формат JSON та зберігає його у змінній `payload`.

. *Встановлення змінної `payload` як транзитної*:
+
```groovy
set_transient_variable('payload', payload)
```
- Зберігає змінну `payload` як транзитну змінну, що дозволяє використовувати її у подальших кроках процесу.

====
+
[NOTE]
====
В результаті для оновлення сутності формується JSON-об'єкт у наступному форматі:

[source,json]
----
{
  "buildNumber": "string",
  "entityId": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
  "flatNumber": "string",
  "buildType": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
  "autoGeneratedNumber": "string",
  "sectionNumber": "string"
}
----
====

X-Access-Token ::
У полі *X-Access-Token* вкажіть токен доступу користувача, під яким виконується операція. Цей токен забезпечує повноваження виконавця задачі щодо доступу до даних.

* Наприклад, вкажіть токен ініціатора процесу через JUEL-функцію `initiator()`, використавши метод `accessToken`:
+
[source,groovy]
----
${initiator().accessToken}
----

* Альтернативно, ви можете вказати токен виконавця останнього користувацького завдання. Для цього ви можете використати JUEL-функцію `completer()`, передавши ID попередньої задачі та використавши метод `accessToken`. Наприклад:
+
[source,groovy]
----
${completer('UserTask_SignUpdateBuildInfo').accessToken}
----
+
** `completer()` — назва JUEL-функції.
** `'UserTask_SignUpdateBuildInfo'` — ID попередньої задачі користувача.
** `accessToken` — метод, який передає JWT-токен користувача.

X-Digital-Signature source ::
У полі *X-Digital-Signature source* вкажіть джерело цифрового підпису. Це поле вказує на Ceph-документ із цифровим підписом даних КЕП на стороні користувача (_див. детальніше про підпис КЕП у делегатах xref:bp-modeling/bp/element-templates/user-task-templates/officer-sign-task.adoc[] та xref:bp-modeling/bp/element-templates/user-task-templates/citizen-sign-task.adoc[]_). Функція `sign_submission()` та метод `signatureDocumentId` дозволяють отримати підписані дані з UI-форми та передати ID Ceph-документа. Наприклад:
+
[source,groovy]
----
${sign_submission('UserTask_SignUpdateBuildInfo').signatureDocumentId}
----

* `sign_submission` -- назва JUEL-функції.
* `'UserTask_SignUpdateBuildInfo'` -- ID завдання користувача, із даними, на які накладено КЕП.
* `signatureDocumentId` -- метод, який дозволяє отримати ID Ceph-документа, в якому зберігаються підписані КЕП дані.

X-Digital-Signature-Derived source ::
* У полі *X-Digital-Signature-Derived source* вкажіть джерело системного цифрового підпису (цифрової печатки). Це поле вказує на Ceph-документ із системним цифровим підписом (цифровою печаткою), накладеним на дані. Наприклад, `${system_signature_key}`.

* (_Альтернативно_) Скористайтеся наступним виразом для отримання системного підпису:
+
[source,groovy]
----
${execution.getVariable("secure-sys-var-ref-task-form-data-{taskDefinitionId}")}
----
+
де `taskDefinitionId` -- ID задачі, звідки потрібно отримати змінну.
+
[TIP]
====
Значення ключа/ідентифікатора системного підпису можна отримати після підпису даних за допомогою делегата xref:bp-modeling/bp/element-templates/service-task-templates/signature/system-signature-by-dso-service.adoc[]. Результат виконання операції підписання даних системним ключем буде збережено до вказаної змінної, наприклад, `system_signature_key`. Надалі ви зможете використати змінну в іншому місці процесу, зокрема під час оновлення даних до БД тощо.
====

Result variable ::
У полі *Result variable* задайте ім'я для змінної, в якій буде зберігатися відповідь від операції створення сутності, наприклад, `response`.

include::registry-develop:partial$snippets/element-templates/delegate-204-ok-response.adoc[]

== Приклад

Ось приклад, який показує, як відповідний делегат використовується у бізнес-процесі:

.Приклад. Налаштування делегата Update entity in data factory
image::registry-develop:bp-modeling/bp/element-temp/service-task/entity-management/update-entity/update-entity-2.png[]

[TIP]
====
[%collapsible]
.Де можна знайти приклад бізнес-процесу?
=====
include::partial$snippets/demo-reg-reference-examples-ua.adoc[]

*Update entity in data factory* — делегат, який використовується у бізнес-процесах, що потребують оновлення записів у БД.

Ви можете використати один із прикладів процесів за пошуком по ключовим словам — *_reference-search-type-or_*.

У Кабінеті користувача бізнес-процес буде доступний у розділі *Доступні послуги*.
=====
====

TIP: Більш детально з описом бізнес-процесу ви можете ознайомитися на сторінці xref:best-practices/bp-and-or-single-table.adoc[].

== Пов'язані сторінки

* xref:bp-modeling/bp/element-templates/service-task-templates/entity-management/update-entity-in-data-factory-partially.adoc[]
