= Аудит бізнес-процесів

|===
|Назва | Критичність

|<<_bp_01>> |Середня
|<<_bp_02>> |Висока
|<<_bp_03>> |Висока
|<<_bp_04>> |Висока
|<<_bp_05>> |Висока
|<<_bp_06>> |Середня
|<<_bp_07>> |Середня
|<<_bp_08>> |Висока
|<<_bp_09>> |Висока
|<<_bp_10>> |Низька
|<<_bp_11>> |Низька
|<<_bp_12>> |Низька
|<<_bp_13>> |Низька
|<<_bp_14>> |Висока
|<<_bp_15>> |Висока
|<<_bp_16>> |Середня
|<<_bp_17>> |Середня
|<<_bp_18>> |Висока

|===

[#_bp_01]
== BP-01. X-Access-Token в сервісних задач
Використовувати в сервісних задачах X-Access-Token, який був отриманий в поточній транзакції бізнес-процесу

IMPORTANT: Критичність: середня

.Опис
При використанні _juel_ функцій для отримання користувацького авторизаційного токену (наприклад,
_completer('ActivityId').accessToken_, _initiator().accessToken_) треба впевнитись, що місце використання функції та
відповідна актівіті (користувацька задача, або початкова подія) знаходяться в одній транзакції бізнес-процесу. +

.Вплив
Термін дії користувацького авторизаційного токена може закінчитися, поки бізнес-процес дійде до точки використання.
Може бути не виявлено на етапі розробки та тестування через відсутність відповідних умов (задача, яку не беруть у
виконання понад 5 хв, довга транзакція, тимчасова недоступність сервісу тощо) +

.Рекомендації
Використовувати токен користувача найближчої до точки використання задачі або токен системного користувача
(_system_user().accessToken_)

NOTE: При використанні токена системного користувача в історичну таблицю будуть внесені дані саме цього користувача,
а не дані безпосередньо ініціатора зміни. В такому випадку рекомендується розглянути розширення дата моделі регламенту
для внесення даних про ініціатора явно.

[#_bp_02]
== BP-02. Довгі транзакції бізнес-процесів
При наявності в бізнес-процесі транзакцій, які потенційно можуть виконуватись довгий час, треба розділяти їх на окремі
транзакції.

IMPORTANT: Критичність: висока

.Опис
При моделюванні бізнес-процесів необхідно розділяти великі транзакції та робити якомога більше задач асинхронними для
надійності виконання та спрощення реагуванні на можливі помилки.

.Вплив
Довгі транзакції можуть призвести до наступних проблем:

* Вичерпання пулу з'єднань до бази даних і блокування виконання інших бізнес-процесів.
* При виникненні помилки, політики повтору (retry policy) будуть виконуватися від початку транзакції, виконуючи всі
задачі, які вже були виконані
* Час життя _X-Access-Token_, який використовується в сервісних задачах транзакції може закінчитися, поки транзакція
виконується
* Якщо початком транзакції є користувацька задача:
** Користувач буде бачити лоадер і не отримає повідомлення про успішно виконану операцію, поки транзакція не буде
завершена
** Транзакції на Кафці пов'язані з транзакціями на _Сервісі виконання бізнес-процесів_ при виконанні користувацьких
задач і обмежені по часу у 30 секунд.
** Проксі сервери мають обмеження на час виконання запиту у 30 секунд. Тобто при перевищенні цього показника часу
користувацький запит буде відхилено.

.Рекомендації
В задачах транзакції проставляти атрибути _camunda:asyncBefore_ або _camunda:asyncAfter_ зі значенням _true_ для
асинхронного продовження (_Asynchronous Continuations_) бізнес-процесу, що призведе до створення нової транзакції.
Додатково слід враховувати роботу з користувацьким токеном (<<_bp_01>>) та несталими
змінами (<<_bp_07>>) при моделюванні асинхронних задач.

NOTE: Детальніше про транзакції у Camunda можна ознайомитись
https://docs.camunda.org/manual/7.19/user-guide/process-engine/transactions-in-processes/[за посиланням]

[#_bp_03]
== BP-03. Транзакції в циклах
При наявності циклів в бізнес-процесі, розпочинати кожну ітерацію в окремій транзакції

IMPORTANT: Критичність: висока

.Опис
Причиною довгої транзакції може бути цикл, який виконує велику кількість ітерації, тому при моделюванні циклів в
бізнес-процесах необхідно застосовувати асинхронне виконання для кожної ітерації.

.Вплив
При наявності циклів, які мають велику кількість ітерацій _Camunda Engine_ тримає транзакцію на базі даних протягом всього
часу його виконання, що може призвести до впливу довгих транзакцій, які описані в <<_bp_02>>.
Додатково слід зауважити, що при виникненні помилки на 100-ій ітерації, буде спроба виконати всі ітерації, починаючи з
першої.

.Рекомендації
Проставляти _camunda:asyncBefore_ атрибут після першої актівіті у циклі (це може бути сервісна задача, або початкова
подія у випадку під-процесу) або _camunda:asyncAfter_ останньої актівіті у циклі. Потрібно також врахувати та виключити
використання несталих (transient) змінних, які були отримані у бізнес-процесі до першої операції у циклу.

[#_bp_04]
== BP-04. Стратегія повторних спроб (retry time cycle)
Перевизначати стратегію повторних спроб (retry time cycle) для асинхронних задач.

IMPORTANT: Критичність: висока

.Опис
За замовчуванням при виникненні помилки при виконанні асинхронних задач виконавець робіт (job executor) буде пробувати
виконати задачу ще 3 рази без пауз між ними. У більшості випадків причиною помилки може бути виклик іншого сервісу як
всередині системи, так і за її межами, який міг бути тимчасово недоступний. В такому випадку негайний повтор не призведе
до якихось змін і врешті решт задача буде помічена невдалою (failed) і може бути перезапущена тільки  вручну
_Адміністратором реєстру_ у _Сервісі адміністрування бізнес-процесами_

.Вплив
При виникненні помилки під час виконання асинхронних задач у більшості випадків повторні спроби не призводять до
успішного завершення задачі, а лише ще більше навантажують сервіс з яким могла виникнути проблема.

.Рекомендації
Для асинхронних задач встановити атрибут циклу повторних спроб _camunda:failedJobRetryTimeCycle_ з певною затримкою,
наприклад, 5 спроб кожні 5 хвилин _R5/PT5M_. В процесі експлуатації значення може бути адаптоване відповідно до поведінки
бізнес-процесу.

NOTE: Детальніше про повторні спроби у Camunda можна ознайомитись https://docs.camunda.org/manual/7.19/user-guide/process-engine/the-job-executor/#retry-time-cycle-configuration[за посиланням]

[#_bp_05]
== BP-05. Ліміт для критеріїв пошуку
При використанні делегатів, які виконують пошук сутностей у фабриці даних чи в сервісі управління користувачами та
ролями, треба явно задавати параметр по максимальній кількості даних (limit), які можуть бути отримані.

IMPORTANT: Критичність: висока

.Опис
При використанні задач з пошуку даних параметр з максимальною кількістю даних (limit) не є обов'язковим, і  часто не
вказується при роботі з таблицями, які на етапі розробки містять невелику кількість даних. Однак, при використанні
в промисловому середовищі такі запити потенційно можуть нести набагато більше даних, що може призвести до деградації
роботи системи.

.Вплив
Велика кількість даних, отримана при використанні сервісної задачі з відсутнім параметром ліміту, може призвести до
наступних потенційних проблем:

* Деградація на _Сервісі управління користувачами та ролями_, яка впливає на продуктивність роботу функцій, що пов'язані
з входом в систему та роботу в кабінеті (оновлення користувацького токену) для користувачів всіх реєстрів на даному
екземплярі платформи
* Додаткове навантаження на сервіси системи:
** Реляційна база даних
** Сервіс синхронного управління даними реєстру
** Сервіс управління користувачами та ролями
** Сервіс виконання бізнес-процесів
* Збільшений час виконання окремого запиту на сервіс синхронного управління даними реєстру
* Збільшений час виконання бізнес-процесу
* Збільшений час виконання окремої транзакції бізнес-процесу
* Надмірне використання підключень до бази даних, що може призвести до накопичень запитів у черзі та ще більше збільшення
часу виконання запитів та бізнес-процесів

.Рекомендації
Завжди вказувати параметр ліміту (limit) для сервісних задач з пошуку даних. Можливі сценарії використання:

=== Пошук обмеженої кількості елементів
Якщо за бізнес-логікою відомо що після виконання запиту обробляється тільки певна кількість даних (наприклад, перший
елемент зі списку), то треба явно обмежити запит цією кількістю.

=== Обробка всіх даних за результатами пошуку
Якщо бізнес-процес повинен обробити всі дані, то треба розглянути поетапну обробку елементів (можливо, пачками)
в циклі та пагінацією при використанні сервісних задач з пошуку даних.

=== Інтеграція з зовнішніми системами
При необхідності запитів зовнішніми системами для вибірки даних з реєстру в першу чергу треба розглянути можливість
використання напряму АПІ для читання даних без залучення бізнес-процесу (але все одно з обов'язковими параметрами пагінації).
Якщо ж відповідна інтеграція потребує певної логіки бізнес-процесу, то треба додати відповідні параметри пагінації як
вхідні атрибути бізнес-процесу та імплементувати логіку пагінації на системі, що інтегрується.

[#_bp_06]
== BP-06. Складна логіка в скриптових задачах
При використанні скриптових задач слід уникати складної логіки і робити їх якомога простішими.

IMPORTANT: Критичність: середня

.Опис
Скриптові задачі дозволяють писати доволі складну логіку, використовуючи всю потужність мови Groovy, що в
короткостроковій перспективі (наприклад, розробка прототипів) можуть допомогти розробнику, але впроваджують перелік
ризиків пов'язаних з підтримкою та розробкою в майбутньому.

.Вплив
Важливі аспекти, пов'язані з використанням складної логіки в скриптових задачах:

* Супроводження: Складну логіку складно розуміти, обслуговувати та усунути. Це може зробити бізнес-процес важким для
управління та розвитку з часом і призвести до потенційних помилок та повільніших циклів розробки.
* Тестування: скриптові завдання зі складною логікою можуть бути важкими для ізольованого тестування, що ускладнює
забезпечення якості та надійності процесу.
* Продуктивність: складна логіка у скриптових завданнях може вплинути на продуктивність, особливо якщо вона містить
операції, що споживають багато ресурсів або довготривалі задачі.
* Обробка помилок: обробка помилок у скриптових задачах може бути складною, що ще більше ускладнює супроводження та
розуміння скрипту

.Рекомендації
* Використовувати скриптові задачі для простих, коротких та зрозумілих операцій
* Використовувати можливості DMN та BPMN для будь-якої бізнес-логіки в бізнес-процесах
* Використовувати вбудовані можливості _Camunda Spin_ для роботи з
https://docs.camunda.org/manual/7.19/user-guide/data-formats/xml/[XML] та
https://docs.camunda.org/manual/7.19/user-guide/data-formats/json/[JSON]

[#_bp_07]
== BP-07. Робота з несталими (transient) змінними
При моделюванні бізнес-процесів слід враховувати, що деякі змінні можуть бути несталими (transient) та не зберігатись
при переході на наступну транзакцію.

IMPORTANT: Критичність: середня

.Опис
При моделюванні бізнес-процесів є певний перелік сервісних задач, які виконують виклики, як всередині системи, так і на
зовнішні сервіси, наприклад, виклики до фабрики даних, сервісу управління користувачами та ролями, сервісу підпису,
Трембіти та інші. Результат будь-якого такого виклику може містити персональні дані користувача, тому зберігається як
нестала (transient) змінна і є доступна тільки в поточній транзакції бізнес-процесу.

.Вплив
Результат виклику сервісної задачі буде недоступний після переходу межі бізнес-процесу (користувацька задача, асинхронне
продовження, очікування повідомлення тощо)

.Рекомендації
* Використовувати результат виконання виклику сервісної задачі відразу після отримання результату в рамках однієї транзакції
* Якщо результат виклику сервісної задачі потрібно використовувати в наступних транзакціях і вони не містять персональних
даних, зберігати результат в сталій змінній бізнес-процесу
* Якщо результат виклику містить змішані дані, але надалі використовується тільки неперсональна частина з них (наприклад,
ідентифікатор сутності), відокремити її та зберегти як окрему сталу змінну

NOTE: Детальніше про несталі змінні в Camunda можна ознайомитись
https://docs.camunda.org/manual/7.19/user-guide/process-engine/variables/#transient-variables[за посиланням]

[#_bp_08]
== BP-08. Декілька викликів фабрики даних в одній транзакції
Для збереження складної сутності та транзакційного запису в декілька таблиць використовувати функціонал вкладених
сутностей (nested entity).

IMPORTANT: Критичність: висока

.Опис
При моделюванні бізнес-процесу може виникнути необхідність оновлення декількох таблиць бази даних в рамках однієї
транзакції (бази даних, не плутати з транзакцією бізнес-процесу). Тобто щоб або всі таблиці були оновлені, або жодна з них.
На рівні виконання бізнес-процесу не має можливості пов'язати декілька викликів фабрики даних в одну транзакцію, тому
декілька послідовних викликів фабрики даних в одному бізнес-процесі можуть призвести до створення неконсистентних даних
в базі даних.

.Вплив
* Створення неконсистентних даних в базі даних після виникнення помилки між окремими викликами фабрики даних. В залежності
від логіки та моделі регламенту може призвести до повного блокування роботи з конкретним записом.
* При виникненні помилки, політика повторних спроб виконання бізнес-процесу розпочне виконання з початку, що може призвести
до повторної вставки даних в окрему таблицю.

.Рекомендації
* Використовувати функціонал вкладених сутностей (nested entity) для збереження складної сутності та транзакційного
виконання оновлення декількох таблиць бази даних в рамках однієї транзакції
* Якщо функціоналу по роботі з вкладеними сутностями виявилось недостатньо, розглянути наступні практики:
** Моделювання компенсації в бізнес-процесі. При виникненні помилки виконання бізнес-процесу виконати відкат змін у вигляді
викликів фабрики даних на видалення створених записів або відновлення попереднього стану
** Налаштувати кожну вставку в базу даних з асинхронним продовженням бізнес-процесу і відповідними політиками повторних
спроб. Це дозволить закінчити умовну транзакцію вставки в базу даних після усунення причини виникнення помилки
** Розташування окремих викликів фабрики даних один за одним в бізнес-процесі. Чим більше буде проміжних задач між викликами,
тим більше ймовірність виникнення помилки між вставками і невдалого виконання транзакції

[#_bp_09]
== BP-09. Ініціалізація та використання змінних
IMPORTANT: Критичність: висока

.Опис
При необхідності створення додаткової змінної в бізнес-процесі ініціалізувати її якомога ближче до місця використання
та уникати збереження великих за розміром змінних

.Вплив
* Зайве використання пам'яті при збереженні сталих змінних
* Збільшення часу виконання запитів при роботі з операційною базою даних Camunda
* Погіршує читабельність та розуміння бізнес-процесу
* Ускладнює виявлення можливих помилок

.Рекомендації
* Уникати збереження великих за розміром змінних. Для строкових змінних існує обмеження на рівні бази даних у 4000
символів https://docs.camunda.org/manual/latest/user-guide/process-engine/variables/[(посилання на документацію)]
* Уникати збереження змінних з типом Object
* Не використовувати надмірно змінні процесу. Як правило, зберігайте якомога менше змінних у Camunda. З офіційними
рекомендаціями від розробників Camunda можна ознайомитись
https://docs.camunda.io/docs/components/best-practices/development/handling-data-in-processes/#storing-just-the-relevant-datas[за посиланням]
* Ініціалізувати змінну безпосередньо перед її використанням. Під ініціалізацією змінної може бути як і явне її
створення, так і використання будь-яких задач, результат яких також зберігається як змінна.

[#_bp_10]
== BP-10. Ідентифікатори елементів бізнес-процесів
IMPORTANT: Критичність: низька

.Опис
Присвоювати технічно доречні ідентифікатори всім елементам бізнес-процесу в BPMN діаграмі.

.Вплив
Ідентифікатори елементів бізнес-процесу постійно використовуються в технічних логах, і підхід до доречного іменування
полегшує сприйняття і розуміння причини виникнення помилки.

.Рекомендації
Першим чином, розглянути перейменування процесів, актівіті (activity), повідомлень і ідентифікаторів помилок. Також
важливими елементами будуть шлюзи (gateways) і їх гілки виконання (sequence flows). Детальніше з конвенцією іменування
можна ознайомитись
https://docs.camunda.io/docs/components/best-practices/modeling/naming-technically-relevant-ids/#using-naming-conventions-for-bpmn-ids[за посиланням]

[#_bp_11]
== BP-11. Створення читабельних BPMN діаграм
IMPORTANT: Критичність: низька

.Опис
При моделюванні BPMN діаграм використовувати загально прийняті практики.

.Вплив
* Покращує читабельність і розуміння BPMN діаграми.
* Полегшує онбордінг нових членів команди
* BPMN діаграма стає зрозумілим і важливим інструментом при комунікації зі стейкхолдерами
* При необхідності загальної публікації опису послуги не потребує додаткового форматування

.Рекомендації
Орієнтуватися на
https://docs.camunda.io/docs/components/best-practices/modeling/creating-readable-process-models/#modeling-from-left-to-rightp[офіційну документацію]
Camunda з кращих практик моделювання BPMN діаграм. Деякі з рекомендацій наведені нижче:

* https://docs.camunda.io/docs/components/best-practices/modeling/creating-readable-process-models/#labeling-bpmn-elements[Маркування елементів BPMN]
* https://docs.camunda.io/docs/components/best-practices/modeling/creating-readable-process-models/#modeling-symmetrically[Моделювання симетрично]
* https://docs.camunda.io/docs/components/best-practices/modeling/creating-readable-process-models/#modeling-from-left-to-right[Моделювання зліва направо]
* https://docs.camunda.io/docs/components/best-practices/modeling/creating-readable-process-models/#creating-readable-sequence-flows[Створення читабельних потоків послідовностей (sequence flows)]
* https://docs.camunda.io/docs/components/best-practices/modeling/creating-readable-process-models/#modeling-explicitly[Моделювання явно (modeling explicitly)]
* https://docs.camunda.io/docs/components/best-practices/modeling/creating-readable-process-models/#avoiding-lanes[Уникання смуг (lanes)]
* https://docs.camunda.io/docs/components/best-practices/modeling/creating-readable-process-models/#emphasizing-the-happy-path[Підкреслення основного флоу (happy path))]

[#_bp_12]
== BP-12. Цикли за допомогою багатоекземплярних (multi-instance) підпроцесів
IMPORTANT: Критичність: низька

.Опис
При моделюванні циклів розглянути можливість використання багатоекземплярних (multi-instance) підпроцесів замість
циклів з використанням шлюзів (gateways).

.Вплив
В деяких випадках може покращити читабельність BPMN діаграми, внаслідок видалення технічних складових з бізнес-процесу
таких як:

* Явне створення і керування змінними для ітерації
* Перевірка умови завершення циклу з використанням шлюзів (gateways)

.Рекомендації
* Виділити логіку для окремої ітерації циклу в під-процес (sub-process)
* Змінити тип під-процесу на багатоекземплярний (multi-instance)
* Налаштувати параметри для багатоекземплярного (multi-instance) під-процесу:
** _camunda:collection_ - для кожного елементу колекції буде створено окремий інстанс під-процесу і виконана логіка
ітерації
** _camunda:elementVariable_ - змінна в якій буде зберігатися конкретний елемент колекції для кожної ітерації
** _completionCondition_ - додаткова умова для завершення циклу до кінця ітерації
** _loopCardinality_ - кількість ітерацій циклу (як альтернатив використання колекції)

NOTE: Детальніше про багатоекземплярні (multi-instance) підпроцеси можна прочитати в
https://docs.camunda.io/docs/components/modeler/bpmn/multi-instance/[офіційній документації]

[#_bp_13]
== BP-13. Логування в скриптових задачах
IMPORTANT: Критичність: низька

.Опис
Часто в скриптових задачах використовуються методи _print_ / _println_ для логування даних в консоль, що є припустимим
при розробці бізнес-процесу, але не прийнятно для промислових середовищ.

.Вплив
Використання методів _print_ / _println_ в скриптових задачах призводить до логування інформації в _Сервісі виконання
бізнес-процесів_, які надалі не можна пов'язати з конкретним бізнес-процесом та запитом користувача.

.Рекомендації
* Розглянути можливість відмови від додаткового логування в скриптових задачах взагалі. У більшості випадків логування
моделювальникам необхідне для налагодження бізнес-процесу на етапі розробки
* Якщо логування все ж необхідне, то рекомендується ініціалізувати _org.slf4j.Logger_ та використовувати його методи
* Додатково важливо перевірити, що в процесі логування не використовується жодна персональна чи конфіденційна
інформація

[#_bp_14]
== BP-14. Авторизаційні токени для викликів зовнішніх сервісів
IMPORTANT: Критичність: висока

.Опис
В регламенті реєстру, а зокрема в файлах бізнес-процесу (BPMN) не повинно бути жодних авторизаційних токенів чи паролів
для викликів зовнішніх сервісів.

.Вплив
Регламент реєстру не є захищеним сховищем і зберігання токенів в ньому може призвести до їх витоку і використання
третіми особами.

.Рекомендації
Всі авторизаційні токени для викликів зовнішніх сервісів повинні бути зареєстровані відповідно до xref:arch:architecture/platform/administrative/control-plane/platform-evolution/registry-regulation-secrets.adoc[документу]

[#_bp_15]
== BP-15. Таймери на користувацьких задачах
IMPORTANT: Критичність: висока

.Опис
При роботі з бізнес-процесами реєстру відповідальні особи працюють з користувацькими задачами (user task), які були на
них призначені і які з тих чи інших причин можуть бути виконані та забуті. Одним з можливих рішень є використання
таймерів з автоматичним завершенням бізнес-процесу

.Вплив
Велике накопичення відкритих бізнес-процесів через користувацькі задачі, які вже не будуть виконані призводить до
безпотрібного навантаження на систему та використання її ресурсів та необхідності виконання додаткових операцій по
видаленню запущених бізнес-процесів

.Рекомендації
На користувацьких задачах, що потенційно можуть бути забуті, рекомендується використовувати timer boundary event, який
по закінченню налаштованого часу автоматично буде переривати виконання бізнес-процесу та призводити до його завершення.
Додатково можна розглянути виділення критичних секцій в підпроцеси і використання такого роду івентів на них.

NOTE: Про використання timer boundary event можна ознайомитись https://docs.camunda.org/manual/7.19/reference/bpmn20/events/timer-events/#timer-boundary-eventх[за посиланням]

[#_bp_16]
== BP-16. Зменшення дублікації коду
IMPORTANT: Критичність: середня

.Опис
Уникати дублювання однакових послідовностей блоків при моделюванні бізнес-процесів

.Вплив
* Ускладнення візуального сприйняття бізнес-процесу
* Збільшення часу на розробку та тестування бізнес-процесу
* За потреби внесення змін в одну з послідовностей блоків, необхідно буде вносити зміни в усі блоки, що дублюються
* Збільшення ймовірності допускання помилок при внесенні змін

.Рекомендації
* Винести спільну логіку в окремий підпроцес
* Видалити блоки, що дублюються та викликати підпроцес за допомогою call activity
* В окремих випадках можна також уникнути дублювання шляхом рефакторингу логіки бізнес-процесу об'єднання різних гілок
виконання

NOTE: Детальніше про під-процеси можна ознайомитись в https://docs.camunda.org/manual/7.19/reference/bpmn20/subprocesses/call-activity/[офіційній документації] та
https://youtu.be/l4w1n2KUR6Q?t=565&si=q2Qb7bK6Wg8b1iNO[відео]

[#_bp_17]
== BP-17. Робота з бізнес-ключами
IMPORTANT: Критичність: середня

.Опис
Задавати бізнес-ключ бізнес-процесу (business key) якомога раніше в процесі його виконання

.Вплив
* Наявність бізнес-ключа спрощує пошук та фільтрацію бізнес-процесів:
** В операційній базі даних _Camunda_ при наявності помилок виконання
** В історичній базі даних _Camunda_ при завершенні бізнес-процесу
* Якщо бізнес-ключ встановлюється в кінці виконання бізнес-процесу в одній з гілок, то можливі наступні проблеми:
** При виникненні помилки до встановлення бізнес-ключа, бізнес-процес не буде його мати
** Можливо забути встановити бізнес-ключ в одній з гілок
** Потенційне дублювання коду для встановлення бізнес-ключа в кінці кожної з гілок
(див. <<_bp_16>>)
* Наявність контекстної інформації в бізнес-ключі спрощує ідентифікацію потенційних проблем при виконанні бізнес-процесу.

.Рекомендації
* Встановлювати бізнес-ключ відразу після можливості його визначення
* В бізнес-ключ можна передавати інформацію про контекст бізнес-процесу, наприклад, номер заявки, номер договору або
параметри з якими був запущений бізнес-процес чи виконана користувацька задача

NOTE: На момент написання статті окремого способу зберегти додаткову контекстну інформацію про бізнес-процес для подальшого
збереження в історичну таблицю не існує

[#_bp_18]
== BP-18. Історичні події для високонавантажених бізнес-процесів
IMPORTANT: Критичність: висока

.Опис
При виконанні бізнес-процесів для нього зберігаються історичні події пов'язані з його проходженням, такі як виконання
задачі, зберігання окремих видів змінних тощо. Процес зберігання історичних подій може суттєво навантажувати систему
і навіть бути причиною помилок, якщо кількість таких процесів є досить великою. Рекомендується відповідним чином адаптувати
бізнес-процес, якщо прогнозується високе навантаження на нього.

.Вплив
* Додаткове навантаження на _Підсистему асинхронного обміну повідомленнями_ та _Сервіс фіксації історичних подій_ через
велику кількість історичних подій в процесі виконання бізнес-процесів, що призводить до збільшення часу затримок і
відмови окремих компонентів системи
* Додаткове навантаження на _Підсистему управління реляційними базами даних_, що можуть призвести до відмови ключових
сервісів, таких як _Сервіс виконання бізнес-процесів_, що практично повністю блокує роботу реєстру

.Рекомендації
* Ідентифікувати бізнес-процеси, для яких планується високе навантаження (понад 50 тисяч запусків на день)
* Для таких бізнес-процесів провести наступні оптимізації, які можуть суперечити іншим рекомендаціям з цього розділу:
** Мінімізувати кількість задач, що виконуються в процесі виконання бізнес-процесу. Розглянути можливість заміни
скриптових задач на _Execution Listener_ або використання _Expression Language_ для створення змінної безпосередньо
в місці її використання
** Розглянути відмову від використання підпроцесів і перенесення логіки в тіло основного бізнес-процесу
** Відмовитись від використання бізнес-ключів та встановлення результату бізнес-процесу. Для автоматичних бізнес-процесів
та бізнес-процесів, що запускаються зовнішніми системами - це обов'язковий пункт