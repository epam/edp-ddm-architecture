:toc-title: ЗМІСТ
:toc: auto
:toclevels: 5
:experimental:
:important-caption:     ВАЖЛИВО
:note-caption:          ПРИМІТКА
:tip-caption:           ПІДКАЗКА
:warning-caption:       ПОПЕРЕДЖЕННЯ
:caution-caption:       УВАГА
:example-caption:           Приклад
:figure-caption:            Зображення
:table-caption:             Таблиця
:appendix-caption:          Додаток
:sectnums:
:sectnumlevels: 5
:sectanchors:
:sectlinks:
:partnums:

= Міграція реєстрів

== Позначення та скорочення

* [.underline]#Кластер А# -- кластер, на якому розгорнуто наявний реєстр.
* [.underline]#Кластер B# -- кластер, куди буде перенесено наявний реєстр (цільовий кластер).

NOTE: Міграція реєстру виконується з останньої резервної копії наявного реєстру та, відповідно до інструкції, буде переноситися із кластера А до кластера B й відновлюватися вже на цьому кластері.

== Передумови для міграції

. Користувач, який буде переносити реєстр на інший кластер, повинен бути доданий в адміністратори платформи на обох кластерах через *`control-plane-console`*.
+
TIP: Див. детальніше -- xref:admin:registry-management/control-plane-assign-platform-admins.adoc#add-platform-admin-cp[Створення адміністратора платформи].
. На кластері, на який переноситься реєстр, повинна бути розгорнута та версія платформи, у якої версія `control-plane-gerrit` буде дорівнювати версії самого реєстру (наприклад, версія платформи -- *`1.9.4.11`*, версія реєстру -- *`1.9.4.7`*, версія `control-plane-gerrit` – *`1.9.4.7`*). Цю версію можна перевірити наявністю гілки у репозиторії *`cluster-mgmt`* в центральному *Gerrit*. Якщо гілка з версією реєстру існує, то версію реєстру можна переносити на кластер B. Якщо ні, то існує два шляхи:

* Оновити платформу на кластері B, яка буде відповідати версії самого реєстру.
* Оновити реєстр на кластері A до версії, яка вже існує на кластері B.

. Одночасний доступ до кластера А та кластера B.

. Наявність наступних команд в Terminal:

* `oc`
* `velero`
* `rclone`
* `vault`

. Стабільне з'єднання з інтернетом. _Чим більша пропускна здатність, тим швидше буде проходити міграція_. В іншому випадку, можна використовувати *jumpbox* (із доступом до обох кластерів), який знаходиться або в AWS, або в іншого cloud-провайдера. Використання jumpbox зменшить час перенесення резервної копії з одного кластера на інший.

[NOTE]
====
Якщо використовується *jumpbox* то треба перевірити доступ до платформених Minio/Vault з IP адреси *jumpbox*. Для отримання IP *jumpbox* виконайте наступну команду:
----
ssh sshmyip.com
----
Та перевірити в Openshift-консоль -> Project -> control-plane -> Networking -> Routes -> platform-minio aбо platform-vault наявність IP адреси в annotations:
----
  annotations:
    haproxy.router.openshift.io/ip_whitelist: <IP jumpbox>/32,....
----
У випадку відсутності ресурсів в Openshift Console, прийти з допомогою до L2 команди для перевірки доступу.
====

== Підготовка реєстру до міграції

. Зробіть резервну копію реєстру на кластері A.
+
Перед перенесенням реєстру на новий кластер, необхідно запустити Jenkins-процес *`Create-registry-backup-<назва реєстру>`*.
+
Якщо Jenkins pipeline завершився зі статусом *`Success`*, то резервна копія виконана успішно.
+
[NOTE]
====
Для отримання назви резервної копії, треба перейти в logs останього запуску Jenkins pipeline (Console Output), та по пошуку на сторінці знайти cхоже повідовлення:

----
[INFO] Velero backup - <назва реєстру>-<час> done with Completed status
----
як приклад:

----
[INFO] Velero backup - abc-02-2023-04-18-19-03-14 done with Completed status
----
де *abc-02-2023-04-18-19-03-14* назва резервої копії

====
+
[WARNING]
====
Для версій реєстру < 1.9.3 необхідно виконати у Terminal наступну команду:

----
velero backup describe <назва бекапу>
----

Назву бекапу можна знайти в логах останнього запуску Jenkins-процесу *`Create-registry-backup-<назва реєстру>`*.
====
+
[TIP]
====
Детальніше про створення резервних копій та відновлення реєстрів див. у розділі xref:backup-restore/overview.adoc[].
====

. Якщо останній velero backup завершився зі статусом *`Completed`*, то можна переходити далі. У випадку, коли статус velero backup відрізняється від `Completed`, необхідно долучати спеціалістів із технічної підтримки L2-L3 для перевірки працездатності Jenkins-пайплайну.

. Забороніть робити зміни у реєстрі за допомогою Jenkins пайплайнів.
+
У кожному пайплайні для реєстру перейдіть до секції *Configure* та знайдіть параметр *`Disable this project`* у секції *Build Triggers*, встановіть напроти нього прапорець та збережіть зміни за допомогою кнопки kbd:[*Save*].

== Міграція резервної копії із кластера А до кластера B

. Отримайте логін-команди для обох кластерів.
+
Для цього виконайте вхід до Openshift-консолі та у правому верхньому кутку, натисканням на свій username, перейдіть до *`Copy login command`*, скопіюйте токен доступу у полі *`Log in with token`* та збережіть його у текстовому редакторі.

+
NOTE: Операцію потрібно повторити для обох кластерів: А та B.

. Отримайте назву останньої резервної копії, яка була створена на кластері А (наприклад, `abc-02-2023-04-18-19-03-14`).

. Відкрийте термінал та виконайте наступні команди:
+
.Експорт логіну для кластера А
----
export A_CLUSTER_LOGIN="oc login --token …"
----
+
Вставте між лапок *`"..."`* після `--token` отриману в пункті 1 команду логіну для кластера А. В кінці логін-команди не повинно бути перенесення на наступний рядок.

+
.Експорт логіну для кластера В
----
export B_CLUSTER_LOGIN="oc login --token …"
----
+
Вставте між лапок *`"..."`* після `--token` отриману в пункті 1 команду логіну для кластера В. В кінці логін-команди не повинно бути перенесення на наступний рядок.

+
.Експорт назви реєстру
----
export REGISTRY_NAME="<назва реєстру>"
----
+
TIP: Приклад назви реєстру: `*abc-02*`.

+
.Експорт назви резервної копії
----
export BACKUP_NAME="<назва резервної копії>"
----
+
TIP: Приклад назви резервної копії: `*abc-02-2023-04-18-19-03-14*`.

. Збережіть link:{attachmentsdir}/migrate-registry/registry-migration.zip[архів], розархівуйте його в нову директорію наступною командою:
+
----
unzip registry-migration.zip -d registry-migration
----
+
Перейдіть в директорію registry-migration (`cd`) та виконайте команду:
+
----
chmod +x && ./migration.sh
----

. Після виконання скрипту, виконайте логін у терміналі за допомогою *oc cli* на кластері B, та перевірте наступне:

* Наявність velero backup на кластері B.
* Наявність директорій із назвою _keycloak-export-<назва реєстру>-*_ у папці, де знаходиться скрипт.

== Підготовка до відновлення на кластері B

. Перенесіть реалми.
+
Для перенесення реалмів, виконайте вхід до Keycloak на кластері B:

* В Openshift-консолі знайдіть проєкт (namespace) *`user-management`*, відкрийте *Networking* > *Routes* та перейдіть за посиланням до сервісу *`keycloak`*.
+
TIP: Дані для логіну можна отримати із секретів keycloak у тому ж проєкті. Для цього перейдіть до Workloads > Secrets, знайдіть у пошуку секрет із назвою *`keycloak`*, та у розділі Data скопіюйте дані для входу до сервісу.

* За допомогою `*Select realm*` (1) > *`Add realm`* (2) > *`Import`* (3), виберіть файл _keycloak-export-<назва реєстру>-*/*-realm.json_ та створити реалми(стратегію обирати SKIP). Так пройдіться по усіх директоріях із назвою _keycloak-export-<назва реєстру>-*_.

+
image:admin:migrate-registry/migrate-registry-1.png[image,width=514,height=194]

. Перенесіть користувачів.
+
Залишаючись в адмін-консолі Keycloak, перейдіть до реалму (1), який був створений за допомогою імпорту, та у лівому меню реалму оберіть  *`Import`* (2)(прим Import стратегію обирати SKIP), далі натисніть *`Select file`* (3) та виберіть файл із директорії _keycloak-export-<назва реєстру>-<ім’я реалму>/<ім’я реалму>-users-*.json_.
+
NOTE: Якщо файлів більше одного, то виконайте імпорт усіх файлів.

+
image:admin:migrate-registry/migrate-registry-2.png[image,width=601,height=417]

. Створіть реєстр через *`control-plane-console`*.

* Створіть реєстр з тим же ім'ям, і такою ж версією на кластері B. При створенні реєстру призначте усіх адміністраторів, що були у реєстрі на кластері A, та вкажіть актуальні дані.
+
NOTE: Дані про ключ - поля заповнювати або з актуальними ключами для цього реєстру, або використовувати тестові ключі, в майбутньому після міграції інформацію про ключі можна актуалізовати через Control-plane-console. За даними для ключів звертатись до L2-L3 сапорту
+
[NOTE]
====
Шаблон реестру - обирати такий самий як і шаблон цього реєстру на кластері A. Для отримання назви шаблону треба перейти в Openshift-консоль -> Projects -> control-plane -> Api Explorer -> В пошуку задати codebase -> Перейти на codebase -> Instances -> Відкрити codebase <назва реєстру> -> і перевірити наступне поле( приклад):
----
metadata:
  annotations:
    registry-parameters/template-name: templates/registry-tenant-template-minimal
----
де *templates/registry-tenant-template-minimal* - назва шаблону
====
+
NOTE: Якщо функціональність консолі дозволяє додати DNS для keycloak або порталів, на цьому етапі необхідно пропустити цей крок, адже трафік поки налаштований на кластер A).

* Після створення одразу перейдіть до Jenkins (namespace *`control-plane`* > *Networking* > *Routes* > *`jenkins`*), та зупиніть першу збірку *`MASTER-Build-<назва реєстру>`*.
+
NOTE: Треба дочекатись створення директорії <назва реєстру> та створення Jenkins pipeline, після запуску одразу зробити Abort білда.

. Перевірка наявності `*CustomResourceDefintition*`.
+
[WARNING]
====
Якщо до цього на кластері не було жодного реєстру, обов'язково перевірте наявність існування *`CustomResourceDefintition`*. Для цього виконайте логін через *`oc cli`* на кластері B та виконати наступну команду:

----
oc get customresourcedefinition ingressclassparameterses.configuration.konghq.com
----

Якщо команда завершиться з помилкою та видасть у консолі *`No resources found`*, то перейдіть до директорії, де знаходиться скрипт *_migration.sh_*, та з кореневого шляху виконайте наступну команду:

----
for file in $(ls crds); do oc apply -f crds/$file; done
----
====

== Відновлення реєстру на кластері B

. Відрийте до Jenkins (namespace *`control-plane`* > *Networking* > *Routes* > *`jenkins`*), перейдіть до папки із назвою реєстру та запустіть Jenkins-пайплайн *`Restore-registry-<назва реєстру>`*. Після запуску пайплайну оберіть версію( на етапі cleanup-registry-before-restore ) та дочекатися, коли процес завершиться.
+
NOTE: У випадку, коли процес завершується помилкою або триває понад 1-2 години, зверніться до спеціалістів команди технічної підтримки L2-L3 "ЕПАМ".

. Після завершення пайплайну перейдіть в Openshift-консоль -> Projects -> <назва реєстру>, та первірте що нема под в статусі помилок.
+
[NOTE]
====
У випадку коли пода з назвою bpms-* зі статусом помилки, треба виправити паролі в postgres для operational-instane та analytical-instance под, для цього треба:

- Перейти в Openshift-консоль -> Secrets, знайти secret для operational-instance - operational-pguser-postgres(для analytical-instance - analytical-pguser-postgres)
- Перейти в Secret та скопіювати поле password.
- Перейти в Openshift-консоль -> Pods -> знайти поду operational-instance/analytical-instance та виконати наступні команди
+
----
psql
----
+
----
ALTER ROLE postgres WITH PASSWORD '<password>';
----
+
де <password> - поле password скопійоване з Secret для відповідного інстанса - operational/analytical.

- Після цих операцій видалите поду bpms та дочекайтесь коли вона буде в статусі Running.
====
+
[NOTE]
====
У випадку коли пода registry-rest-api запускається з помилкою ImagePullBackOff. Треба додати IP кластеру B в антоції Openshift Route -> Nexus.

- Для цього перейдіть в Openshift-консоль -> Project -> <назва реєстру> -> Routes -> Nexus -> YAML та перевірте настпне поле в YAML
+
----
metadata:
  annotations:
    haproxy.router.openshift.io/ip_whitelist: <NAT Cluster IP>/32,....
----
+
Якщо IP адреса кластеру B відсутня додайте ії в *haproxy.router.openshift.io/ip_whitelist* з маскою /32

====
+
. Після перевірки що усі поди в статусі Running треба перенести конфігурацію реестру в values.yaml/values.gotpl
+
- Залогінитись в control-plane-gerrit(Openshift-консоль -> Projects -> control-plane -> Networking -> gerrit -> Логін через openshift-sso). В Gerrit перейти в Browse -> Repositories, та вибрати репозиторій <назва реєстру> та через commands -> Create change та створити сhange з наступними параметрами: Select branch for new change: master, Description: Update registry after migration. Після створення change, в самому change натисніть Edit.
- Додати конфігурацію vault в values.gotmpl. Для цього візьміть актуальну конфігурацію vault з config-map hashicorp-vault-config (Openshift-консоль -> Projects -> <назва реєстру> -> Workloads -> ConfigMaps -> hashicorp-vault-config) та скопіюйте поле як в пркиладі:
+
----
ui = true

listener "tcp" {
  tls_disable = 1
  address = "[::]:8200"
  cluster_address = "[::]:8201"
}
storage "file" {
  path = "/vault/data"
}
seal "transit" {
   address         = "https://<vault url>"
   disable_renewal = "false"
   key_name        = "<key name>"
   mount_path      = "transit/"
   tls_skip_verify = "true"
}
----
Де <vault URL> - лінка на vault, <key name> - назва ключу (в конфігурації з config-map будуть актуальні поля). Далі в change нажміть ADD/OPEN/UPLOAD та в пошуку вбийте values.gotmpl в пошуку та виберіть потрібний файл. В самому файлі додайте конфігурацію як на прикладі:
+
----
vault:
  platformVaultToken: {{ env "platformVaultToken" }}
  openshiftApiUrl: {{ env "openshiftApiUrl" }}
  centralVaultUrl: {{ b64dec $centralVaultUrl }}
  server:
    dataStorage:
      storageClass: ocs-storagecluster-ceph-rbd
    auditStorage:
      storageClass: ocs-storagecluster-ceph-rbd

    standalone:
      config: |
       ui = true

       listener "tcp" {
         tls_disable = 1
         address = "[::]:8200"
         cluster_address = "[::]:8201"
       }
       storage "file" {
         path = "/vault/data"
       }
       seal "transit" {
          address         = "https://<vault url>"
          disable_renewal = "false"
          key_name        = "<key name>"
          mount_path      = "transit/"
          tls_skip_verify = "true"
       }
----
Після додавання натисніть Save.

- Зміни розміру kafka дисків. Залишаючись в цьому файлі, знайдіть поле:
+
----
    storage:
      zookeeper:
        size: 5Gi
      kafka:
        size: 20Gi
----
Та треба замінити розмір kafka.size, відповідно розміру актуального диску в Openshift-консолі(Openshift-консоль -> Project -> <назва реєстру> -> Storage -> PersistentVolumeClaims ) в пошуку знайти *data-0-kafka-cluster-kafka-0* та його Capacity. Повернутись до редагування values.gtmpl та виправиити:
+
----
    storage:
      zookeeper:
        size: 5Gi
      kafka:
        size: 40Gi
----
Де 40Gi - актуальний розміп диску з Capacity.

- Видалити усіх GerritGroupMember. Треба бути залогіненим у кластер B через ос та виконати наступну команду:
+
----
oc -n <назва-реєстру> delete gerritgroupmember --all
----


. Запустіть Jenkins-процес *`MASTER-Build-<назва реєстру>`*.
. Після з завершення Jenkins-пайплайну *`MASTER-Build-<назва реєстру>`*, виправте Jenkins Credentials у Jenkins реєстру.
+
[NOTE]
====
У випадку, коли доступу немає, додайте себе як адміністратора реєстру через control-plane-console.
====
* Для цього перейдіть в Openshift Project > <назва реєстру> -> Workloads > Secrets > gerrit-control-plane-sshkey та скопіюйте поле *`id_rsa`*.

* Після цього перейдіть у реєстровий Jenkins (*Networking* > *Routes* > `*jenkins*`) > Manage Jenkins > Manage Credentials > *`gerrit-ci-users-sshkey`* (*`gerrit-control-plane-sshkey`*) > натисніть *`Update`*.

* У полі *`Private Key`* за допомогою *`Replace`* вставте скопійоване значення.

. Оновіть посилання на Nexus у репозиторії регламенту.
+
Для цього перейдіть до Openshift-консоль -> Project -> <назва реєстру> -> Gerrit, та виконайте логін.
+
Далі перевірте наявність доступу до проєктів у Gerrit та клонуйте локально репозиторій *_registry-regulations_*. Для цього:

* У вебінтерфейсі Gerrit, перейдіть у налаштування > *HTTP Credentials* > згенеруйте новий пароль за допомогою `*Generate New Password*`, та збережіть цей пароль у нотатках.

* Перейдіть до репозиторію *`registry-regulations`* > та скопіюйте команду  для клону *Anonymous HTTP* > *`Clone with commit-msg hook`*. +

* Вставте команду для клону репозиторія до термінала та виконайте. Команда запитає логін та пароль. Логін в цьому випаду буде ваш email, а пароль -- той, який ви згенерували у першому підпункті.
+
[NOTE]
====
Якщо в системі git user відрізняється від вашого юзера на сервері Gerrit, треба виконати наступні команди:
----
git config --global user.name "New Author Name"
git config --global user.email "<email@address.example>"
----
як приклад
----
git config --global user.name "Jonh Doe"
git config --global user.email "jong_doe@doemail.com"
----
====

. Змініть мінорну версію в settings.yaml в рутовій директорії репозиторію registry-regulations згідно з приладом:
+
----
settings:
  general:
    package: ua.gov.mdtu.ddm.dataplatform.template
    register: registry
    version: 2.21.0
----
Як приклад замінити додати до версії +1
+
----
settings:
  general:
    package: ua.gov.mdtu.ddm.dataplatform.template
    register: registry
    version: 2.21.1
----

. Замініть згадування DNS кластера А на кластер B. Для цього у терміналі перейдіть до директорії *_registry-regulations/data-model_*
+
----
cd registry-regulations/data-model
----
Та виконайте наступну команду по заміні DNS:
+
----
find "." \( -type d -name .git -prune \) -o -type f -print0 | xargs -0 sed -i -e  's/<Cluster A DNS wildcard> /<Cluster B DNS Wildcard> /g'
----
+
[TIP]
====
`Cluster A DNS wildcard/Cluster B DNS wildcard` -- це *`apps.*`* (наприклад, `*apps.reestr1.eua.gov.ua*`).
Як повинно виглядати sed правило:
----
's/apps.cluster-a.dns.wildcard.com/apps.cluster-b.dns.wildcard.com/g'
----
====

. Виконайте commit змін та push до репозиторію:
+
[source,git]
----
git add .
----
+
[source,git]
----
git commit -m "Update nexus URL"
----
+
[source,git]
----
git push origin refs/heads/master:refs/for/master
----

. Перейдіть у реєстровий Gerrit, проставте відмітки *`Code-Review +2`*, та за допомогою кнопки kbd:[*Submit*] застосуйте зміни до master-гілки.

. Після внесення змін до master-гілки перейдіть до Jenkins реєстру та перевірте, що Jenkins-пайплайни у Jenkins Folder *registry-regulations* завершилися зі статусом *`Success`*.

== Перевірка реєстру

. Переконайтеся, що Кабінети користувачів працюють у штатному режимі, та бізнес-процеси мігрували успішно.

. Усі Jenkins pipeline мають завершитися зі статусом *`Success`*.

NOTE: У випадку будь-яких проблем із міграцією, зверніться до Anatolii_Stoliarov@epam.com.
