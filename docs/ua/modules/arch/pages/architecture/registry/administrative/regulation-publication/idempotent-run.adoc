= Ідемпотентне розгортання регламенту

== Загальний опис

На етапі розгортання регламенту кроки запускаються лише якщо було внесено зміни в рамках останнього коміту. Таким чином якщо при попередньому запуску пайплайна крок був не успішним, а в поточному коміті зміни не було внесено, то крок буде проігноровано і відмічено як успішний.


== Функціональні сценарії

* Порівняння поточного стану регламенту з станом регламенту при останньому успішному виконанні кроку.
* Збереження стану регламенту в секрет.
* Розгортання регламенту з примусовим викликом всіх кроків (_FULL_DEPLOY_)

== Ролі користувачів

* Моделювальник

== Загальні принципи та положення


* Для визначення чи необхідно виконувати той, чи інший крок, відбувається перевірка поточного стану регламенту з станом регламенту на момент останнього успішного виконання кроку.
* Перевірка залежних файлів відбувається для кожного кроку окремо і фіксується лише для конкретного кроку, таким чином при обробці файлів які використовуються у декількох кроках не буде хибних записів про успішність опрацювання цих файлів.
* Чек-суми по кроках зберігаються в секреті як `JSON`
* Управління секретом відбувається за допомогою _k8s API_


== Високорівневий дизайн рішення

Розширення застосунку командного рядка `registry-regulations-cli` двома командами
`save` для підрахунку чек-сум всіх перелічених файлів та збереження значень у секрет `k8s` і `plan` для перевірки стану і необхідності запуску кроку розгортання.

== Низькорівневий дизайн сервісів

[source, shell]
----
registry-regulations-cli [command] [options]

COMMANDS:
    validate - валідація регламенту на наявність помилок
    plan - перевірка чи необхідні якісь дії для приведення реєстру до стану описаному в регламенті, в рамках окремої бізнес операції.
    save - збереження чек-суми частини регламенту повязаної з бізнес операцією до k8s секрету.
----


[source, shell]
----
registry-regulations-cli [plan|save] [parameter] [options]

Приймає як параметер, логічна назва складової регламенту.

OPTIONS:
    --file - перелік папок і файлів
    --file-detailed - перелік папок і файлів з детальною інформацією про них

----
=== Перевірка стану регламенту і необхідності запуску кроку розгортання

.Приклад використання на пайплайні розгортання
[source, bash]
----
registry-regulations-cli plan data-model --file registry-regulations/data-model/ registry-regulations/settings.yaml
----

Вихідним параметром виконання команди з флагом --file є _boolean_ флаг чи відрізняються файли які були використанні при виконанні даного кроку від поточного стану.
Вихідним параметром виконання команди з флагом --file-detailed є список файлів з переданого списку, які відрізняються від поточного стану.

Правила коли необхідно повторно виконати крок:

* В секреті відсутній крок з таким ім'ям
* Чек-сума для хоча б одного з перелічених файлів відрізняється від чек-суми збереженої в секреті.
* Інформація про чек-суму файла відсутня у секреті.

=== Збереження стану регламенту після успішного виконання кроку

.Формат виклику команди збереження стану файлів для кроку розгортання регламенту.
[source, bash]
----
registry-regulations-cli save ${group-name} --file %{dir1} %{dir2/subDir1} ${fileName}
----

.Приклад
[source, bash]
----
registry-regulations-cli save  data-model --file registry-regulations/data-model/ registry-regulations/settings.yaml
----

у разі успішного виконання кроку стан зберігається в секреті `registry-regulation-state` у форматі
data.group-name: {value json}

.Структура збереження стану регламенту в секреті.
[source, yaml]
----
data:
  upload-global-vars-changes: '{ "global-vars" : "...(SHA256)"}'
  create-keycloak-roles: '{
    "roles/officer.yml" : "...(SHA256)",
    "roles/citizen.yml" : "...(SHA256)"
    }'
  upload-business-process-changes:  '{
  "bpmn/bp-1.bpmn" : "...(SHA256)",
  "bpmn/bp-2.bpmn" : "...(SHA256)"}'
  other-steps: '...'
----

Для підрахунку чексуми файлів використовується алгоритм _SHA256_ `MessageDigest digest = MessageDigest.getInstance("SHA-256");`

== Високорівневий план розробки

=== Технічні експертизи

* BE

=== План розробки

* Перейменування репозиторію застосунку для валідації.
* Винесення операції для валідації в окрему команду _validate_.
* Додавання команди для збереження стану регламенту в секрет `registry-regulation-state`
* Додавання команди для перевірки стану регламенту зі збереженим станом.
* Зміна команд валідації регламенту.
* Зміна перевірки на необхідність запускання всіх кроків пайплайну розгортання регламенту.