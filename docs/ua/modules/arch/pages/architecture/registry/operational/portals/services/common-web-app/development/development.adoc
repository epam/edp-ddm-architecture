= Розробка

Монорепозиторій налаштовано для використання у середовищі NodeJS LTS-версій (від 14.5.0 або 16.x.x) разом із npm версій 7+. Колишні окремі репозиторії перенесено у окремі директорії, які зібрані у рамках директорії `/packages/`. Компоненти з бібліотеки веб-компонентів при використанні у рамках коду порталів не потребують окремої збірки та створення артефактів, а імпортуються напряму під час збірки відповідних порталів. Для управління залежностями та скриптами активно використовуються можливості https://docs.npmjs.com/cli/v8/using-npm/workspaces[npm workspaces].

== Встановлення пакетів у монорепозиторії

Для встановлення пакетів в рамках монорепозиторію не варто інсталювати їх із директорії кожного з вкладених пакетів; натомість їх варто встановлювати з корневої директорії із застосуванням ключів `-w`/`--workspace`/`-ws`/`--workspaces` відповідно до того, як це описано у документації щодо використання workspaces, вказуючи у якості воркспейсів шляхи до директорій з пакетами (як от `-w packages/portal-admin` тощо). В даному випадку npm самостійно вирішує, де розміщати пакети - у кореневому `node_modules` чи у вкладеному `node_modules` відповідного пакету. У разі, якщо всюди версія залежності збігається, то вона може бути розміщена в кореневому `node_modules` з метою дедуплікації. І навпаки, якщо версія однієї й тої самої залежності відрізняється між пакетами, то файли цих версії цього пакету можуть бути розміщені у вкладених `node_modules`. В більшості випадків імпорт із пакетів залежностей у вихідному буде правильно відпрацьовувати та знаходити потрібне джерело.

Важливо звернути увагу: у вкладених пакетах відсутні окремі файли `package-lock.json`. Натомість існує єдиний кореневий файл `package-lock.json`, який містить інформацію про усі залежності як і кореневого пакету, так і вкладених.

Також через відсутність залежності `mdtu-web-components` (бо вона тепер є частиною монорепозиторію) відсутня потреба у використанні Nexus-регістру пакетів, є можливість використовувати звичайний стандартний регістр npm.

== Виконання інших команд у репозиторії

Основні команди винесені скриптами у коренів монорепозиторію. В більшості випадків вони є псевдонімами для аналогічних команд із ключами `--workspaces` та `--if-exists`.

== Використання аліасів для правильного імпорту між пакетами

Оскільки замість імпорту із зовнішнього пакету `mdtu-web-components` імпорт компонентів виконується із сусіднього підпакету `packages/web-components`, то сама назва `#web-components` сконфігурована у пакетах порталів у якості відповідного аліасу для імпорту. Особливості конфігурації будуть описані далі.

Варто зазначити, що всередині підпакету `packages/web-components` внутрішні імпорти так само наразі використовують цей аліас; в інакшому випадку виникали би помилки збірки порталів через те, що деякі шляхи у підпакетах порталів та компонентів збігаються.

У майбутньому для існуючих або нових підпакетів можуть бути додані нові додаткові аліаси (як от `#shared/` тощо).

== Особливості конфігурації tsconfig для усіх пакетів

Директиви, які повторюються в усіх конфігах, було винесено у кореневий файл `tsconfig.react.json`. Також кожен із пакетів має власний файл `tsconfig.paths.json`, який наслідує кореневий конфіг та визначає аліаси для TS через директиву `paths`, а також вказують, що з підпакету `web-components` можливий імпорт через спеціальну директиву `references`.

В свою чергу файли `tsconfig.paths.json` наслідуються кінцевими файлами `tsconfig.json`. Це необхідно тому, що `react-scripts` схильні переписувати файл `tsconfig.json` у разі, якщо він знаходить там певні "проблеми" (які вирішуються сторонніми інструментами). Так, під час кожного запуску, `react-scripts` видаляє директиву `paths` із `tsconfig.json` та вказує попередження, що він "не підтримує" цю директиву. Саме тому вона схована у окремому файлі, який потім наслідується основним конфігом, для того, щоби `react-scripts` не міг видалити цю необхідну директиву.

Також усі підпакети, з яких відбувається імпорт до сусідніх підпакетів (`web-components`, та, можливо, в майбутньому інші підпакети) вимагають додавання директиви `composite` із значенням `true`, яка позначає, що з цей пакет може бути доступний для імпорту іншими пакетами, які, в свою чергу, звертаються до нього за допомогою директиви `references`.

== Особливості налаштування збірки веб-компонентів за допомогою rollup

У файлі `rollup.config.js` у директорії підпакету веб-компонентів додано аліас `#web-components` для коректної збірки підпакету веб-компонентів.

== Особливості налаштування Jest для тестування веб-компонентів

У файлі `jest.config.js` у директорії підпакету веб-компонентів додано аліас `#web-components` (у форматі регулярного виразу) для коректного тестування підпакету веб-компонентів.

== Особливості налаштування збірки та тестування React-додатків у порталах

Оскільки за замовчанням `react-scripts` використовують під капотом `webpack` для збірки та `jest` для тестування, але не дають прямого доступу до конфігурації цих інструментів, то у рамках підпакетів порталів натомість використовується пакет `@craco/craco`, який розширяє можливості `react-scripts` та дає ширші можливості управління конфігураціями відповідних інструментів.

У рамках підпакетів створено відповідні файли конфігурації `craco.config.js`, які, в свою чергу, для побудови конфігурації використовують функцію побудови базової спільної конфігурації, що імпортується із кореневого файлу `craco-base-config.js`.

У рамках цієї базової конфігурації відбувається розширення конфігурації `webpack`, а саме додано аліаси `#web-components` та `#shared`, а також виконується відключення плагіну `react-dev-utils/ModuleScopePlugin`, який обмежував би можливість імпорту із сусідніх директорії (як от `packages/web-components`).

Також у рамках цієї базової конфігурації відбувається розширення конфігурації Jest. Додано аліас `#web-components` та `#shared` для коректних імпортів під час тестування.

У npm-скриптах порталів виклик програми `react-scripts` замінено на виклик програми `craco` із збереженням аргументів.

== Особливості налаштування ESLint

ESLint та його плагіни винесено у якості кореневих залежностей. Додано кореневий `.eslintrc.js` для лінтингу різних службових скриптів монорепозиторію. У самих же підпакетах додано директиву `root: true`, яка дозволяє уникати помилок через розбіжності із кореневим конфігом.

== Імпорт стилів веб-компонентів у рамках порталів

Замість імпорту зібраного css-файлу стилів із зовнішнього артефакту у коді `App.scss` виконується імпорт вихідних кодів стилів (CSS-in-JS) у коді `App.tsx`. Цей крок був необхідних задля уникнення помилок із неможливістю розпізнати аліас `~mdtu-web-components` всередині SCSS.

== Залежності для react-scripts

Для уникнення помилок із `react-scripts` точні версії його ключових залежностей збережені у якості залежностей розробки у корні монорепозиторію. Це стосується пакетів `babel-loader`, `jest`, `webpack`.

== Винесення документації в корінь

Окремі директорії `docs` підпакетів винесено та об'єднано у спільну кореневу директорію `docs`.

== Видалення peerDependencies з веб-компонентів

Оскільки веб-компоненти стали підпакетом, то цей підпакет більше не потребує директиви peerDependencies, оскільки в рамках відповідного монорепозиторію підпакети в більшості випадків мають спільні версії природнім шляхом.

== Особливості конфігурації Storybook

У файлі конфігурації `packages/web-components/.storybook/main.js` додано аліаси `#web-components` та `#shared` для коректної побудови сторібуку.

== Особливості конфігурації SonarQube

Для правильної роботи із Sonar у пайплайнах у коренів створено `sonar-project.properties`, який об'єднує основні налаштування із відповідних файлів у підпакетах, включно із винятками, а також перелічує потрібні шлях до вихідних кодів та тестів.

Оскільки існує значна частина коду, яка раніше була продубльована між порталами, то на момент створення репозиторію Sonar показував досить високий показник дублювання (понад 20%). У якості тимчасової міри більшість службових модулів порталів додано у винятки сканування на дублювання за допомогою директиви `sonar.cpd.exclusions`.

Також для виправлення проблеми із некоректною оцінкою покриття коду тестами через Sonar, яка була викликана збігом деякіх шляхів до файлів у рамках підпакетів використані додаткові налаштування для Jest у підпакетах, які вказують повні шляхи до файлів відносно монорепозиторію у згенерованих файлах coverage-звітів.

== Особливості конфігурації образу Docker

Для того, щоби портали коректно розгортались, було додано кореневий `Dockerfile`, який копіює зібрані файли усіх порталів у відповідні директорії образу Docker. Також у корні монорепозиторію додано файл `nginx.conf`, який використовується для правильної конфігурації роутингу між порталами у рамках спільного Docker-образу.

== Нюанси щодо роботи із SVG

На певному невизначеному етапі оновлення ключових залежностей бібліотеки веб-компонентів та порталів з'явилась проблема, що при додаванні SVG-зображень на сторінки вони додавались у тому числі із зайвими атрибутами на кшталт `fill="none"`, що робило ці зображення невидимими. Там, де це було доцільно, заливка елементів векторних зображень була прибрана або замінена на значення `currentColor`.
