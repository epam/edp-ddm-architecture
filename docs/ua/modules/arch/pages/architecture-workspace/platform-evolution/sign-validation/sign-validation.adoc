= Можливість перевіряти валідність підпису КЕП і ким підписано контент, що прийшов в бізнес процес по API

== Загальний опис


При інтеграції зі сторонніми системами на рівні бізнес-процесів є необхідність роботи з підписаними файлами які завантажуються або передаються в бізнес процес цими системами.
А саме, є необхідність впевнитись в цілісності цих файлів шляхом перевірки КЕП накладеного на ці файли. Отримати інформацію про підписанта для подальшої обробки або внесення в реєстри. Також є необхідність перегляду вмісту файлів-контейнерів.

== Функціональні сценарії

* Перевірка даних на відповідність підпису.
* Отримання деталей про підписанта даних.
* Перевірка підпису ASiC контейнеру
* Отримання контенту з даних ASiC-формату

== Ролі користувачів

* Моделювальник

== Загальні принципи та положення

* Дані опрацьовуються в скрипт-задачах бізнес-процесу.
* Отримання даних з сторонніх джерел поза межами цього дизайну.
* Байтові дані між системами передаються закодованими за допомогою Base64
* Формат за замовченням  використовується CAdES-X-Long.
* Імплементація алгоритмів по роботі з підписами відбувається за допомогою `ІІТ`-бібліотеки

== Глосарій та акроніми

*Контейнер* - тип результуючого файлу. Розрізняються такі контейнери XAdES (xml), PAdES (pdf), CAdES (p7s),  ASiC (asic). Найбільш сучасним і рекомендованим  є контейнер типу ASiC. +
*ASiC* - особливістю даного контейнеру є те що він побудований як архів для зберігання файлів і єдиний з перелічених дозволяє зберігати декілька файлів в різних форматах. +
*Формат* - алгоритм який застосовується для підписання даних (XAdES-B-LT/CAdES-X-Long/CAdES-BASE/PAdES-B-LT) рекомендованим форматом є CAdES-X-Long+
*Тип підпису* - розрізняється два типи підпису відокремлений (detached) та enveloped (вбудований). +

[NOTE]
Терміни файл і дані в даному дизайні взаємозамінні.


== Приклади моделювання

=== Приклад моделювання БП з ASiC контейнером в якості вхідного параметра який містить декілька файлів

image:architecture-workspace/platform-evolution/sign-validation/submission_form.png[]

.Приклад скриптової задачі
[source, groovy]
----
def formData = submission('start_event').formData
def file = formData.prop('signed_data').value()


if (!validate(file, SignFormat.ASiC)) {
    println "Invalid signature"
}


def allSignInfo = get_sign_info(file, SignFormat.ASiC).getAllSignInfo()
for (signInfo in allSignInfo) {
    if (signInfo.subjDRFOCode == null) {
        println "DRFO should be present"
    }
}

def allFiles = get_content(file, SignFormat.ASiC).getAllContent()
for (singleFile in allFiles) {
    set_variable(singleFile.getReference(), singleFile.getReferenceData())
}

----

=== Приклад моделювання БП з отриманням p7s контейнера з вбудованим підписом як частина даних із зовнішнього API

image:architecture-workspace/platform-evolution/sign-validation/external_system.png[]

.Приклад відповіді сторонньої системи
[source, json]
----
{
    "name": "Ololow",
    "day-of-birth": "01/01/01",
    "request": "dGVzdCBkYXRh",
    "request_received": "20/02/14"
}
----

.Приклад скриптової задачі
[source, groovy]
----
def data = external_system_response.prop('data').value()
def request = external_system_response.prop('request').value()
if (!validate(request, SignFormat.PKCS7)) {
    println "Invalid signature"
}


def info = get_sign_info(request, SignFormat.PKCS7).getSignInfo()
if (info.subjDRFOCode == null) {
    println "DRFO should be present"
}

originRequestDate = get_content(request, SignFormat.PKCS7).getContent().getData()
set_variable('fileContent', originRequestDate)
----



== validate(<string|data>, <enum|format>)

=== JUEL функція
|===
|Назва параметру |Опис |Тип |Тип даних

|data
|Дані які включають в себе підпис в форматі Base64
|Вхідний
|String

|format
|Перелік доступних для використання типів файлів
|Вхідний
|Enum (ASiC/CAdES)

|isValid
|Результат валідації
|Вихідний
|boolean
|===

=== REST API

_POST /api/signature/validate_

.Приклад тіла запиту
[source,json]
----
{
  "data": "dGVzdCBkYXRh",
  "container": "CAdES/ASiC/XdES/..."
}
----

.Структура тіла відповіді
|===
|Json Path|Тип|Опис

|*$.isValid*
|boolean
|Результат перевірки даних
|*$.error.code*
|String
|Відповідний код статусу
|*$.error.message*
|String
|Деталі та опис помилки
|*$.error.localizedMessage*
|String
|Локалізовані деталі та опис помилки
|===

=== Низькорівневий дизайн

Для валідації підписів ASiC контейнерів відбувається отримання кількості підписантів за допомогою `EndUser::ASiCGetSignsCount(base64Data)`, а далі перевіряється валідність кожного `EndUser::ASiCVerify(index, base64Data)`

Для CAdES використовується `EndUser::VerifyInternal(base64Data)`


== get_sign_info(<string|data>, <enum|dataFormat>)

=== JUEL функція
|===
|Назва параметру |Опис |Тип |Тип даних

|data
|Дані які включають в себе підпис в форматі Base64
|Вхідний
|String

|format
|Перелік доступних для використання типів файлів
|Вхідний
|Enum (ASiC/CAdES)

|signInfo
|Деталі про підпис
|Вихідний
|SignatureInfo
|===


.Структури для отримання контенту в БП
[plantuml]
----
class SignatureInfo {
- List<SignDetails> data
+ Content getSignInfo()
+ List<SignDetails> getAllSignInfo()
}

----
.Структура SignDetails
|===
|Json Path|Тип|Опис

|*issuer*
|String
|
|*issuerCN*
|String
|
|*serial*
|String
|
|*subject*
|String
|
|*subjCN*
|String
|
|*subjOrg*
|String
|
|*subjOrgUnit*
|String
|
|*subjTitle*
|String
|
|*subjState*
|String
|
|*subjLocality*
|String
|Локаль підписанта
|*subjFullName*
|String
|ПІБ підписанта
|*subjAddress*
|String
|Адреса підписанта
|*subjPhone*
|String
|Телефон підписанта
|*subjDNS*
|String
|
|*subjEDRPOUCode*
|String
|ЄДРПОУ підписанта
|*subjDRFOCode*
|String
|ДРФО підписанта
|===

=== REST API

_POST /api/signature/info_

.Приклад тіла запиту
[source,json]
----
{
  "data": "dGVzdCBkYXRh",
  "container": "CAdES/ASiC/XdES/..."
}
----

.Структура тіла відповіді
|===
|Json Path|Тип|Опис

|*$.info[]*
|array[SignatureInfo]
|Масив даних що містить в себе деталі про кожен підпис
|*$.error.code*
|String
|Відповідний код статусу
|*$.error.message*
|String
|Деталі та опис помилки
|*$.error.localizedMessage*
|String
|Локалізований опис
|===

=== Низькорівневий дизайн

Для даних у форматі ASiC передбачено можливість накладання декількох підписів, тому при отриманні інформації про підпис, повертається масив з деталями про кожен накладений на дані підпис.

.Приклад логіки валідації ASiC
[source, java]
----
IntStream.rangeClosed(0, endUser.ASiCGetSignsCount(data))
                .mapToObj(index -> endUser.ASiCVerify(index, data))
                .collect(Collectors.toList());
----

Для даних в форматі CAdES використовується `EndUser::VerifyInternal(base64Data)` та повертається деталі з об'єкту `EndUserSignInfo` як єдиний елемент в масиві.

== get_content(<string|data>, <enum|dataFormat>)

=== JUEL функція

|===
|Назва параметру |Опис |Тип |Тип даних

|data
|Дані які включають в себе підпис в форматі Base64
|Вхідний
|String

|format
|Перелік доступних для використання типів файлів
|Вхідний
|Enum (ASiC/CAdES)

|response
|Обʼєкт з даними
|Вихідний
|SignData
|===

.Структури для отримання контенту в БП
[plantuml]
----
class SignData {
- List<Content> data
+ Content getContent()
+ List<Content> getAllContent()
}

class Content {
- String data
- String name
+ String getName()
+ String getData() //Base64 string
}
----

=== REST API

_POST /api/esignature/content_

.Приклад тіла запиту
[source,json]
----
{
  "data": "dGVzdCBkYXRh",
  "container": "CAdES/ASiC/XdES/..."
}
----

.Структура тіла відповіді
|===
|Json Path|Тип|Опис

|*$.content[]*
|array[Content]
|Вміст контейнеру
|*$.error.code*
|String
|Відповідний код статусу
|*$.error.message*
|String
|Деталі та опис помилки
|*$.error.localizedMessage*
|String
|Локалізовані деталі та опис помилки
|===

=== Низькорівневий дизайн

Для ASiC контейнеру отримання переліку всіх файлів в контенйері відбувається за допомогою `EndUser::ASiCGetSignReferences` для кожного індексу, а отримання контенту за допомогою `EndUser::ASiCGetReference`

Для CAdES контейнерів дані є частина вихідного параметру `EndUser::VerifyInternal(base64Data)`


== Високорівневий план розробки

== Технічні експертизи

* BE (java)

== План розробки

* Оновлення бібліотеки ІІТ
* Розширення DSO відповідними точками інтеграції
* Додавання JUEL-функцій
* Додавання утілітарної функції для кодування і декодування Base64
* Розробка референтних прикладів
