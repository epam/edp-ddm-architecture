= Аудит бізнес-процесів

== BP-01. X-Access-Token в сервісних задач
Використовувати X-Access-Token в сервісних задач, який був отриманий в поточній транзакції бізнес-процесу

IMPORTANT: Критичність: висока

=== Опис
При використанні _juel_ функцій для отримання користувацького авторизаційного токену (наприклад,
_completer('ActivityId').accessToken_, _initiator().accessToken_) треба впевнитись, що місце використання функції та
відповідна актівіті (користувацька задача, або початкова подія) знаходяться в одній транзакції бізнес-процесу. +

=== Вплив
Термін дії користувацького авторизаційного токен може закінчитися, поки бізнес-процес дійде до точки використання.
Може бути не виявлено на етапі розробки та тестування через відсутність відповідних умов (задача, яку не беруть у
виконання більше 5 хв, довга транзакція, тимчасова недоступність сервісу тощо) +

=== Рекомендації
Використовувати токен користувача найближчої до точки використання задачі або токен системного користувача
(_system_user().accessToken_)

== BP-02. Довгі транзакції бізнес-процесів
При наявності в бізнес-процесі транзакцій, які потенційно можуть виконуватись довгий час, треба розділяти їх на окремі
транзакції.

IMPORTANT: Критичність: висока

=== Опис
При моделюванні бізнес-процесів необхідно розділяти великі транзакції та робити якомога більше задач асинхронними для
надійності виконання та реагуванні на можливі помилки.

=== Вплив
Довгі транзакції можуть призвести до наступних проблем:

* Вичерпання пулу з'єднань до бази даних і блокування виконання інших бізнес-процесів.
* При виникненні помилки, політики повтору (retry policy) будуть виконуватися від початку транзакції, виконуючи всі
задачі, які вже були виконані
//TODO: Перевірити цей стейтмент
* Час життя _X-Access-Token_, який використовується в сервісних задачах транзакції може закінчитися, поки транзакція
виконується
* Якщо початком транзакції є користувацька задача, то користувач буде бачити лоадер і не отримує повідомлення про
успішно виконану операцію, поки транзакція не буде завершена.

=== Рекомендації
В задачах транзакції проставляти атрибути _camunda:asyncBefore_ або _camunda:asyncAfter_ зі значенням _true_ для
асинхронного продовження (_Asynchronous Continuations_) бізнес-процесу, що призведе до створення нової транзакції.
Додатково слід враховувати роботу з користувацьким токеном (<<_bp_01_x_access_token_в_сервісних_задач>>) та несталими
змінами (<<_bp_07_робота_з_несталими_transient_змінними>>) при моделюванні асинхронних задач.

NOTE: Детальніше про транзакції у Camunda можна ознайомитись
https://docs.camunda.org/manual/7.19/user-guide/process-engine/transactions-in-processes/[за посиланням]

== BP-03. Транзакції в циклах
При наявності циклів в бізнес-процесі, розпочинати кожну ітерацію в окремій транзакції
// TODO: Перевірити transactional boundaries для multi-instance актівіті і окремо паралельне виконання

IMPORTANT: Критичність: висока

=== Опис
Причиною довгої транзакції може бути цикл, який виконується багату кількість ітерації, тому при моделюванні циклів в
бізнес-процесах необхідно застосовувати асинхронне виконання для кожної ітерації.

=== Вплив
При наявності циклів, які мають велику кількість ітерацій _Camunda Engine_ тримає транзакцію на базі даних протягом всього
часу його виконання, що може призвести до впливу довгих транзакцій, які описані в <<_bp_02_довгі_транзакції_бізнес_процесів>>.
Додатково слід зауважити, що при виникненні помилки на 100-ій ітерації, буде спроба виконати першу ітерацію, а потім будуть
виконані всі ітерації від початку.

//TODO: Також краще перевірити цей стейтмент

=== Рекомендації
Проставляти _camunda:asyncBefore_ атрибут після першої актівіті у циклі (це може бути сервісна задача, або початкова
подія у випадку під-процесу) або _camunda:asyncAfter_ останньої актівіті у циклі. Потрібно також врахувати та виключити
використання несталих (transient) змінних, які були отримані у бізнес-процесі до першої операції у циклу.

== BP-04. Стратегія повторних спроб (retry time cycle)
Перевизначати стратегію повторних спроб (retry time cycle) для асинхронних задач.

IMPORTANT: Критичність: висока

=== Опис
За замовчуванням при виникненні помилки при виконанні асинхронних задач виконавець робіт (job executor) буде пробувати
виконати задачу ще 3 рази без пауз між ними. У більшості випадків причиною помилки може бути виклик іншого сервісу як
всередині системи, так і за її межами, який міг бути тимчасово недоступний. В такому випадку негайний повтор не призведе
до якихось змін і врешті решт задачу буде помічена невдалою (failed) і може бути перезапущена тільки  вручну
_Адміністратором реєстру_ у _Сервісі адміністрування бізнес-процесами_

=== Вплив
При виникненні помилки при виконанні асинхронних задач в більшості випадків повторні спроби не призводять до успішного
завершення задачі, а лише ще більше навантажують сервіс з яким могла виникнути проблема.

=== Рекомендації
Для асинхронних задач встановити атрибут циклу повторних спроб _camunda:failedJobRetryTimeCycle_ з певною затримкою,
наприклад, 5 спроб кожні 5 хвилин _R5/PT5M_. В процесі експлуатації значення може бути адаптоване відповідно до поведінки
бізнес-процесу.

NOTE: Детальніше про повторні спроби у Camunda можна ознайомитись https://docs.camunda.org/manual/7.19/user-guide/process-engine/the-job-executor/#retry-time-cycle-configuration[за посиланням]

//TODO:Розглянути перевизначення конфігурації на рівні платформи

== BP-05. Ліміт для критеріїв пошуку
При використанні сервісної задачі з пошуку сутностей в фабриці даних, треба явно задавати параметр по максимальній
кількості даних (limit), які можуть бути отримані.

IMPORTANT: Критичність: середня

=== Опис
При використанні задач з пошуку даних в реєстрі, параметр з максимальною кількістю даних (limit) не є обов'язковим, і
часто не вказується при роботі з таблицями, які на етапі розробки містять невелику кількість даних. Однак, при використанні
в промисловому середовищі такі запити потенційно можуть нести набагато більше даних, що може призвести до деградації роботи
системи.

=== Вплив
Велика кількість даних, отримана при використанні сервісної задачі з відсутнім параметром ліміту, може призвести до
наступних потенційних проблем:

* Додаткове навантаження на сервіси системи:
** Реляційна база даних
** Сервіс синхронного управління даними реєстру
** Сервіс виконання бізнес-процесів

* Збільшений час виконання бізнес-процесу
* Збільшений час виконання окремої транзакції бізнес-процесу

=== Рекомендації
Завжди вказувати параметр ліміту (limit) для сервісних задач з пошуку даних. Можливі сценарії використання:

==== Пошук обмеженої кількості елементів
Якщо за бізнес-логікою відомо що після виконання запиту обробляється тільки певна кількість даних (наприклад, перший
елемент зі списку), то треба явно обмежити запит цією кількістю.

==== Обробка всіх даних за результатами пошуку
Якщо бізнес-процес повинен обробити всі дані, то треба розглянути поетапну обробку елементів (можливо, пачками)
в циклі та пагінацією при використанні сервісних задач з пошуку даних.

==== Інтеграція з зовнішніми системами
При необхідності запитів зовнішніми системами для вибірки даних з реєстру в першу чергу треба розглянути можливість
використання напряму АПІ для читання даних без залучення бізнес-процесу (але все одно з обов'язковими параметрами пагінації).
Якщо ж відповідна інтеграція потребує певної логіки бізнес-процесу, то треба додати відповідні параметри пагінації як
вхідні атрибути бізнес-процесу та імплементувати логіку пагінації на системі, що інтегрується.

== BP-06. Складна логіка в скриптових задачах
При використанні скриптових задач слід уникати складної логіки і робити їх якомога простішими.

IMPORTANT: Критичність: середня

=== Опис
Скриптові задачі дозволяють писати доволі складну логіку, використовуючи всю потужність мови Groovy, що в
короткостроковій перспективі (наприклад, розробка прототипів) можуть допомогти розробнику, але впроваджують перелік
ризиків пов'язаних з підтримкою та розробкою в майбутньому.

=== Вплив
Важливі аспекти, пов'язані з використанням складної логіки в скриптових задачах:

* Супроводження: Складну логіку складно розуміти, обслуговувати та усунути. Це може зробити бізнес-процес важким для
управління та розвитку з часом і призвести до потенційних помилок та повільніших циклів розробки.
* Тестування: скриптові завдання зі складною логікою можуть бути важкими для ізольованого тестування, що ускладнює
забезпечення якості та надійності процесу.
* Продуктивність: складна логіка у скриптових завданнях може вплинути на продуктивність, особливо якщо вона містить
операції, що споживають багато ресурсів або довготривалі задачі.
* Обробка помилок: обробка помилок у скриптових задачах може бути складною, що ще більше ускладнює супроводження та
розуміння скрипту

=== Рекомендації
* Використовувати скриптові задачі для простих, коротких та зрозумілих операцій
* Використовувати можливості DMN та BPMN для будь-якої бізнес-логіки в бізнес-процесах
* Використовувати вбудовані можливості _Camunda Spin_ для роботи з
https://docs.camunda.org/manual/7.19/user-guide/data-formats/xml/[XML] та
https://docs.camunda.org/manual/7.19/user-guide/data-formats/json/[JSON]

== BP-07. Робота з несталими (transient) змінними
При моделюванні бізнес-процесів слід враховувати, що деякі змінні можуть бути несталими (transient) та не зберігатись
при переході на наступну транзакцію.

IMPORTANT: Критичність: середня

=== Опис
При моделюванні бізнес-процесів є певний перелік сервісних задач, які виконують виклики, як всередині системи, так і на
зовнішні сервіси, наприклад, виклики до фабрики даних, сервісу управління користувачами та ролями, сервісу підпису,
Трембіти та інші. Результат будь-якого такого виклику може містити персональні дані користувача, тому зберігається як
нестала (transient) змінна і є доступна тільки в поточній транзакції бізнес-процесу.

=== Вплив
Результат виклику сервісної задачі буде недоступний після переходу межи бізнес-процесу (користувацька задача, асинхронне
продовження, очікування повідомлення тощо)

=== Рекомендації
* Використовувати результат виконання виклику сервісної задачі відразу після отримання результату в рамках однієї транзакції
* Якщо результат виклику сервісної задачі потрібно використовувати в наступних транзакціях і вони не містять персональних
даних, зберігати результат в сталій змінній бізнес-процесу
* Якщо результат виклику містить змішані дані, але надалі використовується тільки неперсональна частина з них (наприклад,
ідентифікатор сутності), відокремити її та зберегти як окрему сталу змінну

//TODO: Перевірити можливості пре-пополейта форм для зберігання персональної інформації між транзакціями

NOTE: Детальніше про несталі змінні в Camunda можна ознайомитись
https://docs.camunda.org/manual/7.19/user-guide/process-engine/variables/#transient-variables[за посиланням]

== BP-08. Декілька викликів фабрики даних в одній транзакції
Для збереження складної сутності та транзакційного запису в декілька таблиць використовувати функціонал вкладених
сутностей (nested entity).

IMPORTANT: Критичність: висока

=== Опис
При моделюванні бізнес-процесу може виникнути необхідність оновлення декількох таблиць бази даних в рамках однієї
транзакції (бази даних, не плутати з транзакцією бізнес-процесу). Тобто щоб або всі таблиці були оновлені, або жодна з них.
На рівні виконання бізнес-процесу не має можливості пов'язати декілька викликів фабрики даних в одну транзакцію, тому
декілька послідовних викликів фабрики даних в одному бізнес-процесі можуть призвести до створення неконсистентних даних
в базі даних.

=== Вплив
* Створення неконсистентних даних в базі даних після виникнення помилки між окремими викликами фабрики даних. В залежності
від логіки та моделі регламенту може призвести до повного блокування роботи з конкретним записом.
* При виникненні помилки, політика повторних спроб виконання бізнес-процесу розпочне виконання з початку, що може призвести
до повторної вставки даних в окрему таблицю.

=== Рекомендації
* Використовувати функціонал вкладених сутностей (nested entity) для збереження складної сутності та транзакційного
виконання оновлення декількох таблиць бази даних в рамках однієї транзакції
* Якщо функціоналу по роботі з вкладеними сутностями виявилось недостатньо, розглянути наступні практики:
** Моделювання компенсації в бізнес-процесі. При виникненні помилки виконання бізнес-процесу виконати відкат змін у вигляді
викликів фабрики даних на видалення створених записів або відновлення попереднього стану
** Налаштувати кожну вставку в базу даних з асинхронним продовженням бізнес-процесу і відповідними політиками повторних
спроб. Це дозволить закінчити умовну транзакцію вставки в базу даних після усунення причини виникнення помилки
** Розташування окремих викликів фабрики даних один за одним в бізнес-процесі. Чим більше буде проміжних задач між викликами,
тим більше ймовірність виникнення помилки між вставками і невдалого виконання транзакції

== BP-09. Ініціалізація та використання змінних

IMPORTANT: Критичність

=== Опис

=== Вплив

=== Рекомендації

== BP-10. Ідентифікатори елементів бізнес-процесів

IMPORTANT: Критичність

=== Опис

=== Вплив

=== Рекомендації

== BP-11. Моделювання зліва направо

IMPORTANT: Критичність

=== Опис

=== Вплив

=== Рекомендації

== BP-12. Мультіінстанс задачі та кол актівіті

IMPORTANT: Критичність

=== Опис

=== Вплив

=== Рекомендації

== BP-13. Логування в скриптових задачах
// TODO: Перевірити відповідну juelку
IMPORTANT: Критичність

=== Опис

=== Вплив

=== Рекомендації

== BP-14. Авторизаційні токени для викликів зовнішніх сервісів
// TODO: Перевірити можливості по роботі з токенами через секрети
IMPORTANT: Критичність

=== Опис

=== Вплив

=== Рекомендації

== BP-15. Зрозумілі підписи на елементах бізнес-процесу

== BP-16. Таймери на користувацьких задачах

// TODO: Перевірити Роботу з компенсаціями в документації, демо реєстру та в РПЗМ

