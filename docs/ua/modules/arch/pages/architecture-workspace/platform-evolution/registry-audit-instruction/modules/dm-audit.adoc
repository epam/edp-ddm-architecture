= Аудит моделі даних

|===
|Назва | Критичність

|<<_dm_01>> |Висока
|<<_dm_02>> |Середня
|<<_dm_03>> |Низька
|<<_dm_04>> |Висока
|<<_dm_05>> |Висока
|<<_dm_06>> |Висока
|<<_dm_07>> |Середня
|<<_dm_08>> |Висока
|<<_dm_09>> |Висока

|===

[#_dm_01]
== DM-01. Індекси для критеріїв пошуку
IMPORTANT: Критичність: висока

.Опис
Створюйте індекси необхідні для оптимальної продуктивності запитів критеріїв пошуку. При цьому слідкувати за тим щоб не створювалися дублікати або зайві індекси.

.Вплив
Належне індексування є важливим у реляційних базах даних для покращення продуктивності запитів. Без індексів система управління базами даних (СУБД) мусить сканувати всю таблицю, що може бути дуже повільним для великих наборів даних.

Головними кандидатами на індексування є стовпці по яким відбувається пошук та стовпці по яким відбувається з'єднання таблиць у запитах.

Створення індексів може значно покращити продуктивність запитів, але є ситуації, коли варто утриматися від створення індексу або ретельно розглянути, чи варто його створювати:

* Якщо стовпець має дуже низьку селективність, тобто в ньому мало різних значень порівняно з загальною кількістю рядків, створення індексу може не суттєво покращити продуктивність запитів. Наприклад, стовпець із всього двома різними значеннями, такими як "Так" і "Ні", немає сенсу індексувати.

* Малі таблиці з невеликою кількістю рядків може бути не вигідно індексувати. Накладні витрати на підтримку структури даних індексу можуть перевищити потенційні прирости продуктивності запитів.

* Індекси не покращать запити, що виконують агрегації (наприклад, SUM, AVG, COUNT) по всій таблиці, оскільки для цих операцій потрібно сканувати весь набір даних, незалежно від наявності індексів.

* Дубльовані індекси слід уникати, оскільки вони витрачають ресурси, збільшують витрати на обслуговування і можуть призвести до непередбачуваної продуктивності запитів.

.Рекомендації
Використовуйте атрибут `indexing="true"` тегу `ext:createSearchCondition` для автоматичного створення необхідних індексів на стовпці по яким відбувається пошук.

Використовуйте тег `createIndex` для ручного створення  індексів, наприклад для ключів по яким відбувається join.

Звертайте увагу на те що система автоматично створює індекси для первинних ключів, унікальних ключів та стовпців пошуку, якщо ввімкнено `indexing="true"` тегу `ext:createSearchCondition`, та не створюйте індексів які їх дублюють. 

Своєчасно видаляйте дублікати та зайві індекси за допомогою тегу `dropIndex`.

[#_dm_02]
== DM-02. Зайві чендж сети в рамках 1 релізу
IMPORTANT: Критичність: середня

.Опис
Видаляйте непотрібні чендж сети та зміни створені в процесі розробки, до релізу в промислове середовище.

.Вплив
* Зі зростанням кількості чендж сетів збільшується складність файлу changelog, що робить його важким у керуванні та розумінні.
* Чим більше чендж сетів у вас є, тим більше часу займає застосування змін в базі даних. 

.Рекомендації
Користуйтесь можливістю виділяти зміни в моделі даних, які були створені в процесі розробки релізу. Наприклад якщо в ви створили таблицю і потім вирішили до неї додати колонку не створюйте новий чендж сет `addColumn`, а перестворіть таблицю з новою колонкою. Так само якщо ви створили критерій пошуку, а потім вирішили його змінити або видалити, просто змініть або видаліть оригінальний чендж сет. Такі операції можуть потребувати очищення розробницького оточення за допомогою `clean-up`.

[#_dm_03]
== DM-03. Іменування ідентифікаторів чендж сетів
IMPORTANT: Критичність: низька

.Опис
Додержуйтесь єдиної конвенції в найменуваннях ідентифікаторів чендж сетів.

.Вплив
Прийняття чіткої та послідовної конвенції найменування для  ідентифікаторів чендж сетів допоможе організувати та зрозуміло представити зміни в схемі бази даних.

.Рекомендації
Встановіть конвенцію для найменування та послідовно дотримуйтеся її протягом усього проекту. Це забезпечить розуміння всім членам команди правил найменування та легкої ідентифікації змінних.

Використовуйте описові назви, які пояснюють призначення або характер змін. Добре обрана назва повинна чітко розкривати суть зміни.

[#_dm_04]
== DM-04. Перелік колонок в критеріях пошуку
IMPORTANT: Критичність: низька

.Опис
Додавати в критерії пошуку тільки ті колонки, що використовуються в бізнес-процесі, формах чи зовнішньому АПІ.
Якщо колонка не використовується в пошуку, то вона не повинна бути включена в критерії пошуку.

.Вплив
* Наявність файлів в критеріях пошуку і їх виклик з бізнес-процесу призводить до перекладання файлів між постійним та
тимчасовим сховищем, що впливає на час виконання операції та призводить до додаткового навантаження на систему

.Рекомендації
* Не робити 1 критерій пошуку для всіх потреб (аналогія антипатерну _"God Object"_). Краще зробити декілька критеріїв
пошуку, що будуть задовільняти конкретні потреби.

[#_dm_05]
== DM-05. Ліміти на критерії пошуку
IMPORTANT: Критичність: висока

.Опис
Завжди вказуйте ліміт при моделюванні критеріїв пошуку

.Вплив
Якщо зовнішній сервіс чи бізнес-процес не вкаже ліміт при визові критерію пошуку, та на самому критерії ліміт не вказано, це може призвести як до витоку даних, так і до проблем з продуктивністю системи. 

.Рекомендації
Вказуйте ліміт для критерію пошуку, користуючись атрибутом `limit` тегу `ext:createSearchCondition`

[#_dm_06]
== DM-06. Нормалізація схеми бази даних
IMPORTANT: Критичність: висока

.Опис
Моделюйте схему бази даних в третій нормальній формі.

.Вплив
Третя нормальна форма (3NF) усуває або значно зменшує повторення даних. Це мінімізує ризик невідповідності та аномалій в даних, які можуть виникнути, коли однакові дані зберігаються в кількох місцях. Вона сприяє існуванню єдиного джерела правди для кожного фрагмента даних.

Шляхом усунення повторення даних та забезпечення логічного та організованого зберігання кожного фрагмента даних, 3NF підвищує цілісність даних. Дані залишаються точними та надійними, зменшуючи ризик помилок.

Також завдяки уникненню повторення даних, схеми 3NF зазвичай потребують менше простору для зберігання. Це важливо для економії витрат та ефективного використання ресурсів, особливо в великих базах даних.

.Рекомендації
Використовувати 3-ю нормальну форму (3NF) як базову для моделювання схеми.

В випадках коли відступ від 3NF є обґрунтованим, наприклад для оптимізації продуктивності, треба глибоко розуміти та враховувати компроміси які виникають.

[#_dm_07]
== DM-07. Часткове оновлення
IMPORTANT: Критичність: середня

.Опис
При необхідності оновлення сутності в бізнес-процесі надавати перевагу частковому оновленню (partial update) замість
стандартного повного оновлення сутності.

.Вплив
* Спрощує логіку бізнес-процесу
* Менше викликів до бази даних. Немає потреби додатково вичитувати сутність для подальшого її оновлення

NOTE: Треба пам'ятати, що при використанні часткового оновлення, всі поля, які в ньому присутні повинні бути передані.
Інакше, вони будуть встановлені в NULL.

.Рекомендації
Створюйте API для часткового оновлення за допомогою тегу `ext:partialUpdate` та використовуйте при необхідності оновлювати частину стовпців сутності.

[#_dm_08]
== DM-08. SQL тег Liquibase
IMPORTANT: Критичність: висока

.Опис
Використовуйте стандартні теги _Liquibase_ що надаються платформою.

.Вплив
SQL-вирази, написані в чендж сетах, можуть виявитися не сумісними з новими версіями платформи.

Liquibase забезпечує перевірку та виявлення помилок для стандартних тегів. На відміну від цього, SQL-вирази в чендж сетах не перевіряються Liquibase, і помилки можуть бути виявлені лише під час виконання.

.Рекомендації
Використовуйте стандартні теги _Liquibase_ що підтримуються платформою.

Якщо з'являється необхідність використати SQL, обов'язково ретельно тестуйте та перевіряйте ваші чендж сети, щоб переконатися, що вони працюють правильно і не вводять помилок у схему бази даних. 

[#_dm_09]
== DM-09. Пагінація (Посторінкова навігація) на критеріях пошуку
IMPORTANT: Критичність: висока

.Опис
Використовуйте можливості пагінації при моделюванні критеріїв пошуку

.Вплив
Пагінація зменшує обсяг передаваних даних, поліпшуючи роботу мережі.

Надання посторінкових результатів дозволяє користувачам переглядати дані у керованих частинах.

Менші за об'ємом результати обробляються швидше, що зменшує навантаження на сервер бази даних.

.Рекомендації
Обирайте необхідний тип пагінації за допомогою атрибуту `pagination` тегу `ext:createSearchCondition`.

* Для випадків коли необхідно щоб поверталась також і інформація про загальну кількість сторінок та рядків - `pagination="page"`
* Для випадків коли інформація про загальну кількість сторінок та рядків не потрібна - `pagination="offset"`. Це тип пагінації за замовчанням.
