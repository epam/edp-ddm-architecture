= Керування сертифікатами та параметрами взаємодії із сумісними ЦСК для Сервісу цифрових підписів

== Загальний опис
Поточне рішення для Сервісу цифрових підписів передбачає наявність файлів зі _Списком сертифікатів сумісних центрів
сертифікації ключів (ЦСК)_ (_CACertificates.p7b_) та _Параметрами взаємодії із сумісними ЦСК_ (_CAs.json_) на файловій
системі сервісу. На цільовому оточенні ці файли монтуються за допомогою _OpenShift_ секретів, що, втім мають обмеження
в розмірі у 1MB. Потрібно розробити рішення, що б дозволило працювати з вищевказаними файлами без обмеження на розмір.

NOTE: В цьому документі для спрощення _Список сертифікатів сумісних центрів сертифікації ключів (ЦСК)_ = файл
(_CACertificates.p7b_), а _Параметри взаємодії із сумісними ЦСК_ = файл _CAs.json_

== Концепти
* _Список сертифікатів сумісних центрів сертифікації ключів (ЦСК)_ - файл що містить перелік сертифікатів ЦСК, що
вповноважені оформлювати _Кваліфікований Електронний Підпис_. При перевірці чи накладанні підпису відбувається перевірка,
що ключ був випущений _Акредитованим Центром Сертифікації Ключів_. Список зберігається у форматі PKCS #7 з розширенням
_.p7b_, що зазвичай має назву _CACertificates.p7b_.
* _Параметри взаємодії із сумісними ЦСК_ - файл, що містить додаткову інформацію про ЦСК, таку як _Загальне ім'я_, та
параметри доступу до серверів ЦСК (CMP, TSP та OCSP). Зазвичай має назву _CAs.json_

== Функціональні сценарії
* Налаштування _Списку сертифікатів сумісних центрів сертифікації ключів (ЦСК)_ та _Параметрів взаємодії із сумісними ЦСК_
для автентифікації користувачів Адміністратором Платформи
* Налаштування _Списку сертифікатів сумісних центрів сертифікації ключів (ЦСК)_ та _Параметрів взаємодії із сумісними ЦСК_
для перевірки підписів Адміністратором Реєстру
* Перевірка користувацького електронного підпису
* Накладання системного підпису (електронної печатки)

== Ролі користувачів
* Адміністратор Платформи
* Адміністратор Реєстру

== Загальні принципи та положення
* Файли _CACertificates.p7b_ та _CAs.json_ є публічно доступними по своїй природі і не містять секретної інформації
* Сервіс цифрових підписів має можливість використовувати або файлову систему (поточне рішення) або адресу URL, за якою
можна отримати файли _CACertificates.p7b_ та _CAs.json_
* Стратегія отримання файлів _CACertificates.p7b_ та _CAs.json_ керується на рівні налаштувань сервісу в _application.yml_
* Доступ до файлів  _CACertificates.p7b_ та _CAs.json_ по URL не передбачає автентифікації та доступний анонімним користувачам
* Інтерфейс взаємодії Адміністратора Платформи та Адміністратора Реєстру для налаштування файлів _CACertificates.p7b_ та
_CAs.json_ у _Веб-інтерфейсі управління Платформою та реєстрами_ не змінюється
* При розгортанні реєстру файли _CACertificates.p7b_ та _CAs.json_ перекладаються в Ceph кошик з Vault, який наразі
використовується як проміжне сховище
* При перекладанні файлів у Ceph налаштовується публічний доступ за допомогою заголовку HTTP запиту _x-amz-acl = public-read_

== Високорівневий дизайн рішення

.Діаграма послідовності
[plantuml, dso-cert-mng, svg]
----
@startuml
actor "Platform Admin" as admin
participant "Control Plane" as cp
participant "Gerrit" as gerrit
participant "Jenkins" as jenkins
participant "Cert Object\nBucket Claim" as obc
participant "Cert Bucket\nConfig Map" as cm
participant "Cert Bucket\nSecret" as secret
participant "Ceph" as ceph
participant "DSO" as dso

admin -> cp: Updates certificates
cp -> gerrit: Updates certificates
jenkins -> obc: Creates
obc --> cm: Creates
obc --> secret: Creates
dso -> cm: Mount

jenkins -> gerrit: Pull certificates
jenkins -> jenkins: Generates name
jenkins -> cm: Read
jenkins -> secret: Read
jenkins -> ceph: Save certs in bucket with name and public access

@enduml
----

=== Міграція

== Попередня декомпозиція

== Поза скоупом

== Обмеження рішення

== Додаток. Розглянуті варіанти в порівнянні

|===
|Варіант|Опис|Плюси|Мінуси|Ціна

|Push сертифікатів на файлову систему
|Монтуємо замість секрету PV по тому ж шляху. В пайплайні по розгортанню реєстру оновлюємо сертифікати на файловій
системі
|Дешево. Швидко
|Прозорість налаштування. Може бути не очевидно, що для коректної роботи сервісу треба ще щось зробити руками на
файловій системі, хоча по факту зараз теж саме можна сказати і про секрети
|XS

|Pull сертифікатів по публічній урлі
|Вказуємо в конфігурації УРЛ по якій скачати сертифікати при старті застосунку. Так само працює віджет
|Мінімум змін. Не треба залучати додаткові компоненти. Локальна розробка не відрізняється від запуску на оточенні
a|
 * Залежність від 3rd party сервісів. Якщо сервер з сертифікатами відпаде, сервіс dso не зможе стартанути.
Але якщо він відпаде, віджет так само не буде працювати
 * Додаткові динамічні network policy.
 * Складність використання кастомних ланцюжків. Так потреба виникла тільки тоді, коли виникла помилка з великим розміром
секрету
|S

|Pull сертифікатів по публічній/приватній урлі + управління сертифікатами на платформі
|Додаємо можливість адміністратору платформи вказати ланцюжки сертифікатів для платформи. Для них формується урл, який
вказується в конфігурації dso
|Адресування мінусів з попереднього пункту. Незалежність від 3rd party сервісів. Статичні network policy. Можливість
формування кастомних ланцюжків. Можливо розбити на 2 етапи
|Максимум змін, додаємо новий функціонал щоб адресувати ризик з нестабільністтю сервера з сертифікатами (спірний момент)
|M

|Pull сертифікатів з vault/ceph
|На оточенні dso при старті забирає сертифікати з вказанням кредів доступу до vault/ceph
|Відносно дешеве рішення з точки зору розгортання. Зрозумілий підхід
|Ускладнення локального девелопменту. Або тримати декілька стратегій отримання сертифікатів
|S

|Pull сертифікатів на файлову систему в ініт контейнері
|init контейнер на оточенні викачує сертифікати з урли/vault/ceph і скаладає на файлову систему
|Жодних змін в DSO. Локально розробка ніяк не змінюється.
a|
* Прозорість налаштування. Може бути не очевидно, що для коректної роботи сервісу треба ще щось зробити руками на
файловій системі, хоча по факту зараз теж саме можна сказати і про секрети
* Додаткова розробка init контейнеру
|M

|===