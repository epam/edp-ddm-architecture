= Керування сертифікатами та параметрами взаємодії із сумісними ЦСК для Сервісу цифрових підписів

== Загальний опис
Поточне рішення для Сервісу цифрових підписів передбачає наявність файлів зі _Списком сертифікатів сумісних центрів
сертифікації ключів (ЦСК)_ (_CACertificates.p7b_) та _Параметрами взаємодії із сумісними ЦСК_ (_CAs.json_) на файловій
системі сервісу. На цільовому оточенні ці файли монтуються за допомогою _OpenShift_ секретів, що, втім мають обмеження
в розмірі у 1MB. Потрібно розробити рішення, що б дозволило працювати з вищевказаними файлами без обмеження на розмір.

NOTE: В цьому документі для спрощення _Список сертифікатів сумісних центрів сертифікації ключів (ЦСК)_ = файл
_CACertificates.p7b_, а _Параметри взаємодії із сумісними ЦСК_ = файл _CAs.json_

== Концепти
* _Список сертифікатів сумісних центрів сертифікації ключів (ЦСК)_ - файл що містить перелік сертифікатів ЦСК, що
вповноважені оформлювати _Кваліфікований Електронний Підпис_. При перевірці чи накладанні підпису відбувається перевірка,
що ключ був випущений _Акредитованим Центром Сертифікації Ключів_. Список зберігається у форматі PKCS #7 з розширенням
_.p7b_, що зазвичай має назву _CACertificates.p7b_.
* _Параметри взаємодії із сумісними ЦСК_ - файл, що містить додаткову інформацію про ЦСК, таку як _Загальне ім'я_, та
параметри доступу до серверів ЦСК (CMP, TSP та OCSP). Зазвичай має назву _CAs.json_

== Функціональні сценарії
* Налаштування _Списку сертифікатів сумісних центрів сертифікації ключів (ЦСК)_ та _Параметрів взаємодії із сумісними ЦСК_
для автентифікації користувачів Адміністратором Платформи
* Налаштування _Списку сертифікатів сумісних центрів сертифікації ключів (ЦСК)_ та _Параметрів взаємодії із сумісними ЦСК_
для перевірки підписів Адміністратором Реєстру
* Перевірка користувацького електронного підпису
* Накладання системного підпису (електронної печатки)

== Ролі користувачів
* Адміністратор Платформи
* Адміністратор Реєстру

== Загальні принципи та положення
* Файли _CACertificates.p7b_ та _CAs.json_ є публічно доступними по своїй природі і не містять секретної інформації
* Сервіс цифрових підписів має можливість використовувати адресу в форматі URL, за якою можна отримати файли
_CACertificates.p7b_ та _CAs.json_
* Доступ до файлів  _CACertificates.p7b_ та _CAs.json_ по URL не передбачає передачі додаткових параметрів, які не
включені в URL конфігурації. За необхідністю додаткові параметри включаються як частина URL
* Інтерфейс взаємодії Адміністратора Платформи та Адміністратора Реєстру для налаштування файлів _CACertificates.p7b_ та
_CAs.json_ у _Веб-інтерфейсі управління Платформою та реєстрами_ не змінюється
* При розгортанні реєстру файли _CACertificates.p7b_ та _CAs.json_ зберігаються в Ceph кошик з публічним доступом до файлу
* Для файлів сертифікатів створюється окремий Ceph кошик шляхом додавання ресурсу _Object Bucket Claim_ у Helm Chart
_Сервісу цифрових підписів_
* Файли сертифікатів при оновленні перезатираються у Ceph кошику по тому самому ідентифікатору
* Імена файлів статичні та посилання на них не змінюються при оновленні
* Рішення застосовується як для _Сервісу цифрових підписів_ _Підсистеми цифрових підписів_, так і для _Підсистеми
управління користувачами та ролями_

== Високорівневий дизайн рішення

.Діаграма послідовності
[plantuml, dso-cert-mng, svg]
----
@startuml
actor "Admin" as admin
participant "Control Plane" as cp
participant "Gerrit" as gerrit
participant "Jenkins" as jenkins
participant "Cert Object\nBucket Claim" as obc
participant "Cert Bucket\nConfig Map" as cm
participant "Cert Bucket\nSecret" as secret
participant "Ceph" as ceph
participant "DSO" as dso

admin -> cp: Update certificates
cp -> gerrit: Update certificates
jenkins -> obc: Create
obc --> secret: Create
obc --> cm: Create
dso --> cm: Read env variables from

jenkins -> gerrit: Pull certificates
jenkins -> cm: Read
jenkins -> secret: Read
jenkins -> ceph: Save certs in bucket with public access
jenkins -> dso: Restart deployment

dso -> ceph: Read certs

@enduml
----

=== Взаємодія пайплану публікації з Ceph

Після створення _Object Bucket Claim_ як частини Helm чарту _Сервісу цифрових підписів_ параметри доступу для нього
зберігаються у відповідних Секреті та Конфіг Мапі в тому ж неймспейсі, де і був створений _Object Bucket Claim_, які
будуть мати туж саму назву, що і _Object Bucket Claim_.

[source,yaml]
.Object Bucket Claim dso-ca-certificates
----
apiVersion: objectbucket.io/v1alpha1
kind: ObjectBucketClaim
metadata:
  name: dso-ca-certificates
  namespace: registry-ns
spec:
  generateBucketName: dso-certificates
  storageClassName: registry-bucket
----

[source,yaml]
.Config Map dso-ca-certificates
----
kind: ConfigMap
apiVersion: v1
metadata:
  name: dso-ca-certificates
  namespace: registry-ns
data:
  BUCKET_HOST: rook-ceph-rgw-mdtuddm.openshift-storage.svc
  BUCKET_NAME: dso-certificates-<<UUID>>
  BUCKET_PORT: '80'
  BUCKET_REGION: ''
  BUCKET_SUBREGION: ''
----

[source,yaml]
.Secret dso-ca-certificates
----
kind: Secret
apiVersion: v1
metadata:
  name: dso-ca-certificates
  namespace: registry-ns
data:
  AWS_ACCESS_KEY_ID: <<ACCESS_KEY_ID_VALUE>>
  AWS_SECRET_ACCESS_KEY: <<SECRET_ACCESS_KEY_VALUE>>
type: Opaque
----

[source,bash]
.Приклад виконання операції збереження файлу у Ceph
----
sh '
  AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \
  AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \
  AWS_DEFAULT_OUTPUT=json \
  AWS_ENDPOINT_URL=$BUCKET_HOST \
  aws s3 cp dso/config/CACertificates.p7b s3://$BUCKET_NAME/CACertificates.p7b --acl public-read
'
----

NOTE: В ході розробки треба переконатись, що виконання команд з Ceph не вплине на глобальну конфігурацію AWS, яка також
використовується для іншої функціональності в пайплайні

Ім'я файлів є статичним і має значення _CACertificates.p7b_ та _CAs.json_ відповідно

Після оновлення сертифікатів у Ceph кошику виконується рестарт Деплойменту _Сервісу Цифрових Підписів_

[source, bash]
----
oc rollout restart deployment/digital-signature-ops
----

=== Конфігурація DSO

Конфігурація _Сервісу цифрових підписів_ повинна включати два параметри для отримання файлів сертифікатів
(_CACertificates.p7b_) та конфігурацій доступу (_CAs.json_) по заданій адресі в форматі URL. Реалізація повинна бути
незалежної від природи зберігання файлу і можуть бути використані публічні сервери для отримання вищевказаних файлів.

[source,yaml]
.application.yml. Конфігурація з використанням системного сховища Ceph
----
ca:
  certificates-url: http://rook-ceph-rgw-mdtuddm.openshift-storage.svc/dso-certificates-3ea4ad25-805b-4a27-8df0-c85066501937/CACertificates.p7b
  config-url: http://rook-ceph-rgw-mdtuddm.openshift-storage.svc/dso-certificates-3ea4ad25-805b-4a27-8df0-c85066501937/CAs.json
----

[source,yaml]
.application.yml. Конфігурація з використанням публічного сервера сертифікатів
----
ca:
  certificates-url: https://eu.iit.com.ua/sign-widget/v20200922/Data/CACertificates.p7b?v=30
  config-url: https://eu.iit.com.ua/sign-widget/v20200922/Data/CAs.json?v=30
----
NOTE: Варіант з використанням публічного сервера сертифікатів потребує додаткових налаштувань політик мережі

Опційно. Реалізація повинна підтримувати конфігурацію URL для файлів, в тому числі на файловій системі сервісу

[source,yaml]
.application.yml. Конфігурація з використанням файлової системи
----
ca:
  certificates-url: file:/app/data/CACertificates.p7b
  config-url: file:/app/data/CAs.json
----

Параметри доступу до Ceph кошика, що включають адресу s3 ендпоінта та назву бакета прокинуті в Деплоймент _Сервіс
цифрових підписів_ як змінні оточення

[source,yaml]
.values.yaml
----
# part of digital-signature-ops Deployment
      env:
        - name: CERT_BUCKET_HOST
          valueFrom:
            configMapKeyRef:
              name: dso-ca-certificates
              key: BUCKET_HOST
        - name: CERT_BUCKET_NAME
          valueFrom:
            configMapKeyRef:
              name: dso-ca-certificates
              key: BUCKET_NAME
# ...
----

NOTE: Авторизаційна інформація доступу до кошика не використовується у _Сервісі Цифрових Підписів_

URL доступу до файлів винесені як параметри Helm values і мають наступні значення, які потенційно можуть бути перевизначені
на рівні реєстру (без відповідного інтерфейсу у _Веб-інтерфейсі управління Платформою та Реєстрами_)

[source,yaml]
.values.yaml
----
ca:
  certificates-url: http://${CERT_BUCKET_HOST}/${CERT_BUCKET_NAME}/CACertificates.p7b
  config-url: http://${CERT_BUCKET_HOST}/${CERT_BUCKET_NAME}/CAs.json
----

NOTE: Параметри прокидаються в Spring застосунок за стандартними в платформі принципом _Helm values_ -> _Config Map_ ->
_application.yml_ -> _Spring context_

=== Міграція
* В рамках міграції потрібно реалізувати видалення ключів _CACertificates.p7b_ та _CAs.json_ у секреті
_digital-signature-data_ в пайплайнах розгортання реєстру та платформи

== Попередня декомпозиція
* [BE] Зміна стратегії отримання файлів сертифікатів та конфігурацій на URL у Сервісі цифрових підписів
* [BE] Зміна назв параметрів для кошиків витягів з загальних на більш конкретні (CEPH_BUCKET_HOST -> EXCERPT_BUCKET_HOST
і інші)
* [DEVOPS] Адаптація пайплайну розгортання реєстру для збереження файлів сертифікатів у Ceph кошик (registry dso)
* [DEVOPS] Адаптація пайплайну розгортання платформи для збереження файлів сертифікатів у Ceph кошик (user-mng dso)

== Поза скоупом
* Можливість задавання URL в ручному режимі в _Веб-інтерфейсі управління Платформою та реєстрами_
* Відмова від зберігання файлів сертифікатів у Git репозиторії реєстру
* Можливість зберегти файли сертифікатів 1 раз на платформу і задати для всіх реєстрів один і той самий URL

== Додаток 1. Розглянуті варіанти в порівнянні
.Розгорнути
[%collapsible]
====
|===
|Варіант|Опис|Плюси|Мінуси|Ціна

|Push сертифікатів на файлову систему
|Монтуємо замість секрету PV по тому ж шляху. В пайплайні по розгортанню реєстру оновлюємо сертифікати на файловій
системі
|Дешево. Швидко
|Прозорість налаштування. Може бути не очевидно, що для коректної роботи сервісу треба ще щось зробити руками на
файловій системі, хоча по факту зараз теж саме можна сказати і про секрети
|XS

|Pull сертифікатів по публічній урлі
|Вказуємо в конфігурації УРЛ по якій скачати сертифікати при старті застосунку. Так само працює віджет
|Мінімум змін. Не треба залучати додаткові компоненти. Локальна розробка не відрізняється від запуску на оточенні
a|
 * Залежність від 3rd party сервісів. Якщо сервер з сертифікатами відпаде, сервіс dso не зможе стартанути.
Але якщо він відпаде, віджет так само не буде працювати
 * Додаткові динамічні network policy.
 * Складність використання кастомних ланцюжків. Так потреба виникла тільки тоді, коли виникла помилка з великим розміром
секрету
|S

|Pull сертифікатів по публічній/приватній урлі + управління сертифікатами на платформі
|Додаємо можливість адміністратору платформи вказати ланцюжки сертифікатів для платформи. Для них формується урл, який
вказується в конфігурації dso
|Адресування мінусів з попереднього пункту. Незалежність від 3rd party сервісів. Статичні network policy. Можливість
формування кастомних ланцюжків. Можливо розбити на 2 етапи
|Максимум змін, додаємо новий функціонал щоб адресувати ризик з нестабільністтю сервера з сертифікатами (спірний момент)
|M

|Pull сертифікатів з vault/ceph
|На оточенні dso при старті забирає сертифікати з вказанням кредів доступу до vault/ceph
|Відносно дешеве рішення з точки зору розгортання. Зрозумілий підхід
|Ускладнення локального девелопменту. Або тримати декілька стратегій отримання сертифікатів
|S

|Pull сертифікатів на файлову систему в ініт контейнері
|init контейнер на оточенні викачує сертифікати з урли/vault/ceph і скаладає на файлову систему
|Жодних змін в DSO. Локально розробка ніяк не змінюється.
a|
* Прозорість налаштування. Може бути не очевидно, що для коректної роботи сервісу треба ще щось зробити руками на
файловій системі, хоча по факту зараз теж саме можна сказати і про секрети
* Додаткова розробка init контейнеру
|M

|===
====