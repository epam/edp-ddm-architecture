//:imagesdir: ../../../../images

= Доступ до контенту файлів реєстру через зовнішні API

[IMPORTANT]
--
Сторінка технічної документації є баченням майбутньої реалізації, актуальність якого може бути застарілою.
--

== Загальний опис
У цій статті буде розглянута реалізація можливості віддавати контент файлів збережених у реєстрі через зовнішні API. Наразі ця можливість відсутня і контент файлів можливо отримати тільки з бізнес процесу який є частиною реєстру в якому зберігається файл.

== Актори та ролі користувачів
* Розробник регламенту
* Зовнішні системи

== Загальні принципи та положення

* Поведінка і контракт існуючих критеріїв пошуку не змінюється. 
* Зберігається зворотна сумісність конфігурації критеріїв пошуку.
* Отримання файлів відбувається окремим запитом.
* Точки інтеграції створюються лише за наявності полів типу _file_ або _file[]_ в регламенті

== Функціональні сценарії

* Налаштування критеріїв пошуку
* Генерація сервісів критеріїв пошуку
* Доступ до контенту файлів через публічний АРІ
* Доступ до контенту файлів через міжреєстрову взаємодію без Трембіти
* Доступ до контенту файлів через міжреєстрову взаємодію через Трембіту
* Доступ до контенту файлів для публічної форми (майбутня функціональність) з EditGrid 

== Поточна реалізація

image::architecture-workspace/platform-evolution/rest-file-transfer/file-transfer-current.drawio.svg[]

В поточній реалізації доступ до файлів реалізований лише для підсистеми виконання бізнес-процесів. Працює він наступним чином:
 
 * Підсистема виконання бізнес-процесів робить виклик на registry-rest-api і окрім всього іншого передає в хедері запиту ідентифікатор бізнес-процесу
 * registry-rest-api по хедеру розуміє що запит прийшов з підсистеми виконання бізнес-процесів
 * registry-rest-api отримує дані що запитані з БД реєстру.
 * Якщо серед даних є дані типу _type_file_, тобто дані що містять ідентифікатори файлів в бакеті file-ceph-bucket, то всі ці файли копіюються у бакет lowcode-file-storage по шляху який дорівнює ідентифікатор бізнес-процесу та який є доступним для підсистеми виконання бізнес-процесів.
 * Підсистема виконання бізнес-процесів отримує відповідь з даними що запитані, включаючи ідентифікатори файлів.
 * Підсистема виконання бізнес-процесів читає вміст файлів з lowcode-file-storage

Всі інші запити до registry-rest-api та його копій (ext та pub) не отримують ідентифікатор бізнес-процесу в хедері та не повертають ідентифікатори файлів (замість них пусте поле) та не копіюють файли з file-ceph-bucket в lowcode-file-storage.

Таким чином для зовнішніх систем не передбачено жодного механізму для отримання контенту файлів що збережені в реєстрі.

== Високорівневий дизайн рішення

=== Повернення інформації про файли які міститься в сутності

При запиті сутностей, що містять тип файл або масив файлів при відсутності заголовків з інформацією про бізнес-процес повертається структура з ідентифікатором файлу з кошика _file-ceph-bucket_. При цьому не відбувається копіювання файлів.

.Приклад сутності
[source, xml]
----
 <createTable tableName="user" ext:historyFlag="true">
            <column name="user_id" type="UUID" defaultValueComputed="uuid_generate_v4()">
                <constraints nullable="false" primaryKey="true" primaryKeyName="pk_koatuu_id"/>
            </column>
            <column name="name" type="TEXT">
                <constraints nullable="false"/>
            </column>
            <column name="photo" type="file">
                <constraints nullable="false"/>
            </column>
            <column name="documents" type="file[]">
                <constraints nullable="false"/>
            </column>
        </createTable>
----

.Приклад відповіді на запит пошуку сутності за ідентифікатором
[source, json]
----
{
  "userId": "uuid1-user",
  "name": "Petro",
  "photo": {
    "id": "uuid2-photo",
    "checksum": "..."
  },
  "documents": [
    {
        "id": "uuid3-passport",
        "checksum": "..."
    },
    {
        "id": "uuid4-driver-licence",
        "checksum": "..."
    }]
}

----

=== Створення окремих точок інтеграції для отримання вмісту файлів.

.Шаблон формування посилання до вмісту файлу
[source, httprequest]
----
HTTP GET /api/data-factory/files/{entity}/{entityId}/{fieldName}/{fieldId}
----

Данна точка інтеграції наслідує всі правила застосування _RBAC_.

Така точка інтеграції доступна в rest-api якщо в моделі даних є хоча б одне поле типу _file_ або _file[]_. +
В сервісах _rest-api-ext_ та _rest-api-public_ правила _Istio_ налаштовані так, що доступ до цих посилань для користувачів з реалму _external_systems_ є тільки за умови якщо хоча б один _searchCondition_ що містить в собі тип _file_ або _file[]_ був виставлений через тег _<exposeSearchCondition/>_

.Посилання для прикладу
[source, httprequest]
----
HTTP GET /api/data-factory/files/user/uuid1-user/photo/uuid2-photo
----

.Посилання для прикладу для доступу до конкретних документів в масиві
[source, httprequest]
----
GET /api/data-factory/files/user/uuid1-user/documents/uuid3-passport
GET /api/data-factory/files/user/uuid1-user/documents/uuid4-driver-licence
----

Дане посилання підтримує запити двох типів контенту  _application/json_ і при такому запиті повертає структуру _JSON_, вміст файлу закодований у _Base64_ в якості значення поля _content_ з мета інформацією про файл у _checksum_ та _fileName_

.Приклад запиту для отримання відповіді в JSON форматі
[source, httprequest]
----
GET /api/data-factory/files/user/uuid1-user/documents/uuid3-passport
Accept: application/json
----

[source, httprequest]
----
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8

{
    "contetn": "passport in Base64",
    "checksum": "..."
    "fileName": "petro_passport.pdf"
}
----

Запити між _soap-api_ та _rest-api_ для файлів відбуваються саме таким чином, а трансформація об'єкта для передачі по _SOAP_Trembita_ відбувається безпосередньо на _soap-api_

Якщо в запиті не зазначено, що в якості відповіді очікується _application/json_, то типи визначаються динамічно в залежності від типу файлу.
Додатково проставляються заголовки _Content-Disposition_ із значенням _attachment_ та вказанням атрибуту _filename_ взятого з метаданих про файл.
Такі посилання можна буде формувати в бізнес-процесах, та публікувати на користувацьких формах, для завантаження файлів безпосередньо з форм.


.Приклад запиту для скачування файлу
[source, httprequest]
----
GET /api/data-factory/files/user/uuid1-user/documents/uuid3-passport
----

[source, httprequest]
----
HTTP/1.1 200 OK
Content-Type: application/pdf
Content-Disposition: attachment; filename="petro_passport.pdf"

... (binary PDF data)
----

== Високорівневий план розробки

=== Технічні експертизи

* BE

=== План розробки

* Створення окремого сценарію при відсутності заголовків з інформацією про бізнес-процес
* Створення точок інтеграції для отримання контенту в rest-api
* Оновлення клієнту soap-api
* Зміна правил _Istio_ по наданню доступів до точок інтеграції повʼязаних з отриманнями вмісту файлів
* Референтний процес