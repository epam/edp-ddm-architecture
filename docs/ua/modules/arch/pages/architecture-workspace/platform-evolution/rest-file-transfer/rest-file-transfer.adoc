//:imagesdir: ../../../../images

= Доступ до контенту файлів реєстру через зовнішні API

[IMPORTANT]
--
Сторінка технічної документації є баченням майбутньої реалізації, актуальність якого може бути застарілою.
--

NOTE: Work In Progress

== Загальний опис
У цій статті буде розглянута реалізація можливості віддавати контент файлів збережених у реєстрі через зовнішні API. Наразі ця можливість відсутня і контент файлів можливо отримати тільки з бізнес процесу який є частиною реєстру в якому зберігається файл.

== Актори та ролі користувачів
* Розробник регламенту
* Зовнішні системи

== Загальні принципи та положення

* Поведінка і контракт існуючих критеріїв пошуку не змінюється. 
* Зберігається зворотна сумісність конфігурації критеріїв пошуку.
* Отримання файлів відбувається окремим запитом.

== Функціональні сценарії

* Налаштування критеріїв пошуку
* Генерація сервісів критеріїв пошуку
* Доступ до контенту файлів через публічний АРІ
* Доступ до контенту файлів через міжреєстрову взаємодію без Трембіти
* Доступ до контенту файлів через міжреєстрову взаємодію через Трембіту
* Доступ до контенту файлів для публічної форми (майбутня функціональність) з EditGrid 

== Поточна реалізація

image::architecture-workspace/platform-evolution/rest-file-transfer/file-transfer-current.drawio.svg[]

В поточній реалізації доступ до файлів реалізований лише для підсистеми виконання бізнес-процесів. Працює він наступним чином:
 
 * Підсистема виконання бізнес-процесів робить виклик на registry-rest-api і окрім всього іншого передає в хедері запиту ідентифікатор бізнес-процесу
 * registry-rest-api по хедеру розуміє що запит прийшов з підсистеми виконання бізнес-процесів
 * registry-rest-api отримує дані що запитані з БД реєстру.
 * Якщо серед даних є дані типу _type_file_, тобто дані що містять ідентифікатори файлів в бакеті file-ceph-bucket, то всі ці файли копіюються у бакет lowcode-file-storage по шляху який дорівнює ідентифікатор бізнес-процесу та який є доступним для підсистеми виконання бізнес-процесів.
 * Підсистема виконання бізнес-процесів отримує відповідь з даними що запитані, включаючи ідентифікатори файлів.
 * Підсистема виконання бізнес-процесів читає вміст файлів з lowcode-file-storage

Всі інші запити до registry-rest-api та його копій (ext та pub) не отримують ідентифікатор бізнес-процесу в хедері та не повертають ідентифікатори файлів (замість них пусте поле) та не копіюють файли з file-ceph-bucket в lowcode-file-storage.

Таким чином для зовнішніх систем не передбачено жодного механізму для отримання контенту файлів що збережені в реєстрі.

== Варіанти рішення

=== Повернення інформації про файли які міститься в сутності

При запиті сутностей, що містять тип файл або масив файлів при відсутності заголовків з інформацією про бізнес-процес повертається структура з ідентифікатором файлу з кошика _file-ceph-bucket_. При цьому не відбувається копіювання файлів.

.Приклад сутності
[source, xml]
----
 <createTable tableName="user" ext:historyFlag="true">
            <column name="user_id" type="UUID" defaultValueComputed="uuid_generate_v4()">
                <constraints nullable="false" primaryKey="true" primaryKeyName="pk_koatuu_id"/>
            </column>
            <column name="name" type="TEXT">
                <constraints nullable="false"/>
            </column>
            <column name="photo" type="file">
                <constraints nullable="false"/>
            </column>
            <column name="documents" type="file[]">
                <constraints nullable="false"/>
            </column>
        </createTable>
----

.Приклад відповіді на запит пошуку сутності за ідентифікатором
[source, json]
----
{
  "userId": "uuid1-user",
  "name": "Petro",
  "photo": {
    "id": "uuid2-photo",
    "checksum": "..."
  },
  "documents": [
    {
        "id": "uuid3-passport",
        "checksum": "..."
    },
    {
        "id": "uuid4-driver-licence",
        "checksum": "..."
    }]
}

----

=== Створення окремих точок інтеграції для отримання вмісту файлів.

.Шаблон формування посилання до вмісту файлу
[source, httprequest]
----
HTTP GET /api/data-factory/{entity}/{entityId}/{fieldName}/{fieldId}
----

.Посилання для прикладу
[source, httprequest]
----
HTTP GET /api/data-factory/user/uuid1-user/photo/uuid2-photo
----

.Посилання для прикладу
[source, httprequest]
----
GET /api/data-factory/user/uuid1-user/documents/uuid3-passport
GET /api/data-factory/user/uuid1-user/documents/uuid4-driver-licence
----

Дане посилання підтримує запити двох типів контенту  _application/json_ і при такому запиті повертає структуру _JSON_, вміст файлу закодований у _Base64_ в якості значення поля _content_ з мета інформацією про файл у _checksum_ та _fileName_

[source, httprequest]
----
GET /api/data-factory/user/uuid1-user/documents/uuid3-passport
Content-Type: application/json
-
{
    "contetn": "passport in Base64",
    "checksum": "..."
    "fileName": "petro_passport.pdf"
}
----

Запити між _soap-api_ та _rest-api_ для файлів відбуваються саме таким чином, а трансформація об'єкта для передачі по _SOAP_Trembita_ відбувається безпосередньо на _soap-api_

Якщо в запиті не зазначено, що в якості відповіді очікується _application/json_, то типи визначаються динамічно в залежності від типу файлу.
Додатково проставляються заголовки _Content-Disposition_ із занченням _attachment_ та вказанням атрибуту _filename_ взятого з метаданих про файл.
Такі посилання можна буде формувати в бізнес-процесах, та публікувати на користувацьких формах, для завантаження файлів безпосередньо з форм.

[source, httprequest]
----
GET /api/data-factory/user/uuid1-user/documents/uuid3-passport
Content-Type: application/pdf
Content-Disposition: attachment; filename="petro_passport.pdf"
----