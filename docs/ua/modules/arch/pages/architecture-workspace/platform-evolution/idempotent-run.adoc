= Ідемпотентне розгортання регламенту

== Загальний опис

На етапі розгортання регламенту кроки запускаються лише якщо було внесено зміни в рамках останнього коміту. Таким чином якщо при попередньому запуску пайплайна крок був не успішним, а в поточному коміті зміни не було внесено, то крок буде проігноровано і відмічено як успішний.


== Функціональні сценарії

* Порівняння поточного стану регламенту з станом регламенту при останньому успішному виконанні кроку.
* Збереження стану регламенту в секрет.

== Ролі користувачів

* Моделювальник

== Загальні принципи та положення


* Для визначення чи необхідно виконувати той чи інший крок, відбувається перевірка поточного стану регламенту з станом регламенту на момент останнього успішного виконання кроку.
* Перевірка залежних файлів відбувається для кожного кроку окремо і фіксується лише для конкретного кроку, таким чином при обробці файлів які використовуються у декільках кроках не буде хибних записів про успішність опрацювання цих файлів.
* Чексуми по кроках зберігаються в секреті як `JSON`


== Високорівневий дизайн рішення

Розширення утіліти командного рядка `registry-regulations-validator-cli` двома командами
`save ${stepName} -f %{dir1} %{dir2/subDir1} ${fileName}` для підрахунку чек-сум всіх перелічених файлів та збереження значень у секрет `k8s` і
`plan %{stepName}` для перевірки стану і необхідності запуску кроку розгортання.


== Низькорівневий дизайн сервісів


=== Перевірка стану регламенту і необхідності запуску кроку розгортання

.Приклад використання на пайплайні розгортання
[source, bash]
----
registry-regulations-validator-cli plan create-redash-roles
----

Вихідним параметром виконання команди є _boolean_ флаг чи відрізняються файли які були використанні при виконанні даного кроку від поточного стану.

Правила коли необхідно повторно виконати крок:

* В секреті відсутній крок з таким ім'ям
* Чексума для хоча б одного з перелічених файлів відрізняється від чексуми збереженої в секреті.
* Інформація про чексуму файла відсутня у секреті.

=== Збереження стану регламенту після успішного виконання кроку

.Формат виклику команди збереження стану файлів для кроку розгортання регламенту.
[source, bash]
----
save ${stepName} -f %{dir1} %{dir2/subDir1} ${fileName}
----

.Приклад
[source, bash]
----
save create-trembita-business-process -f %{dir1} %{dir2/subDir1} ${fileName}
----

у разі успішного виконання кроку стан зберігається в секреті `registry-regulation-steps-state`

.Структура збереження стану регламенту в серкреті
[source, json]
----
{
  "create-trembita-business-process": {
    "global-vars": "....:SHA256",
    "bp-auth": "....:SHA256",
    "bp-trembita": "....:SHA256"
  },
  "upload-global-vars-changes": {
    "global-vars": "....:SHA256"
  }
}
----

Для підрахунку чексуми файлів використовується алгоритм _SHA256_ `MessageDigest digest = MessageDigest.getInstance("SHA-256");`

