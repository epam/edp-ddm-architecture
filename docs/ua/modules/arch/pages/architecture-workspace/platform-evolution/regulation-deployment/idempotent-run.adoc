= Ідемпотентне розгортання регламенту

[IMPORTANT]
--
Сторінка технічної документації є баченням майбутньої реалізації, актуальність якого може бути застарілою.
--

== Загальний опис

На етапі розгортання регламенту кроки запускаються лише якщо було внесено зміни в рамках останнього коміту. Таким чином якщо при попередньому запуску пайплайна крок був не успішним, а в поточному коміті зміни не було внесено, то крок буде проігноровано і відмічено як успішний.


== Функціональні сценарії

* Порівняння поточного стану регламенту з станом регламенту при останньому успішному виконанні кроку.
* Збереження стану регламенту в секрет.
* Розгортання регламенту з примусовим викликом всіх кроків (_FULL_DEPLOY_)

== Ролі користувачів

* Моделювальник

== Загальні принципи та положення


* Для визначення чи необхідно виконувати той, чи інший крок, відбувається перевірка поточного стану регламенту з станом регламенту на момент останнього успішного виконання кроку.
* Перевірка залежних файлів відбувається для кожного кроку окремо і фіксується лише для конкретного кроку, таким чином при обробці файлів які використовуються у декількох кроках не буде хибних записів про успішність опрацювання цих файлів.
* Чек-суми по кроках зберігаються в секреті як `JSON`
* Управління секретом відбувається за допомогою _k8s API_


== Високорівневий дизайн рішення

Розширення застосунку командного рядка `registry-regulations-cli` двома командами
`save` для підрахунку чек-сум всіх перелічених файлів та збереження значень у секрет `k8s` і `plan` для перевірки стану і необхідності запуску кроку розгортання.

== Низькорівневий дизайн сервісів

[source, shell]
----
registry-regulations-cli [command] [options]

COMMANDS:
    validate - валідація регламенту на наявність помилок
    plan - перевірка чи необхідні якісь дії для приведення реєстру до стану описаному в регламенті, в рамках окремої бізнес операції.
    save - збереження чек-суми частини регламенту повязаної з бізнес операцією до k8s секрету.
----


[source, shell]
----
registry-regulations-cli [plan|save] [parameter] [options]

Приймає як параметер, назву бізнес операції.

OPTIONS:
    -f --file - перелік папок і файлів [Обовʼязковий]

----
=== Перевірка стану регламенту і необхідності запуску кроку розгортання

.Приклад використання на пайплайні розгортання
[source, bash]
----
registry-regulations-cli plan update-data-model -f registry-regulations/data-model/ registry-regulations/settings.yaml
----

Вихідним параметром виконання команди є _boolean_ флаг чи відрізняються файли які були використанні при виконанні даного кроку від поточного стану.

Правила коли необхідно повторно виконати крок:

* В секреті відсутній крок з таким ім'ям
* Чек-сума для хоча б одного з перелічених файлів відрізняється від чек-суми збереженої в секреті.
* Інформація про чек-суму файла відсутня у секреті.

=== Збереження стану регламенту після успішного виконання кроку

.Формат виклику команди збереження стану файлів для кроку розгортання регламенту.
[source, bash]
----
registry-regulations-cli save ${business-operation} -f %{dir1} %{dir2/subDir1} ${fileName}
----

.Приклад
[source, bash]
----
registry-regulations-cli save  update-data-model -f registry-regulations/data-model/ registry-regulations/settings.yaml
----

у разі успішного виконання кроку стан зберігається в секреті `registry-regulation-steps-state`

.Структура збереження стану регламенту в секреті.
[source, json]
----
{
  "registry-regulations-validation": {
    "registry-regulations": "...:SHA256"
  },
  "create-redash-roles": {
    "registry-regulations/roles": "...:SHA256"
  },
  "create-keycloak-roles": {
    "registry-regulations/roles": "...:SHA256"
  },
  "update-data-model": {
    "registry-regulations/data-model": "...:SHA256",
    "registry-regulations/settings.yaml": "...:SHA256"
  },
  "apply-reports": {
    "registry-regulations/reports": "...:SHA256"
  },
  "apply-notifications": {
    "registry-regulations/notifications": "...:SHA256"
  },
  "apply-excerpts": {
    "registry-regulations/excerpts-csv": "...:SHA256",
    "registry-regulations/excerpts-docx": "...:SHA256",
    "registry-regulations/excerpts": "...:SHA256"
  },
  "apply-bp-grouping": {
    "registry-regulations/bp-grouping": "...:SHA256"
  },
  "update-geoserver-configuration": {
    "registry-regulations/data-model": "...:SHA256"
  },
  "apply-web-forms": {
    "registry-regulations/forms": "...:SHA256"
  },
  "set-global-vars": {
    "registry-regulations/global-vars": "...:SHA256"
  },
  "apply-theme": {
    "registry-regulations/global-vars": "...:SHA256"
  },
  "configure-trembita-integrations": {
    "registry-regulations/bp-trembita": "...:SHA256"
  },
  "bpms-rollout": {
    "registry-regulations/bpmn": "...:SHA256"
  },
  "update-bp": {
    "registry-regulations/bpmn": "...:SHA256",
    "registry-regulations/dmn": "...:SHA256"
  },
  "update-bp-permission": {
    "registry-regulations/bp-auth": "...:SHA256"
  },
  "apply-autotests": {
    "registry-regulations/autotests": "...:SHA256"
  },
  "update-registry-settings": {
    "registry-regulations/settings": "...:SHA256"
  }
}
----

Для підрахунку чексуми файлів використовується алгоритм _SHA256_ `MessageDigest digest = MessageDigest.getInstance("SHA-256");`

== Високорівневий план розробки

=== Технічні експертизи

* BE

=== План розробки

* Перейменування репозиторію застосунку для валідації.
* Винесення операції для валідації в окрему команду _validate_.
* Додавання команди для збереження стану регламенту в секрет.
* Додавання команди для перевірки стану регламенту зі збереженим станом.
* Зміна команд валідації регламенту.
* Зміна перевірки на необхідність запускання всіх кроків пайплайну розгортання регламенту.