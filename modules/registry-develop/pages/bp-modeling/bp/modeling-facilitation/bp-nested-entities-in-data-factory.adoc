= Збереження декількох сутностей в рамках однієї транзакції
:toc:
:toc-title: ЗМІСТ
:toclevels: 5
:sectnums:
:sectnumlevels: 5
:sectanchors:

CAUTION: Документ у процесі формування.

== Загальний опис

З метою підтримки функціональності збереження декількох сутностей в рамках однієї транзакціїfootnote:[_Транзакція_ -- група послідовних операцій із базою даних, яка є логічною одиницею роботи з даними. Транзакція може бути виконана або цілком і успішно, дотримуючись цілісності даних і незалежно від інших транзакцій, що ідуть паралельно, або не виконана зовсім.], розроблено типове розширення до бізнес-процесів -- делегат `${dataFactoryConnectorNestedCreateDelegate}`, для якого імплементовано однойменний шаблон *Create nested entities in data factory*, представлений у вигляді JSON-файлу _dataFactoryConnectorNestedCreateDelegate.json_.

Делегат потрібний для того, щоб в рамках однієї транзакції створювати декілька сутностей у Фабриці даних.

[TIP]
====
На Платформі реєстрів також реалізовано подібний делегат і відповідний шаблон до нього -- *Create entity in data factory*, але він дозволяє створити _лише одну_ сутність в рамках транзакції. При такому підході Фабрика даних може створити декілька сутностей, але вони будуть записані по черзі, під різними транзакціями.

За таких обставин результат _однієї системної задачі_ бізнес-процесу може створити тільки _один запис_ у сховищі даних CEPH.
====

За допомогою делегата `${dataFactoryConnectorNestedCreateDelegate}` реалізовано можливість створення _декількох записів з однієї сервісної задачі_.

Для того, щоб делегат міг функціонувати, на рівні Фабрики даних реалізовано можливість створення таких _nested entities_, тобто імплементовано окремий _спеціальний ендпоінт_, для того, щоб приймати декілька сутностей від бізнес-процесу і створювати відповідні записи у базі даних.

На рівні API, у контракті, описано яким має бути тіло запита, щоб мати змогу створити декілька сутностей у БД.

.Приклад
====
Нам необхідно зберегти до бази даних користувача та його налаштування, але з точки зору бази даних, ці параметри знаходяться у різних таблицях.

Для вирішення такої ситуації необхідно залучити новий ендпоінт, який дозволятиме зберегти й користувача, і його налаштування.

Після опрацювання на рівні API, Фабрика даних сама розкладе дані до належних таблиць.
====

== Налаштування делегата у бізнес-процесі

//TODO: Можливо, надати аттачмент готової схеми із прикладом БП? АБО дати посилання на моделювання БП чи навчальний курс

=== Передумови

. Перед налаштуванням шаблону в Сamunda Modeler переконайтеся, що папка `/element-templates` застосунку містить файл _dataFactoryConnectorNestedCreateDelegate.json_.
+
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-1.png[]

[start=2]
. Перед налаштуванням делегата у бізнес-процесі, обов'язково підготуйте змодельований процес із наявними задачами: сервісною та скриптування.

////
TODO: Змінити скрин - розглянемо інший БП
+
.Приклад. Абстрактний бізнес-процес для налаштування делегата
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-2.png[]
////

////
TODO: Розглянемо інший БП, інший приклад скрипту
=== Моделювання та налаштування задачі скриптування для формування даних

Налаштуйте задачу скриптування, а саме, використовуючи Groovy-скрипт, побудуйте об'єкт (`payload`), що буде використано сервісною задачею для передачі даних до ендпоінту на стороні Фабрики даних.

. Відкрийте змодельовану задачу скриптування (*Script Task*).
. Перейдіть до панелі налаштувань та сконфігуруйте наступні параметри:

* У полі `Name` введіть ім'я задачі. Наприклад, `Підготувати дані до запису (transient var)`.
* У полі `Script Format` вкажіть формат (мову) скрипту -- `Groovy`.
* У полі `Script Type`  вкажіть тип скрипту -- `Inline Script`.

+
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-3.png[]

* У полі `Script` введіть безпосередньо groovy-скрипт:

+
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-4.png[]

+
[#example-2]
.Приклад. Groovy-скрипт, що формує JSON-об'єкт для запису до Фабрики даних
====
[source,groovy]
----
def requestMap = [:]
        def factors = []

        def signedFormData = submission('Activity_shared-sign-app-include').formData

        factorNames = ['FactorsPhys', 'laborfact', 'biofactors', 'factorPesticide', 'chemfactgost', 'chemfacthyge', 'chemfactobrv', 'chemfactodovilni']
        factorNames.each { factors.addAll(signedFormData.prop(it).elements().collect { it.prop('factorId').stringValue() }) }

        signedFormData.fieldNames().findAll { fieldName -> !factorNames.contains(fieldName) }.each { requestMap[it] = signedFormData.prop(it).value() }

        requestMap['factors'] = factors
        requestMap['applicationTypeId'] = applicationTypeResponse.responseBody.elements()[0].prop('applicationTypeId').stringValue()
        requestMap['laboratoryId'] = submission('start_event').formData.prop('laboratory').prop('laboratoryId').value()
        requestMap['solutionTypeId'] = solutionTypeId

        var payload = S(requestMap, 'application/json')
        execution.removeVariable('payload')
        set_transient_variable('payload', payload)
----
====

* Визначте, що JSON-об'єкт із необхідними параметрами потрібно записати до `set_transient_variable ('payload', payload)`. Тобто скрипт записуватиме дані об'єкта у форматі `application/json` до змінної `'payload'` (_див. xref:#example-2[приклад]_).

* Потім використайте створений JSON як змінну `${payload}` у сервісній задачі для запису даних до БД.
+
TIP: Тобто ми визначаємо наступне: взяти дані, записані до змінної `${payload}` у задачі скриптування та використати їх для запису у сервісній задачі, тобто передати їх до відповідного ендпоінту, розробленого для делегата `$dataFactoryConnectorNestedCreateDelegate`.
////

=== Моделювання та налаштування сервісної задачі для збереження даних

Налаштуйте сервісну задачу та шаблон делегата `$dataFactoryConnectorNestedCreateDelegate` для запису даних до БД.

. Змоделюйте сервісну задачу (*Service Task*).

+
image:bp-modeling/bp/element-temp/nested-entities/nested-entities-1.png[]

. Натисніть `Open Catalog` та оберіть шаблон *Create nested entities in data factory* зі списку.

+
image:bp-modeling/bp/element-temp/nested-entities/nested-entities-2.png[]
+
image:bp-modeling/bp/element-temp/nested-entities/nested-entities-3.png[]

. Сконфігуруйте обраний шаблон:

* У полі `Name` вкажіть назву задачі. Наприклад, `Зберегти дані до Фабрики даних`.
* У полі `Resource` вкажіть ресурс, тобто назву ендпоінту, до якого необхідно звернутися. Наприклад, `registration`.
+
NOTE: На рівні API, ендпоінт виглядає наступним чином: `/nested/<resource name>`, де `<resource name>` -- назва ресурсу. Тобто у полі `Resource` необхідно ввести значення, вказане після останньої косої риски (`/`).

* У полі `Payload` введіть тіло запита -- JSON-об`єкт із вкладеною структурою декількох сутностей, яку необхідно зберегти до Фабрики даних. Наприклад, `${payload}`.
+
NOTE: Майте на увазі, що необхідно попередньо побудувати цей JSON-об`єкт, тобто `payload`, в рамках задачі скриптування.

* У полі `X-Access-Token` вкажіть токен доступу.
+
[CAUTION]
====
Токен доступу береться з АБО ініціатора (наприклад, `$initiator().accessToken}`), АБО виконавця задачі (наприклад, `${completer('taskDefinitionId').accessToken}`).

Якщо перед сервісною задачею у бізнес-процесі немає жодної користувацької задачі, використовуємо токен ініціатора процесу (initiator).

Якщо перед сервісною задачею є користувацька задача, використовуємо токен виконавця задачі (completer).

Таким чином ми від імені користувача, який АБО запустив бізнес-процес, АБО виконав користувацьку задачу, створюємо сутності у базі даних.
====

+
image:bp-modeling/bp/element-temp/nested-entities/nested-entities-4.png[]

* У полі `X-Digital-Signature source` вкажіть джерело цифрового підпису.
* У полі `X-Digital-Signature-Derived source` вкажіть джерело системного цифрового підпису.
* У полі `Result variable` вкажіть назву змінної процесу, до якої необхідно записати результат (за замовчуванням -- `response`).

+
image:bp-modeling/bp/element-temp/nested-entities/nested-entities-5.png[]

. Виконайте `Unlink` шаблону, тобто від'єднайте шаблон від задачі, щоб побачити деталі його імплементації, що передзаповнюються автоматично:

* У полі `Implementation` визначено тип -- `Delegate Expression`.
* У полі `Delegate Expression`  визначено назву делегата -- `$dataFactoryConnectorNestedCreateDelegate`.
+
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-5.png[]
+
image:bp-modeling/bp/element-temp/nested-entities/bp-nested-entities-6.png[]

== Імплементація на рівні API

Для окремого типу запита використовують окремий делегат.

Тобто є контролер, який підтримує певні типи запитів (методи): `POST`, `GET`, `PUT` та `DELETE`. Для кожного методу -- свій делегат.

[WARNING]
====
Для ресурсу `/nested/<resource name>` використовується _лише_ метод `PUT`.

І хоча метод `PUT` зазвичай використовується для оновлення записів, у нашому випадку `PUT` може як _створити сутність_, так і _оновити_ її, в залежності від того, які параметри ми передаємо у запиті:

* Якщо необхідно _створити сутність_, то ми НЕ передаємо параметр `id` у тілі запита.

* Якщо необхідно _оновити сутність_, то ми включаємо параметр `id` у тіло запита.
====

////
TODO: Complete, додати валідний приклад
Найважливішим параметром для передачі даних до API-ендпоінту є безпосередньо тіло запита (`Request body`), тобто `payload`, що був сформований у задачі скриптування та використаний сервісною задачею, і в якому передається JSON.

.Приклад. Тіло запита
====
[source,json]
----
{
"name": "Іван",
"surname": "Сидоренко",
"personProfileId": "<uuid>"
}
----
====

[IMPORTANT]
====
Отже, нема потреби створювати окремий контролер із різними ендпоінтами. Достатньо створити один окремий ендпоінт, який матиме можливість приймати й правильно опрацьовувати тіло запита, сформоване у форматі JSON, де будуть передані всі необхідні дані користувача та його налаштування тощо.
====
////

== Проблематика питання

При використанні делегата `dataFactoryConnectorCreateDelegate` та відповідного ендпоінта, за потреби запису 2-х і більше сутностей до бази даних, -- це може бути реалізовано тільки по черзі, різними транзакціями.

Відповідно, одна транзакція може завершитися успішно, а наступна -- з будь-якої причини не завершитися. Такий сценарій призводить до неконсистентності даних і необхідності видалення успішної операції із БД і повторного виконання процедури.

//TODO: Розглянути більш точний приклад
.Приклад
====
Наприклад, маємо три транзакції:

. Запис імені користувача (параметра `name`) до таблиці `user`. Операція успішна.
. Запис прізвища користувача (параметра `surname`) до таблиці `user`. Операція неуспішна.
. Запис налаштувань користувача (параметр `personProfileId`) до таблиці `person_profile`. Транзакція не розпочалася.

В результаті, база даних не консистентна. Виникає необхідність відкотити БД до попереднього стану, тобто видалити успішно записані дані через `DELETE`-ендпоінт.
====

Делегат `$dataFactoryConnectorNestedCreateDelegate` забезпечує можливість зберігати декілька сутностей до різних таблиць бази даних в рамках однієї транзакції.