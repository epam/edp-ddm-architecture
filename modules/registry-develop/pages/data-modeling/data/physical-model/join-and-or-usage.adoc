:toc-title: ЗМІСТ
:toc: auto
:toclevels: 5
:experimental:
:important-caption:     ВАЖЛИВО
:note-caption:          ПРИМІТКА
:tip-caption:           ПІДКАЗКА
:warning-caption:       ПОПЕРЕДЖЕННЯ
:caution-caption:       УВАГА
:example-caption:           Приклад
:figure-caption:            Зображення
:table-caption:             Таблиця
:appendix-caption:          Додаток
:sectnums:
:sectnumlevels: 5
:sectanchors:
:sectlinks:
:partnums:

= Сценарії використання операції JOIN із додатковими умовами AND та OR

== Загальний опис

Операція `*<ext:join>*` дозволяє поєднувати таблиці за певними умовами. Використовується при створенні критеріїв пошуку всередині тегу `*<ext:createSearchCondition>*` для отримання необхідних даних у зведених таблицях.

Є 3 основні типи поєднання таблиць за допомогою JOIN: ::

* *INNER JOIN* -- Перетин даних двох таблиць. Наприклад, *`<ext:join type="inner">`*.
* *LEFT JOIN* -- вивід даних з першої таблиці (зліва) та приєднання даних другої таблиці (справа), де це можливо. Наприклад, *`<ext:join type="left">`*.
* *RIGHT JOIN* -- протилежний до LEFT JOIN. Наприклад, *`<ext:join type="right">`*.

Операцію `*<ext:join>*` можна використовувати із додатковими умовами `*and*` та `*or*`, які визначаються в рамках тегу `*<ext:condition>*` як значення атрибута `*logicOperator*`.

== Приклади використання

Розглянемо приклади використання умови `JOIN` у критеріях пошуку та додаткові умови `AND` та `OR` в рамках рольової моделі та її окремого випадку із застосуванням довідників кодифікатора КАТОТТГ.

=== Передумови

Створіть дві таблиці для використання у критеріях пошуку та поєднання за допомогою `JOIN`.

. `<createTable tableName="katottg">` -- таблиця, що містить коди КАТОТТГ.
. `<createTable tableName="katottg_category"` -- таблиця, що містить категорії кодів КАТОТТГ.

.Таблиця "katottg"
====
[source,xml]
----
<changeSet id="table katottg" author="registry_owner">
        <createTable tableName="katottg" ext:historyFlag="true" remarks="katottg">
            <column name="katottg_id"  type="UUID" defaultValueComputed="uuid_generate_v4()"
                    remarks="Ідентифікатор katottg">
                <constraints nullable="false" primaryKey="true" primaryKeyName="pk_katottg_id"/>
            </column>

            <column name="code" type="TEXT" remarks="Код">
                <constraints nullable="true"/>
            </column>
			<column name="name" type="TEXT" remarks="Назва">
                <constraints nullable="true"/>
            </column>
			<column name="category" type="TEXT" remarks="Категорія">
                <constraints nullable="true"/>
            </column>
			<column name="level" type="INT">
                <constraints nullable="false"/>
            </column>
			<column name="katottg_parent_id" type="UUID">
                <constraints nullable="true"
                             foreignKeyName="fk_katottg_parent"
                             referencedTableName="katottg"
                             referencedColumnNames="katottg_id"/>
            </column>
        </createTable>
        <addUniqueConstraint tableName="katottg" columnNames="code"/>
    </changeSet>
----
====

.Таблиця "katottg_category"
====
[source,xml]
----
<changeSet id="table katottg_category" author="registry_owner">
        <createTable tableName="katottg_category" ext:historyFlag="true" remarks="katottg_category">
            <column name="katottg_category_id"  type="UUID" defaultValueComputed="uuid_generate_v4()"
                    remarks="Ідентифікатор">
                <constraints nullable="false" primaryKey="true" primaryKeyName="pk_katottg_category_id"/>
            </column>
            <column name="code" type="TEXT" remarks="Код">
                <constraints nullable="false"/>
            </column>
			<column name="name" type="TEXT" remarks="Назва">
                <constraints nullable="true"/>
            </column>
        </createTable>
        <addUniqueConstraint tableName="katottg_category" columnNames="code"/>
    </changeSet>
----
====

=== Сценарії

Створимо критерій пошуку `get_regions_or_city_regions`. На основі цього критерію пошуку буде створено ендпоінт у фабриці даних, який зможе повертати список усіх областей України, а також міста зі спеціальним статусом, їх коди КАТОТТГ, а також категорію коду КАТОТТГ, при виконанні певних умов запита, а саме:

* Об'єднати таблиці за допомогою `JOIN` та додатковою умовою `AND`:
+
[source,xml]
----
<ext:condition logicOperator="and" columnName="k.category" operator="eq"  value="'K'"/>
----

* Об'єднати таблиці за допомогою `JOIN` та додатковою умовою `OR`:
+
[source,xml]
----
<ext:condition logicOperator="or" columnName="k.category" operator="eq"  value="cat.code">
	<ext:condition logicOperator="and" columnName="k.category" operator="ne"  value="'K'"/>
	<ext:condition logicOperator="and" columnName="k.level" operator="eq"  value="'1'"/>
</ext:condition>
----

Залежно від умови, яку ви зазначаєте у запиті, формується й відповідний результат. Тобто формується вибірка з певної кількості записів, об'єднаних в одній зведеній таблиці.

==== Використання INNER JOIN без додаткових умов

.XML-схема. Використання INNER JOIN без додаткових умов
====
[source,xml]
----
<ext:createSearchCondition name="get_regions_or_citi_regions">
	<ext:table name="katottg" alias="k">
		<ext:column name="katottg_id" />
		<ext:column name="name" alias="name_region" searchType="startsWith" />
		<ext:column name="category" />
	</ext:table>
	<ext:table name="katottg_category" alias="cat">
		<ext:column name="name" alias="name_category" />
		<ext:column name="code" />
	</ext:table>
	<ext:join type="inner">
		<ext:left alias="k">
			<ext:column name="category" />
		</ext:left>
		<ext:right alias="cat">
			<ext:column name="code" />
		</ext:right>
	</ext:join>
</ext:createSearchCondition>
----
====

На виході Liquibase генерує наступний SQL-запит: ::
+
.SQL-запит. Використання INNER JOIN без додаткових умов
====
[source,sql]
----
CREATE
OR REPLACE VIEW registry.get_regions_or_citi_regions_v AS
SELECT
  k.katottg_id,
  k.name AS name_region,
  cat.name AS name_category,
  cat.code
FROM
  katottg k
  JOIN katottg_category cat
  ON k.category = cat.code

----
====

==== Використання INNER JOIN із додатковою умовою AND

.XML-схема. Використання INNER JOIN з умовою AND
====
[source,xml]
----
<ext:createSearchCondition name="get_regions_or_citi_regions">
	<ext:table name="katottg" alias="k">
		<ext:column name="katottg_id" />
		<ext:column name="name" alias="name_region" searchType="startsWith" />
		<ext:column name="category" />
	</ext:table>
	<ext:table name="katottg_category" alias="cat">
		<ext:column name="name" alias="name_category" />
		<ext:column name="code" />
	</ext:table>
	<ext:join type="inner">
		<ext:left alias="k">
			<ext:column name="category" />
		</ext:left>
		<ext:right alias="cat">
			<ext:column name="code" />
		</ext:right>
		<ext:condition logicOperator="and" columnName="k.category" operator="eq"  value="'K'"/>
	</ext:join>
</ext:createSearchCondition>
----
====

На виході Liquibase генерує наступний SQL-запит: ::
+
.SQL-запит. Використання INNER JOIN з умовою AND
====
[source,sql]
----
CREATE
OR REPLACE VIEW registry.get_regions_or_citi_regions_v AS
SELECT
  k.katottg_id,
  k.name AS name_region,
  cat.name AS name_category,
  cat.code
FROM
  katottg k
  JOIN katottg_category cat
  ON k.category = cat.code
  AND k.category = 'K' :: text;
----
====

Результат виконання запита буде таким: ::

Якщо об'єднати таблиці за допомогою `JOIN` із додатковою умовою `AND`, то ви отримаєте вибірку лише з 2-х записів:
+
.Результат запита за умовами JOIN + AND
image::data-modeling/data/physical-model/join-and-or-usage/join-and-or-usage-1.png[]

==== Використання INNER JOIN із додатковою умовою OR

.Використання INNER JOIN з умовою OR
====
[source,xml]
----
<ext:createSearchCondition name="get_regions_or_citi_regions">
	<ext:table name="katottg" alias="k">
		<ext:column name="katottg_id" />
		<ext:column name="name" alias="name_region" searchType="startsWith" />
		<ext:column name="category" />
	</ext:table>
	<ext:table name="katottg_category" alias="cat">
		<ext:column name="name" alias="name_category" />
		<ext:column name="code" />
	</ext:table>
	<ext:join type="inner">
		<ext:left alias="k">
			<ext:column name="category" />
		</ext:left>
		<ext:right alias="cat">
			<ext:column name="code" />
		</ext:right>
		<ext:condition logicOperator="or" columnName="k.category" operator="eq"  value="cat.code">
			<ext:condition logicOperator="and" columnName="k.category" operator="ne"  value="'K'"/>
			<ext:condition logicOperator="and" columnName="k.level" operator="eq"  value="'1'"/>
                </ext:condition>
	</ext:join>
</ext:createSearchCondition>
----
====

На виході Liquibase генерує наступний SQL-запит: ::
+
.SQL-запит. Використання INNER JOIN з умовою OR
====
[source,sql]
----
CREATE
OR REPLACE VIEW registry.get_regions_or_citi_regions_v AS
SELECT
  k.katottg_id,
  k.name AS name_region,
  cat.name AS name_category,
  cat.code
FROM
  katottg k
  JOIN katottg_category cat
  ON k.category = cat.code
  OR k.category = cat.code AND k.category <> 'K'::text AND k.level = 1;
----
====

Результат виконання запита буде таким: ::

Якщо об'єднати таблиці за допомогою `JOIN` із додатковою умовою `OR`, то ви отримаєте вибірку з 25 записів:
+
.Результат запита за умовами JOIN + OR
image::data-modeling/data/physical-model/join-and-or-usage/join-and-or-usage-2.png[]

==== Використання INNER JOIN із додатковими умовами AND та OR

.XML-схема. Використання INNER JOIN з умовами AND та OR
====
[source,xml]
----
<ext:createSearchCondition name="get_regions_or_citi_regions">
	<ext:table name="katottg" alias="k">
		<ext:column name="katottg_id" />
		<ext:column name="name" alias="name_region" searchType="startsWith" />
		<ext:column name="category" />
	</ext:table>
	<ext:table name="katottg_category" alias="cat">
		<ext:column name="name" alias="name_category" />
		<ext:column name="code" />
	</ext:table>
	<ext:join type="inner">
		<ext:left alias="k">
			<ext:column name="category" />
		</ext:left>
		<ext:right alias="cat">
			<ext:column name="code" />
		</ext:right>
		<ext:condition logicOperator="and" columnName="k.category" operator="eq"  value="'K'"/>
        <ext:condition logicOperator="or" columnName="k.category" operator="eq"  value="cat.code">
			<ext:condition logicOperator="and" columnName="k.category" operator="ne"  value="'K'"/>
			<ext:condition logicOperator="and" columnName="k.level" operator="eq"  value="'1'"/>
                </ext:condition>
	</ext:join>
</ext:createSearchCondition>
----
====

На виході Liquibase генерує наступний SQL-запит: ::
+
.SQL-запит. Використання INNER JOIN з умовами AND та OR
====
[source,sql]
----
CREATE
OR REPLACE VIEW registry.get_regions_or_citi_regions_v AS
SELECT
  k.katottg_id,
  k.name AS name_region,
  cat.name AS name_category,
  cat.code
FROM
  katottg k
  JOIN katottg_category cat
  ON k.category = cat.code
  AND k.category = 'K' :: text
  OR k.category = cat.code AND k.category <> 'K'::text AND k.level = 1;
----
====

Результат виконання запита буде таким: ::

Якщо об'єднати таблиці за допомогою `JOIN` із додатковими умовами `AND` та `OR`, то ви отримаєте вибірку з 27 записів:
+
.Результат запита за умовами JOIN + AND + OR
image::data-modeling/data/physical-model/join-and-or-usage/join-and-or-usage-3.png[]