= Що нового у версії 1.6?
:toc:
:toclevels: 5
:toc-title: ЗМІСТ
:sectnums:
:sectnumlevels: 5
:sectanchors:

== Моделювання
=== Моделювання бізнес-процесів
==== Підтримка бізнес-ключів

У цьому релізі було розроблено функціональність, що дозволяє створювати
_Ключ бізнес-процесу_ (*Business Key*) – специфічний для домену ідентифікатор
екземпляра бізнес-процесу у https://camunda.com/bpmn/reference/[Camunda BPM].

Ідентифікатор застосовується при моделюванні бізнес-процесів з метою їх
ідентифікації, а також для ідентифікації користувацьких задач процесу.

Бізнес-ключем може виступати будь-який окремий атрибут або сполучення бізнес-значимих
атрибутів конкретного бізнес-процесу чи користувацької задачі.

За допомогою бізнес-ключа користувач може відрізнити один бізнес-процес від іншого
(або одну користувацьку задачу від іншої) в переліку бізнес-задач особистих
Кабінетів посадової особи та отримувача послуг.

При моделюванні бізнес-ключ може застосовуватись у таких випадках:

* xref:registry-develop:bp-modeling/bp/modeling-facilitation/bp-business-keys.adoc#bp-key-start[Налаштування бізнес-ключа на старті процесу]
* xref:registry-develop:bp-modeling/bp/modeling-facilitation/bp-business-keys.adoc#bp-key-start-message-event[Налаштування бізнес-ключа на старті процесу, що ініційований стартовою подією «Повідомлення»]
* xref:registry-develop:bp-modeling/bp/modeling-facilitation/bp-business-keys.adoc#bp-key-bp-stage[Налаштування бізнес-ключа на етапі виконання процесу]

Таким чином, користувач має змогу швидко відрізнити бізнес-процес,
за виконання якого він відповідає, або виокремити певну задачу у цьому процесі,
серед тисяч інших записів, що доступні на сторінках інтерфейсу.

_Приклад. Відображення бізнес-ключа/ідентифікатора послуги в Кабінеті посадової особи_

image:registry-develop:bp-modeling/bp/bp-keys/bp-keys-officer-portal-bp.png[]

_Приклад. Відображення бізнес-ключа/ідентифікатора задачі в Кабінеті посадової особи_

image:registry-develop:bp-modeling/bp/bp-keys/bp-keys-officer-portal-task.png[]

'''

==== Підтримка часових обмежень
_«Таймер»_ (*Timer Event*) -- це подія, що активується таймером і визначає конкретний час, дату, або
інтервал, що обмежує тривалість виконання певного елементу бізнес-процесу. Кожен таймер має
свій час очікування.

Виділяють 2 типи подій _«Таймер»_, які наразі підтримує Платформа:

* *_Проміжна гранична переривальна подія часу_ (Time Intermediate Boundary Interrupting
Event)* -- подія, яка діє як секундомір і виконує обробку подій, активуючи таймер.
Коли таймер спрацьовує (наприклад, через певний інтервал), виконується потік послідовності,
що виходить із проміжної події таймера. На час очікування поточний потік виконання
бізнес-процесу не переривається.
+
Іншими словами, коли настає виконання елемента, до якого приєднано граничну подію,
потік продовжується. Коли таймер спрацьовує (наприклад, через певний проміжок часу),
активність анулюється, і виконується альтернативний потік послідовності, що виходить із
події таймера.
+
image:platform:registry-develop:bp-modeling/bp/events/timer-event/timer-event-02.png[]

* *_Проміжна оброблювальна подія часу_ (Time Intermediate Catch Event)* -- подія, яка виконує
роль секундоміра або будильника і перериває виконання бізнес-процесу у певній точці,
очікуючи перехід до виконання наступного елемента бізнес-процесу (тобто продовжує
виконання потоку послідовності). На час очікування поточний потік виконання бізнес-процесу призупиняється.
+
image:platform:registry-develop:bp-modeling/bp/events/timer-event/timer-event-03.png[]

Таймери, що використовуються при моделюванні подій _«Таймер»_, можуть бути визначені за:

* *_Датою_ (Date)*
+
_Таймер дати_ встановлює конкретний момент часу, визначений як комбіноване
представлення дати та часу за стандартом ISO 8601. Він повинен містити інформацію про
часовий пояс або зміщення зони від серверного часу. За бажанням, він може містити
ідентифікатор зони. _(детальніше за -- https://docs.camunda.io/docs/components/modeler/bpmn/timer-events/#time-date[посиланням])._
* *_Тривалістю_ (Duration)*
+
_Таймер тривалості_ встановлюється відповідно до формату тривалості ISO 8601, який
визначає кількість часу у певному часовому проміжку.
+
Наприклад, P14DT1H30M -- 14 днів,
1 година і 30 хвилин _(детальніше -- за https://docs.camunda.io/docs/components/modeler/bpmn/timer-events/#time-duration[посиланням])._
+
TIP: Якщо тривалість дорівнює нулю або від’ємна, таймер спрацьовує негайно.
* *_Циклом_ (Cycle)*
+
_Таймер циклу_ визначається як формат повторюваних інтервалів ISO 8601. Він містить
тривалість і кількість повторів. Наприклад, R5/PT10S -- повторювати кожні 10 секунд, 5
разів _(детальніше -- за https://docs.camunda.io/docs/components/modeler/bpmn/timer-events/#time-cycle[посиланням])._
+
TIP: Якщо повтори не визначені, таймер повторюється нескінченно, доки його не
скасують.

Таймери можна додати до будь-якої події _«Таймер»_, як то таймер початкової події, таймер
проміжної події або таймер оброблювальної події.

[TIP]
====
Детальну інформацію з моделювання і використання подій «Таймер» ви можете переглянути за посиланнями:

* xref:registry-develop:bp-modeling/bp/bpmn/events/timer-event.adoc#time-interm-boundary-interrupt-event[Моделювання граничної переривальної події часу]
* xref:registry-develop:bp-modeling/bp/bpmn/events/timer-event.adoc#time-interm-catch-event[Моделювання проміжної оброблювальної події часу]
====

'''

==== Підтримка подіі «З’єднання»

*_Подія «З’єднання»_ (Link Event)* є елементом BPMN-моделювання, що дозволяє поєднати дві
частини бізнес-процесу і діє як портал.

image:platform:registry-develop:bp-modeling/bp/bp-links/link-event-01.png[]

Вона не впливає на вміст бізнес-процесу, але полегшує процес створення
BPMN-діаграм і надає можливість змоделювати два пов'язаних посилання, як альтернативу
потоку послідовності (sequence flow).

Події _«З’єднання»_ є особливо корисними, коли необхідно:

* розподілити діаграму процесу на кількох сторінках: посилання орієнтують читача з однієї
сторінки на іншу.
* змоделювати складні діаграми процесів з багатьма потоками послідовностей: посилання
допомагають уникнути того, що інакше могло б виглядати як довга «спагетті»-діаграма.

NOTE: Подія «З’єднання» Link застосовується лише в рамках одного бізнес-процесу, тобто не
може пов'язати батьківський процес та підпроцес або два та більше відокремлених
бізнес-процеси.

Виділяють 2 типи подій _«З’єднання»_:

* *_Подія, що ініціює з’єднання_ (Link Intermediate Throw Event)* -- є вихідною точкою
(точкою А) однієї секції бізнес-процесу для сполучення з іншою секцією бізнес-процесу;
* *_Подія з’єднання оброблювальна_ (Link Intermediate Catch Event)* -- є вхідною точкою
(точкою Б) секції бізнес-процесу, з якою сполучається інша секція бізнес-процесу.

Елементи *Link Intermediate Throw Event* та *Link Intermediate Catch Event* надають можливість
поєднувати дві частини бізнес-процесу -- *source* (вихідна точка) і *target* (вхідна точка) відповідно —
в єдиний потік.

[TIP]
====
Детальну інформацію щодо моделювання і налаштування події «З'єднання» ви можете переглянути за посиланнями:

* xref:registry-develop:bp-modeling/bp/bpmn/events/bp-link-events.adoc#link-throw-event[Моделювання та налаштування події, що ініціює з’єднання]
* xref:registry-develop:bp-modeling/bp/bpmn/events/bp-link-events.adoc#link-catch-event[Моделювання та налаштування оброблювальної події «З’єднання»]
====

'''

==== Підтримка обміну повідомленнями при взаємодії бізнес-процесів

*_Подія «Повідомлення»_ (Message Event)* — це подія у бізнес-процесі, яка використовується для
передачі інформації від одного бізнес-процесу до іншого бізнес-процесу або підпроцесу.

Згенероване вихідне повідомлення (подія-відправник) активує елемент, що приймає повідомлення
(подія-одержувач), який з ним пов'язаний.

image:platform:registry-develop:bp-modeling/bp/events/message-event/message-event-01.png[]

Елементи події, що надсилають та приймають повідомлення, _повинні бути взаємопов'язаними_
та мати відповідні налаштування обміну інформацією.

При моделюванні застосовуються такі типи подій повідомлення:

* *_Кінцева подія повідомлення_ (Message End Event)* — подія, що моделюється при завершенні бізнес-процесу чи підпроцесу, і яка налаштовується для відправки масиву даних, певних атрибутів або тестового повідомлення.
* *_Стартова подія повідомлення_ (Message Start Event)* — подія, що моделюється при ініціюванні старту нового бізнес-процесу чи підпроцесу, і яка налаштовується для отримання масиву даних, певних атрибутів або тестового повідомлення від елемента *End Message Event* або *Message Intermediate Throw Event*.
* *_Проміжна подія відправки повідомлення_ (Message Intermediate Throw Event)* — подія, що моделюється при проходженні бізнес-процесу чи підпроцесу, і яка налаштовується для відправки масиву даних, певних атрибутів або тестового повідомлення.
* *_Проміжна подія отримання повідомлення_ (Message Intermediate Catch Event)* — подія, що моделюється при проходженні бізнес-процесу чи підпроцесу, і яка налаштовується для отримання масиву даних, певних атрибутів або тестового повідомлення від елемента *End Message Event* або *Message Intermediate Throw Event*.

[TIP]
====
Детальну інформацію щодо моделювання і налаштування події «Повідомлення» ви можете переглянути за посиланнями:

* xref:registry-develop:bp-modeling/bp/bpmn/events/message-event.adoc#message-end-event[Моделювання та налаштування кінцевої події повідомлення]
* xref:registry-develop:bp-modeling/bp/bpmn/events/message-event.adoc#message-start-event[Моделювання та налаштування стартової події повідомлення]
* xref:registry-develop:bp-modeling/bp/bpmn/events/message-event.adoc#message-intermediate-throw-event[Моделювання та налаштування проміжної події відправки повідомлення]
* xref:registry-develop:bp-modeling/bp/bpmn/events/message-event.adoc#message-intermediate-catch-event[Моделювання та налаштування проміжної події отримання повідомлення]
====

'''

==== Підтримка ексклюзивного шлюзу, що керується подіями

*_Ексклюзивний шлюз, що керується подіями_ (Event-based Gateway)* — логічний оператор
виключаючого _АБО_, який керується подіями (повідомлення, таймер, умова тощо) і
дозволяє приймати рішення на основі цих подій. Використовується для вибору
альтернативного маршруту у процесі.

image:registry-develop:bp-modeling/bp/gateways/event-based-gw/event-based-gw-01.png[]

Ексклюзивний шлюз, що керується подіями, повинен мати принаймні два вихідні потоки
послідовності. Вихідні потоки управління цього шлюзу повинні пов'язуватися лише з _проміжними
подіями обробки_ *(Intermediate Catching Event)* або _приймальними задачами_ *(Receive Task)*.

NOTE: Платформа реєстрів наразі підтримує 2 типи подій, з якими може взаємодіяти елемент
Event-based Gateway: «Таймер» і «Повідомлення».

Коли шлюз активується, екземпляр процесу чекає на шлюзі, доки не буде запущена
одна з подій. Потік управління бізнес-процесом спрямовується тією гілкою,
де подія відбулася/задача виконалася першою. Решта подій будуть проігноровані.

[TIP]
====
Детальну інформацію щодо моделювання ексклюзивного шлюзу ви можете переглянути за посиланням:

* xref:registry-develop:bp-modeling/bp/bpmn/gateways/event-based-gateway.adoc#_моделювання_ексклюзивного_шлюзу_що_керується_подіями[Моделювання ексклюзивного шлюзу, що керується подіями]
====

'''

==== Підтримка вбудованих та глобальних підпроцесів

Моделювання бізнес-процесів передбачає можливість виклику різних типів підпроцесів із основного/батьківського
процесу.

Ці підпроцеси відрізняються за механізмом їх ініціювання та виконання і поділяються на:

* _Вбудований підпроцес (Embedded subprocess)_
* _Глобальний підпроцес (Call Activity)_
* _Подієвий підпроцес (Event Subprocess)_

*_Вбудований підпроцес (Embedded subprocess)_*

Вбудований підпроцес -- це процес, що налаштовується та запускається всередині основного (батьківського)
бізнес-процесу.

Вбудований підпроцес дозволяє НЕ виконувати два бізнес-процеси окремо, щоразу входячи до Кабінету
користувача та запускаючи кожний послідовно. Натомість вбудований підпроцес покликаний забезпечити
плавний перехід між бізнес-процесами, без розриву основного процесу та підпроцесу, і повернення назад
до основного процесу.

Наприклад, основний процес має на меті внести дані про заяву, але він також вимагає попередньо погодити
внесення змін уповноваженою особою. Погодження змін логічно і зручно винести в окремий вбудований процес,
таким чином розділяючи два процеси між собою, і водночас не порушуючи єдиний потік послідовності.

image:platform:registry-develop:bp-modeling/bp/subprocesses/embedded-subprocess/embedded-subprocess-1.png[]

Вбудований підпроцес повинен мати тільки одну подію -- *none start*.

Старт вбудованого процесу ініціюється подією Start event. Підпроцес залишається активним, допоки активним
залишається хоча б один елемент у контейнері з підпроцесом. Коли останній елемент підпроцесу, тобто фінальна
подія виконується, підпроцес завершується, і продовжується вихідний потік послідовності у батьківському процесі.

[TIP]
====
Детальну інформацію з використання вбудованого підпроцесу ви можете переглянути за посиланням:

* xref:registry-develop:bp-modeling/bp/bpmn/subprocesses/embedded-subprocess.adoc#_використання_вбудованого_підпроцесу_при_моделюванні[Використання вбудованого підпроцесу при моделюванні]
====

*_Глобальний підпроцес (Call Activity)_*

*Call Activity* _(або підпроцес, який можна використовувати повторно)_ — це стандартний елемент BPMN-моделювання,
що підтримує Camunda Engine, який дозволяє викликати інший процес як частину поточного процесу.
Він подібний до вбудованого підпроцесу, але є зовнішнім, тобто змодельованим в рамках окремого пулу
бізнес-процесу, і може використовуватися неодноразово та декількома різними батьківськими бізнес-процесами.

image:registry-develop:bp-modeling/bp/subprocesses/call-activities/bp-call-activity-01.png[]

У Camunda BPMN виклики глобального, тобто зовнішнього підпроцесу, можуть виконуватися між процесами,
що змодельовані в окремих файлах `.bpmn`, або ж в рамках одного файлу `.bpmn`. Таким чином один незалежний
бізнес-процес може запускати інший і навпаки.

Платформа реєстрів наразі підтримує лише один тип — виклик глобального підпроцесу з основного (батьківського) процесу.
З глобального підпроцесу можна також виконати виклик *Call Activity* — підпроцес 2-го рівня
_(див. xref:registry-develop:bp-modeling/bp/bpmn/subprocesses/call-activities.adoc#restrictions[Обмеження рівнів вкладеності при викликах підпроцесів за допомогою Call Activity])._

._Приклад. Виклик між процесами, змодельованими в окремих файлах BPMN_

image:registry-develop:bp-modeling/bp/subprocesses/call-activities/call-activity-separate-bpmn.png[]

._Приклад. Виклик підпроцесу із основного процесу в рамках одного файлу BPMN_

image:registry-develop:bp-modeling/bp/subprocesses/call-activities/call-activity-same-bpmn.png[]

Коли елемент Call Activity вводиться в дію, створюється новий екземпляр процесу,
на який він посилається. Новий екземпляр процесу активується під час події *none start*.
Процес може мати стартові події інших типів, але вони ігноруються.

[TIP]
====
Коли створений екземпляр процесу завершується, дія виклику припиняється, і продовжується
виконання вихідного потоку послідовності.

Іншими словами як тільки виконано виклик *Call Activity*, процес, що ініціював виклик
(основний процес), чекає на завершення глобального підпроцесу,
і тільки після цього продовжується.
====

Для спрощення моделювання бізнес-процесів в рамках Платформи реєстрів,
імплементовано декілька типів розширень (делегатів), що налаштовуються за допомогою
розроблених шаблонів елементів для виклику зовнішніх процесів (*Call Activity*):

* *xref:platform:registry-develop:bp-modeling/bp/bp-element-templates-installation-configuration.adoc#bp-element-temp-call-activity-call-activity[Call Activity]* — загальний шаблон для виклику глобального (зовнішнього) підпроцесу;
* *xref:platform:registry-develop:bp-modeling/bp/bp-element-templates-installation-configuration.adoc#element-temp-system-digital-signature[System digital signature]* — специфікований шаблон для виклику підпроцесу підпису даних системним ключем;
* *xref:platform:registry-develop:bp-modeling/bp/bp-element-templates-installation-configuration.adoc#element-temp-check-excerpt-status[Check excerpt status]* — специфікований шаблон для виклику підпроцесу перевірки статусу витягу.
+
[CAUTION]
====
Варто розрізняти *Call Activity* як стандартний BPMN-елемент і *Call Activity* як розширення
цього самого елемента, що налаштовується за допомогою розробленого шаблону `callActivity.json`,
призначеного для виклику глобального (зовнішнього) підпроцесу.
====

[TIP]
====
Детальну інформацію щодо моделювання глобального підпроцесу ви можете переглянути за посиланням:

* xref:registry-develop:bp-modeling/bp/bpmn/subprocesses/call-activities.adoc#element-temp-call-activity[Моделювання бізнес-процесів із застосуванням розширень Call Activity]
====

*_Подієвий підпроцес_ (Event Subprocess)*

_Подієвий підпроцес_ -- це процес, що ініційований подією.
Такий підпроцес починає виконуватися, якщо ініціюється його початкова подія.
Він може переривати батьківський процес або виконуватися паралельно з ним;
може виконуватися один або декілька разів, або не виконуватися взагалі.

Подієвий підпроцес повинен містити хоча б одну стартову подію.

image:platform:registry-develop:bp-modeling/bp/subprocesses/event-subprocess/event-subprocess-01.png[]

Для ініціювання подієвого підпроцесу можуть бути використані наступні типи подій:

* *_Подія «Повідомлення» (Message Event)_*
+
Подія у бізнес-процесі, яка використовується для передачі інформації від одного бізнес-процесу до іншого бізнес-процесу або підпроцесу за допомогою повідомлення.
* *_Подія «Помилка» (Error Event)_*
+
Під час автоматизації процесів можна часто стикнутися із відхиленнями від стандартного сценарію. Одним зі способів усунути відхилення є використання BPMN-події «Помилка», що дозволяє моделі бізнес-процесу реагувати на передбачені сценаріями помилки в рамках виконання задачі.

[NOTE]
====
_Початкова подія, викликана помилкою (Error Start Event)_, може використовуватися лише для запуску подієвого підпроцесу.
====
Подію «Помилка» не можна використовувати для запуску екземпляра процесу.
Початкова подія, викликана помилкою, є завжди переривальною.

[TIP]
====
Детальну інформацію щодо моделювання подієвого підпроцесу ви можете переглянути за посиланнями:

* xref:registry-develop:bp-modeling/bp/bpmn/subprocesses/event-subprocess.adoc#_моделювання_вбудованого_підпроцесу_ініційованого_подією_повідомлення[Моделювання вбудованого підпроцесу, ініційованого подією «Повідомлення»]
* xref:registry-develop:bp-modeling/bp/bpmn/events/error-event.adoc[]
====

'''

==== Підтримка транзакційного підпроцесу

*_Транзакційний підпроцес_ (Transaction subprocess)* — це процес, за допомогою якого
реалізується моделювання бізнес-сценаріїв з транзакціями, виконання яких може
тривати багато днів або тижнів, доки не буде завершено набір всіх активностей бізнес-процесу.

*_Транзакція_ (Transaction)* — це набір активностей, які становлять логічну
одиницю операції, що мають виконуватися неподільно. Такий процес регулюється
спеціальним протоколом (визначеним у середовищі виконання), який забезпечує або
повне виконання або повне скасування\анулювання всіх активностей транзакційного бізнес-процесу.

Транзакція може мати один з трьох наступних результатів:

* Транзакція вважається успішною, якщо всі дії у процесі успішно виконані, процес
продовжується у звичайному режимі. Такий підпроцес транзакції, за потреби, може
потім компенсуватися подією компенсації (*Compensation Event*).
* Транзакція завершується помилкою, якщо підпроцес закінчується подією помилки
(*Error Event*), яка не обробляється в межах підпроцесу транзакції. Тоді транзакції перериваються
без будь-якої компенсації, а процес продовжується із проміжною подією помилки.
* Транзакція скасовується, якщо виконання досягає події завершення скасування
(*Cancel Event*). Усі дії, які вже були виконані в рамках процесу, при цьому необхідно
припинити та скасувати. Це досягається шляхом виконання компенсаційних заходів
(наразі робота елемента Compensation Event не розглядається). Після компенсації,
виконання продовжується за потоком(-ами) вихідної послідовності граничної події скасування.

[TIP]
====
Детальну інформацію з моделювання транзакційного підпроцесу ви можете переглянути за посиланням:

* xref:registry-develop:bp-modeling/bp/bpmn/subprocesses/transaction-subprocess/transaction.adoc[]
====

Моделювання граничної переривальної події «Скасування» та кінцевої події «Скасування» ::

При моделюванні транзакційних підпроцесів, для ініціювання та обробки скасування
транзакції застосовуються події скасування.
+
Елемент подія *_«Скасування»_ (Cancel Event)* використовується лише при моделюванні транзакцій.
+
Виділяють 2 типи подій скасування:

* *_Кінцева подія скасування_ (Cancel End Event)* — подія, що моделюється при завершенні
скасування транзакційного підпроцесу. Коли досягається подія завершення скасування,
створюється подія скасування, яка повинна бути перехоплена граничною подією скасування.
* *_Гранична переривальна подія скасування_ (Cancel Boundary Interrupting Intermediate Event)*
— подія, що моделюється на межі підпроцесу транзакції як перехоплювальна проміжна
подія скасування. Така подія ініціюється, коли транзакція скасовується елементом
Cancel End Event.
+
[TIP]
====
Детальну інформацію щодо моделювання та налаштування події «Скасування» ви можете переглянути за посиланням:

* xref:registry-develop:bp-modeling/bp/bpmn/subprocesses/transaction-subprocess/cancel-event.adoc[]
====

Моделювання події «Помилка» у транзакційному підпроцесі ::

Якщо змодельований транзакційний підпроцес закінчується подією _«Помилка»_
(*Error Event*), то транзакція не може бути виконана. Така помилка не обробляється
в межах підпроцесу, і транзакція переривається без будь-якої компенсації.
Батьківський бізнес-процес продовжується із проміжною подією __«Помилка» __
(*Error Boundary Interrupting Intermediate Event*) на межі транзакційного підпроцесу.
+
В рамках моделювання застосовують 2 типи подій _«Помилка»_:

* *_Кінцева подія «Помилка»_ (Error End Event)* -- подія, що моделюється при завершенні
транзакційного підпроцесу помилкою. Коли досягається подія «Помилка», всі активні
потоки процесу припиняються, й помилка має бути перехоплена граничною подією
_«Помилка»_.
* *_Гранична переривальна подія помилки_ (Error Boundary Interrupting Intermediate Event)* -- подія,
що моделюється на межі підпроцесу транзакції як перехоплювальна проміжна
подія _«Помилка»_. Така подія ініціюється, коли транзакція закінчується елементом
*Error End Event*.
+
[TIP]
====
Детальну інформацію щодо моделювання події «Помилка» у транзакційному підпроцесі ви можете переглянути за посиланнями:

* xref:registry-develop:bp-modeling/bp/bpmn/subprocesses/transaction-subprocess/error-event-transaction.adoc[]
====

'''

==== Перегляд назв послуг основних бізнес-процесів у кабінеті користувача

У цьому релізі ми реалізували функціональність, що дозволяє користувачу бачити
лише основні бізнес-процеси у виконанні.

Відображення всіх бізнес-процесів з їх підпроцесами в інтерфейсі кабінету користувача
може створювати занадто довгий ланцюг записів, що є незручним при використанні кабінету.
Тому, при наявності двох або трьох рівнів вкладеності, тільки перший рівень -- основний процес -
буде відображено на вкладці «Мої послуги», в той час, як підпроцеси 1-го та 2-го рівнів
візуалізовано не буде.

Наприклад, бізнес-процес внесення даних потребує виклику підпроцесу погодження змін
(підпис за допомогою системного ключа). Процес внесення даних є основним, тоді як процес
погодження змін є глобальним підпроцесом 1-го рівня, що був викликаний з основного процесу
за допомогою елемента Call Activity. Таким чином, в інтерфейсі користувача відображатиметься
тільки один з двох ініційованих процесів -- основний бізнес-процес.

'''

==== Розробка SOAP-інтеграційних розширень до бізнес-процесів

Для виклику зовнішніх сервісів через ШБО "Трембіта", на Платформі реєстрів розроблено типові інтеграційні розширення-конектори, що дозволяють комунікувати через інтерфейс ШБО із зовнішніми сервісами за протоколом SOAP. Кожний конектор є делегатом, який використовується у бізнес-процесах для отримання даних із реєстрів поза межами Платформи.

У цьому релізі розроблено типові інтеграційні конектори для отримання інформації із зовнішнього сервісу ДРАЦС, налаштування яких відбувається на схемах бізнес-процесів у додатку Camunda Modeler.

Наразі імплементовано 2 типи конекторів для отримання даних із ДРАЦС:

. Типове інтеграційне розширення-конектор до SOAP-сервісу ДРАЦС для отримання даних Свідоцтва про народження за вказаними серією і номером Свідоцтва, та датою народження -- `GetCertByNumRoleBirthDate`.
. Типове інтеграційне розширення-конектор до SOAP-сервісу ДРАЦС для отримання даних Свідоцтва про народження за вказаними серією і номером Свідоцтва, та ПІБ — `GetCertByNumRoleNames`.

Щоб мати змогу використовувати розроблені на Платформі SOAP-інтеграційні конектори до зовнішніх сервісів та отримувати інформацію від інших реєстрів через ШБО "Трембіта", реалізовано можливість виконувати конфігурації на рівні регламенту реєстру в окремому файлі _bp-trembita/configuration.yml_.

[TIP]
====
Детальну інформацію з описом SOAP-інтеграційних розширень до бізнес-процесів ви можете переглянути за посиланнями:

* xref:registry-develop:bp-modeling/external-integration/api-call/connectors-external-registry.adoc#extension-conectory_for_retrieving_data_from_DRACS[Розширення-конектори для отримання даних із ДРАЦС]

* xref:registry-develop:registry-admin/external-integration/api-call/external-services-connection-config.adoc[]

====

'''

==== Підтримка функціональності часткового оновлення сутності в базі даних

Розроблено типове інтеграційне розширення (делегат), яке дозволяє виконувати операції часткового оновлення сутності (таблиці у базі даних) – *partialUpdate*. Тобто імплементовано можливість оновлювати значення конкретних параметрів у таблиці БД.

Делегат використовує метод `PATCH` для інтеграції із Фабрикою даних. Цей метод ігнорує всі незаповнені поля, не зазначені у тілі запита. Він опрацьовує лише ті параметри, які потребують оновлення.

Реалізовано також відповідний шаблон делегата `Update entity in data factory partially`, доступний для використання у застосунку Camunda Modeler на рівні моделювання бізнес-процесів.

[TIP]
====
Детальну інформацію з описом функціональності ви можете переглянути за посиланнями:

* xref:registry-develop:bp-modeling/bp/modeling-facilitation/partial-update.adoc[Часткове оновлення сутності у Фабриці даних]
* xref:registry-develop:bp-modeling/bp/bp-element-templates-installation-configuration.adoc#update_entity_in_data_factory_partially[Опис інтеграційного розширення]
====

'''

==== Підтримка розмежування доступу організацій до бізнес-процесів на рівні атрибутів користувачів

З метою розмежування доступу організацій до бізнес-процесів на рівні атрибутів
користувачів, розроблено типове розширення до бізнес-процесів — делегат
`${getUsersByAttributesFromKeycloak}`, для якого імплементовано однойменний шаблон
*Get users by attributes from keycloak*, представлений у вигляді JSON-файлу
_getUsersByAttributesFromKeycloak.json_.

Делегат потрібний для того, щоб при виконанні бізнес-процесу отримувати список користувачів
(посадових осіб) за певними атрибутами із сервісу керування ідентифікацією та доступом *Keycloak*.

Виконати пошук у *Keycloak* можливо за такими атрибутами:

* `edrpou`, тобто ідентифікаційним номером суб'єкта Єдиного державного реєстру підприємств
і організацій (ЄДРПОУ);
* `drfo`, тобто ідентифікаційним номером фізичної особи у Державному реєстрі фізичних
осіб—платників податків (ДРФО).

Кожна посадова особа певної організації має такі атрибути у сервісі *Keycloak*.
У результаті виконання запита, до бізнес-процесу повертається список імен користувачів
_(наприклад, username1, username2 тощо)_.

Цей список імен можна надалі застосовувати при виконанні користувацької задачі
бізнес-процесу у полі *Candidate users*.

*Candidate users* — користувачі, уповноважені до виконання задачі.
Тобто це параметр, який потрібен для того, щоб розмежувати доступ до конкретних
задач бізнес-процесу між користувачами.

[TIP]
====
Детальну інформацію з описом функціональності ви можете переглянути за посиланням:

* xref:registry-develop:bp-modeling/bp/access/bp-limiting-access-keycloak-attributes.adoc[]
====

'''

==== Збереження декількох сутностей в рамках однієї транзакції

Для збереження декількох сутностей в рамках однієї транзакції, розроблено типове
розширення до бізнес-процесів -- делегат `${dataFactoryConnectorNetsedCreateDelegate}`,
для якого імплементовано однойменний шаблон *Create nested entities in data factory*,
представлений у вигляді JSON-файлу _dataFactoryConnectorNestedCreateDelegate.json_.

За допомогою делегата `${dataFactoryConnectorNetsedCreateDelegate}` реалізовано
можливість створення декількох записів з однієї сервісної задачі.

Для того, щоб делегат міг функціонувати, на рівні Фабрики даних реалізована можливість
створення вкладених сутностей (nested entities), тобто імплементовано окремий спеціальний
ендпоінт, щоб приймати комплексні (вкладені) об'єкти, що містять декілька сутностей,
і створювати відповідні записи у різних таблицях бази даних за одну транзакцію.

Після опрацювання на рівні API, Фабрика даних сама розкладе дані до належних таблиць.

Для подальшого використання комплексного об'єкта та його збережених сутностей у
бізнес-процесі, необхідно отримати ID транзакції, в рамках якої був записаний цей об’єкт.
Після отримання ID, стає можливим виконати пошук за певними даними, що збереглися
в рамках такої транзакції.

[TIP]
====
Детальну інформацію з описом функціональності ви можете переглянути за посиланням:

* xref:registry-develop:bp-modeling/bp/modeling-facilitation/bp-nested-entities-in-data-factory.adoc[]
====

'''

=== Моделювання форм

==== Локалізація компонентів Form.IO

Моделювання форм до бізнес-процесів відбувається у Кабінеті адміністратора регламентів
за допомогою додатка FormIO. Це дозволяє забезпечити зв'язок між користувацькими формами,
необхідними для внесення даних до БД, та API рівнів виконання бізнес-процесів і фабрики даних.

Деякі компоненти інтерфейсу моделювання FormIO на адміністративному порталі було локалізовано:

* Прі виборі місяця і дня тижня, наведені нижче компоненті фільтрів Date/Time
відображаються українською мовою:

** місяці: Січень, Лютий, Березень, Квітень, Травень, Червень, Липень, Серпень, Вересень, Жовтень, Листопад, Грудень;
** дні тижня: Пн, Вт, Ср, Чт, Пт, Сб, Нд.

+
image:release-notes:what’s-new-1.6-3.png[]

* При клієнтській валідації опис помилок відображається українською мовою.
+
image:release-notes:what’s-new-1.6-4.png[]

'''

== Адміністрування реєстру

=== Автоматична валідація змін до регламенту реєстру

У цьому релізі імплементовано додаткову автоматичну валідацію змін до регламенту при його розгортанні. Це зроблено для уникнення помилок при ручному валідуванні регламенту під час процедури перевірки коду (Code Review), та з метою покращення безпекових складових при роботі з регламентом реєстру.

Автоматична валідація змін до регламенту наразі передбачає:

. Перевірку регістрів при налаштуванні зовнішніх ключів у моделі даних.
. Перевірку регістрів при налаштуванні ролей посадових осіб.
. Перевірку на дублювання та унікальність атрибутів у формах бізнес-процесів.
. Перевірку на унікальність значення ідентифікатора бізнес-процесу.

image:registry-develop:registry-admin/regulations-deploy/auto-validation/registry-regulations-auto-validation-8.png[]

[TIP]
====
Детальну інформацію з описом функціональності ви можете переглянути за посиланням:

* xref:registry-develop:registry-admin/regulations-deploy/registry-regulations-auto-validation.adoc[]
====

== Моделювання структур даних

=== Підтримка нових тегів у бібліотеці функціональних розширень Liquibase

У цьому релізі розширено можливості для моделювання структур даних реєстру за допомогою впровадження нових нетипових тегів _(Change Types)_ у модулі `liquibase-ddm-ext`. Це дозволяє застосовувати нові сценарії моделювання схем даних, використовуючи розширені теги.

До таких розширень належать:

* видалення типів даних (`dropType`);
* видалення користувацьких типів даних (`dropDomain`);
* видалення критерію пошуку (`dropSearchCondition`);
* визначення точок інтеграції з ШБО "Trembita" (`exposeSearchCondition`);
* створення/видалення аналітичного представлення  (`createAnalyticsView/dropAnalyticsView`);
* створення індексу (`createAnalyticsIndex`);
* збереження декількох сутностей в рамках однієї транзакції (`createCompositeEntity`);
* генерація ендпоінтів для часткового оновлення сутності в БД (`partialUpdate`);
* надання/видалення доступу до всіх аналітичних представлень (`grantAll/revokeAll`);
* надання/видалення доступу до окремого аналітичного представлення (`grant/revoke`).

[TIP]
====
Детальну інформацію щодо підтримки нових розширених тегів Liquibase ви можете переглянути за посиланням:

* xref:registry-develop:data-modeling/data/physical-model/liquibase-ddm-ext.adoc[]
====

== Кабінети отримувача послуг / посадової особи

=== Підтримка послідовного переходу між задачами користувачів кабінетів

Ми розробили функціональність, що забезпечує плавний перехід між процесами та їх
підпроцесами, не порушуючи єдиного ланцюжка виконання бізнес-процесу.

Послідовний або плавний перехід (Smooth-перехід) імплементовано для:

* xref:registry-develop:bp-modeling/bp/bpmn/subprocesses/embedded-subprocess.adoc[вбудованого підпроцесу];
* xref:registry-develop:bp-modeling/bp/bpmn/subprocesses/event-subprocess.adoc[вбудованого подієвого підпроцесу];
* xref:registry-develop:bp-modeling/bp/bpmn/subprocesses/call-activities.adoc[виклику глобального підпроцесу Call activity];
* xref:registry-develop:bp-modeling/bp/bpmn/events/bp-link-events.adoc[події "З'єднання"].

Наприклад, вбудований підпроцес дозволяє НЕ виконувати два бізнес-процеси окремо,
щоразу виходячи до Кабінету користувача та запускаючи кожний послідовно.
Натомість, вбудований підпроцес забезпечує плавний перехід між бізнес-процесами,
без розриву основного процесу та підпроцесу, і повернення назад до основного процесу.

image:registry-develop:bp-modeling/bp/subprocesses/embedded-subprocess/embedded-subprocess-1.png[]

'''

=== Повідомлення про успішне виконання задач у Кабінеті посадової особи

Для чіткішої роботи, ми вдосконалили систему нотифікацій,
що надходять до кабінету користувача у процесі виконання задач.

Так, було створено можливість отримувати повідомлення про успішне
виконання задачі в Кабінеті посадової особи:

* У верхньому правому куті сторінки буде відображено нотифікацію
зеленого кольору, що сповіщає про успішне виконання задачі.
* Повідомлення містить наступну інформацію: «Вітаємо! Задача
`«назва задачі»` виконана успішно!»
* Нотифікація відображається протягом 8 секунд, якщо користувач
не закриє її раніше або не виконає перехід до іншої сторінки.

image:platform:user:notifications/notifications-success-6.png[]

[TIP]
====
Детальну інформацію з описом функціональності ви можете переглянути за посиланням:

* xref:platform:user:user-notifications-success-task.adoc[]
====

'''

=== Сортування та пагінація задач у Кабінеті посадової особи

Для розширення можливостей інтерфейсу Кабінету посадової особи, а також
сприянню використовності, ми розробили функції сортування та пагінації задач.

Це надає можливість:

* розбивати на сторінки чергу задач (задачі для виконання) у Кабінеті;
* розбивати на сторінки перелік виконаних задач;
* сортувати задачі у черзі згідно з датою та часом їх створення;
* сортувати задачі, виконані посадовою особою, згідно з датою та часом їх створення й виконання.

'''

==== Пагінація задач

*_Пагінація_* -- це розбивка величезного масиву даних (зазвичай однотипного)
на невеликі за обсягом сторінки, із відображенням нумерованої навігації.

Користувач може налаштувати інтерфейс, обравши кількість записів на сторінці.

image:user:officer-task-sorting-pagination/officer-task-sorting-pagination-4.png[]

'''

==== Сортування задач

Сортування задач у черзі за датою та часом їх створення/виконання може бути
низхідним (найновіші вгорі) та висхідним (найдавніші вгорі).

За допомогою фільтра користувач обирає потрібний формат.

_На вкладці «Задачі для виконання»_:

image:user:officer-task-sorting-pagination/officer-task-sorting-pagination-8.png[]

_На вкладці «Виконані задачі»_:

image:user:officer-task-sorting-pagination/officer-task-sorting-pagination-9.png[]

[TIP]
====
Детальний опис функціональності ви можете переглянути за посиланням:

* xref:user:officer/sorting-pagination/officer-portal-task-sorting-pagination.adoc[]
====

'''

=== Сортування та пагінація послуг у Кабінеті отримувача послуг / посадової особи

Для розширення можливостей інтерфейсу кабінетів користувача,
а також сприянню використовності, ми розробили функції сортування та
пагінації послуг.

Це надає можливість:

* розбивати на сторінки перелік бізнес-процесів у виконанні;
* розбивати на сторінки перелік завершених бізнес-процесів;
* сортувати бізнес-процеси у виконанні за датою і часом їх старту;
* сортувати завершені бізнес-процеси за датою і часом їх старту та датою завершення.

==== Пагінація послуг

_Пагінація_ -- це розбивка величезного масиву даних (зазвичай однотипного)
на невеликі за обсягом сторінки, із відображенням нумерованої навігації.

Користувач може налаштувати кількість записів на одній сторінці.

_На вкладці «Послуги у виконані»_:

image:user:officer-bp-sorting-pagination/officer-bp-sorting-pagination-2.png[]

_На вкладці «Надані послуги»_:

image:user:officer-bp-sorting-pagination/officer-bp-sorting-pagination-4.png[]

==== Сортування послуг

Сортування бізнес-процесів у виконанні та завершених бізнес-процесів
за датою і часом їх старту/завершення може бути _низхідним_ (найновіші вгорі)
та _висхідним_ (найдавніші вгорі).

Користувач може налаштувати сортування бізнес-процесів за допомогою
фільтрів `«Дата старту»` і `«Дата завершення».`

_На вкладці «Послуги у виконанні»_:

image:user:officer-bp-sorting-pagination/officer-bp-sorting-pagination-5.png[]

_На вкладці «Надані послуги»_:

image:user:officer-bp-sorting-pagination/officer-bp-sorting-pagination-6.png[]

[TIP]
====
Детальний опис функціональності представлений за посиланням:

* xref:user:officer/sorting-pagination/officer-portal-bp-sorting-pagination.adoc[]
====

'''

=== Формування витягів у Кабінеті отримувача послуг

Функціональність Кабінету отримувача послуг дозволяє замовити та отримати
витяг на підставі даних реєстру.

Процес включає декілька етапів:

* Попереднє замовлення;
* Завантаження та перегляд.

Формування витягу є результатом надання інформаційної послуги і має вигляд
окремого бізнес-процесу, якій ініціює користувач. Після формування витягу,
файл може бути збережено до обраної папки на пристрої користувача.

image:platform:user:citizen/excerpts/citizen-bp-get-excerpts-9.png[]

Отриманий витяг є доступним для подальшого завантаження та обробки.
Наприклад, для використання у системі документообігу.

image:platform:user:citizen/excerpts/citizen-bp-get-excerpts-10.png[]

[TIP]
====
Детальну інструкцію з описом функціональності ви можете переглянути за посиланням:

* xref:platform:user:citizen/citizen-get-excerpts.adoc[]
====

'''

=== Стилізація інтерфейсів користувача

==== Підтримка UI-тем в інтерфейсах Кабінетів

В рамках цього релізу ми розширили можливості використання різних UI-тем
в інтерфейсах кабінетів отримувачів послуг та кабінетів посадових осіб.

Тепер адміністратор має можливість обрати будь-яку з нижченаведених тем:

* Чорна тема:

image:release-notes:what’s-new-1.6-1.png[]

* Біла тема:

image:release-notes:what’s-new-1.6-2.png[]

==== Стилізація компонентів форм

Також ми реалізували стилізацію елементів інтерфейсів користувачів
(посадова особа та отримувач послуг) відповідно до стайл-гайду додатка "Дія" _(див. табл. “Оновлені компоненти інтерфейсів користувача”)_.

[#table-1]
.Оновлені компоненти інтерфейсів користувача
[cols="1, 2, 2"]
|===
|Компонент (форми задач)| Опис | Приклад
|Error Label | Компонент Error Label відображає валідаційні помилки для критичних компонентів на формах задач.  | image:release-notes:what’s-new-1.6-5.png[]
|Textfield | Компонент Textfield можна використовувати для введення короткого загального тексту. Є варіанти визначення масок введення та перевірки, що дозволяє користувачам формувати інформацію у потрібних форматах.| image:release-notes:what’s-new-1.6-6.png[]
|Textarea | Компонент Textarea має ті самі параметри, що й компонент форми Textfield. Різниця в тому, що Textarea — багаторядкове поле, яке дозволяє вводити довший текст.| image:release-notes:what’s-new-1.6-7.png[]
|Content | Компонент Content може бути доданий до форми для надання інформації, не пов’язаної з полями. Наприклад, якщо необхідно ввести інструкцію всередині самої форми, призначену лише для відображення. | image:release-notes:what’s-new-1.6-8.png[]
|Email | Компонент Email майже ідентичний з компонентом Textfield. Такий компонент має спеціальне налаштування перевірки, яке може гарантувати, що введене значення є дійсною адресою електронної пошти. | image:release-notes:what’s-new-1.6-9.png[]
|Select | Компонент Select відображає перелік значень у випадному списку. Залежно від типу компонента, користувачі можуть вибрати одне зі значень або декілька. | image:release-notes:what’s-new-1.6-10.png[]
|File upload | Компонент File upload дозволяє завантажити файл до системи. Залежно від налаштувань, можливе додавання обмеженої кількості файлів з вимогами до їх властивостей (тип, розмір файлу). | image:release-notes:what’s-new-1.6-11.png[]
|Date/time | Компонент Date/time можна використовувати для введення дати, часу або одночасно дати і часу. | image:release-notes:what’s-new-1.6-12.png[]
|EditGrid | Компонент EditGrid показує дані окремого запису в один ряд. Якщо таблиця за шириною більша, ніж ширина вікна, її можна прокрутити горизонтально. | image:release-notes:what’s-new-1.6-13.png[]
|Number | Компонент Number має бути обмежений типом числового значення. Має можливості налаштувань, щоб встановити роздільник тисяч, встановити десяткові розряди та ін. | image:release-notes:what’s-new-1.6-14.png[]
|===


'''

=== Налаштування зв'язку зі службою підтримки в Кабінетах посадової особи та отримувача послуг

Для розв'язання проблеми, яка може виникнути при виконанні бізнес-процесу,
ми розробили функціональність, що дозволяє звернутися до служби підтримки
через електронну пошту зі сторінки кабінету.

Це потребує виконання таких кроків:

* Налаштування електронної адреси служби підтримки;
* Відправлення повідомлення про помилку адміністратору служби підтримки.

Налаштування електронної адреси служби підтримки ::

У адміністратора регламенту існує можливість налаштовувати глобальні
змінні для конфігурування електронної адреси служби підтримки.
+
[TIP]
====
Детальну інформацію з описом налаштування глобальних змінних ви можете переглянути за посиланням:

* xref:registry-develop:bp-modeling/bp/global-vars.adoc[]
====

Відправлення повідомлення про помилку на Email служби підтримки ::

Зв'язок зі службою підтримки здійснюється за допомогою повідомлень.
Якщо при виконанні задачі у кабінеті користувача виникла критична помилка,
він надсилає повідомлення на електронну адресу служби підтримки.
+
[TIP]
====
Детальну інформацію з описом налаштування зв'язку зі службою підтримки в Кабінеті користувача ви можете переглянути за посиланням:

* xref:user:error-email-support.adoc[]
====
+
Процес відправлення повідомлення адміністратору служби підтримки є ідентичним
як для Кабінету посадової особи, так і для Кабінету отримувача послуг.

'''

== Інфраструктура

=== Control Plane

==== Вибір шаблону для створення нового реєстру

В рамках цього релізу ми запровадили можливість керування шаблонами реєстру з адміністративної панелі Control Plane.

Шаблон реєстру визначає параметри конфігурації та кількість інстансів для реєстру, що розгортається, тобто виділену кількість ресурсів (CPU, RAM тощо) та кількість нод в MachineSets.

Розгорнути реєстр в адмін-панелі Control Plane може лише адміністратор Платформи з відповідними правами доступу.

Після успішного встановлення Платформи у цільовому оточенні, адміністратор Платформи отримує доступ до адміністративної панелі керування Платформою і обирає новий шаблон з каталогу.

image:platform:admin:infrastructure/cluster-mgmt/cp-registry-deploy-5.png[]

[TIP]
====
Детальну інформацію з описом функціональності ви можете переглянути за посиланням:

* xref:admin:registry-management/control-plane-create-registry.adoc[]
====

'''

==== Вибір гілки для створення нового реєстру

В цьому релізі ми імплементували можливість обирати гілку шаблону реєстру з адміністративної панелі Control Plane.

При створенні нового екземпляру реєстру в панелі Control Plane, адміністратор платформи обирає гілку з випадного списку для його подальшого розгортання.

Версія гілки компонента у Gerrit-репозиторії містить збірку реєстру відповідної версії.

image:platform:admin:infrastructure/cluster-mgmt/cp-registry-deploy-7.png[]

[TIP]
====
Детальну інформацію з описом функціональності ви можете переглянути за посиланням:

* xref:admin:registry-management/control-plane-create-registry.adoc[]
====

'''

==== Оновлення інфраструктурних компонентів Платформи через Control Plane

Ми запровадили можливість оновлення інфраструктурних компонентів Платформи в інтерфейсі адміністративної панелі керування кластером та реєстрами Control Plane.

Адміністрування кластера Платформи відбувається за підходом GitOps. Це означає, що будь-які зміни у конфігурації кластера, компонентів кластера та компонентів Платформи відбуваються через внесення змін до конфігурації відповідних компонентів у git-гілках цих компонентів.

Кожен компонент є окремим git-репозиторієм. Метадані усіх інфраструктурних компонентів, для яких реалізована можливість управління через GitOps-підхід, зберігаються в компоненті cluster-management.

Нижче представлено список компонентів, для яких наразі імплементована можливість оновлення через GitOps-підхід:

* catalog-source;
* storage;
* monitoring;
* logging;
* service-mesh;
* velero;
* control-plane-nexus;
* user-management.

Після виконання попередніх кроків за xref:admin:update/update_cluster-mgmt.adoc[інструкцією], адміністратор обирає версію, до якої необхідно оновити компоненти платформи.

image:admin:infrastructure/cluster-mgmt/cluster-mgmt-update.png[]

Процес оновлення можна умовно поділити на такі етапи:

. Налаштування в адміністративній панелі керування кластером та реєстрами Control Plane.
. Проходження процедури перевірки коду в системі рецензування коду Gerrit.
. Контроль за виконанням збірки коду в Jenkins.

[TIP]
====
Детальну інформацію щодо оновлення Платформи у Control Plane ви можете переглянути за посиланням:

* xref:admin:update/update_cluster-mgmt.adoc[Оновлення інфраструктурних компонентів Платформи]
====

'''

==== Оновлення компонентів реєстру через Control Plane

Ми реалізували функціональність, яка дозволяє оновлювати компоненти реєстру в інтерфейсі адміністративної панелі керування кластером та реєстрами Control Plane.

Оновлення реєстру відбувається за підходом GitOps: будь-які зміни у конфігурації реєстру, або його компонентах відбуваються через внесення змін до конфігурації  компонента у git-гілці цього компонента. Кожен компонент є окремим git-репозиторієм.

[CAUTION]
====
Оновлення компонентів реєстру можна виконати лише після попереднього оновлення компонентів Платформи.
====

Після виконання попередніх кроків за xref:admin:update/update-registry-components.adoc[інструкцією], адміністратор має обрати версію, до якої необхідно оновити компоненти реєстру:

image:admin:infrastructure/update-registry-components/update-registry-components-6.png[]

Процес оновлення можна умовно поділити на такі етапи:

. Налаштування в адміністративній панелі керування кластером та реєстрами Control Plane.

. Проходження процедури перевірки коду в системі рецензування коду Gerrit.

. Контроль за виконанням збірки коду в Jenkins.


[TIP]
====
Детальну інформацію щодо оновлення компонентів реєстру через Control Plane ви можете переглянути за посиланням:

* xref:admin:update/update-registry-components.adoc[]
====

'''

==== Горизонтальне масштабування бази даних реєстру

У цьому релізі ми запровадили можливість горизонтального масштабування бази даних реєстру із використанням підходу шардингу БД (поділ бази даних на окремі частини). Це дозволяє винести кожну частину бази даних на окремий сервер в процесі масштабування.

Для цього ми провели міграцію з продукту *Citus* і перейшли до використання сервісу *pgPool*. Це сервіс, що дає можливість кластеризувати БД, створювати репліки та балансувати навантаження між read-нодами. Сервіс керує кількістю підключень до бази даних реєстру та дозволяє налаштовувати цю кількість, використовуючи власний пул підключень (конектів).

При масштабуванні використовується 2 типи нод: *Master* та *Replica*:

* *Master-ноди (Master DB) PostgreSQL* призначені лише для операцій запису даних і виконують роль мастера реплікації.
* *Ноди типу Replicа (Replicа DB) PostgreSQL* підтримують лише читання даних і виконують роль репліки, отримуючи дані з мастер-ноди в синхронному режимі. Для нод такого типу налаштовується горизонтальне масштабування.

Інструмент *pgPool* також підтримує транзакційність запитів. Це дозволяє переадресовувати запити на читання та запис даних до різних сервісів для балансування навантаження між нодами. Зокрема, *pgPool* підтримує переадресацію трафіку з репліки до мастер-ноди в рамках операцій транзакції, якщо це необхідно.

Наприклад, операція `SELECT` опрацьовується реплікою, в той час, як `UPDATE` має опрацювати мастер-нода. В рамках транзакції трафік автоматично перемикається із репліки до мастер-ноди, де і продовжується транзакція.

image:admin:infrastructure/postgres_cluster.svg[]

[TIP]
====
Детальну інформацію з описом горизонтального масштабування бази даних реєстру ви можете переглянути за посиланням:

* xref:admin:scaling/db_scaling.adoc[]
====

'''

==== Резервне копіювання Control Plane

В рамках цього релізу ми розробили функціональність, яка дозволяє виконувати резервне копіювання та відновлення компонентів адміністративної панелі керування кластером та реєстрами *Control Plane*. Це надає можливість створювати бекапи (резервні копії) компонентів адмін-панелі та відновлюватися із таких резервних копій.

До таких компонентів *Control Plane* відносяться:

* control-plane-console;
* control-plane-gerrit;
* control-plane-jenkins.

Також функціональність забезпечує можливість резервного копіювання та відновлення списку наявних реєстрів та їх компонентів.

Функціональність надалі буде розширюватися, тобто кількість компонентів у *Control Plane* зростатиме, а звідси і розширюватимуться можливості для бекапування та відновлення.

'''

=== Installer

==== Автоматичне розгортання компонента Minio

В рамках цього релізу, ми запровадили автоматичне розгортання компонента Minio (сховище резервних копій) за допомогою інструмента *Terraform IaC (Inrastructure as Code)*.

*HashiCorp Terraform* є програмним забезпеченням з відкритим вихідним кодом. Воно дозволяє декларативно описувати інфраструктуру за допомогою прийнятних для людини конфігураційних файлів.

Ресурси *Terraform* забезпечують однорідне та автоматичне розгортання компонента *Minio* для різних Cloud-провайдерів. Використання *Terraform* забезпечує ідемпотентність поведінки створення, запуску та конфігурування компонентів у відповідному Cloud-провайдері.

==== Автоматичне розгортання компонента Vault

Ми реалізували також інтеграцію з *Terraform IaC* для автоматичного розгортання компонента *Vault* (сховище секретів для зберігання токенів доступу, паролів користувачів тощо). Використання *Terraform* забезпечує автоматизацію та однорідність розгортання компонента *Vault*. Створення, запуск та конфігурування компонента описано в коді.

==== Додавання окремого конфігураційного файлу для розгортання в середовищі vSphere

В рамках цього релізу ми розробили окремий конфігураційний файл, якій полегшує підготовку до розгортання Платформи в середовищі провайдера *vSphere*.

У цьому файлі адміністратор Платформи вказує усі необхідні налаштування для доступу до Cloud-провайдера *vSphere*. Файл зберігається в архіві *Nexus* разом з інсталяційним скриптом для розгортання Платформи. Він адаптує Installer під конкретне середовище *vSphere*, в якому розгортається Платформа.










