== Забезпечення одночасної роботи декількох користувачів над однією версію-кандидатом

=== Проблеми link:gitflow-description.adoc[існуючого рішення]
- Втрата внесених змін користувачами при одночасній роботі декількох користувачів над однією сутністю в рамках однієї версії-кандидату
- Можлива неконсистентність файлів на файловій системі в момент виконання _git_ операцій (наприклад `git rebase`) при одночасній роботі декількох екземплярів admin-portal backend сервісу з одним persistent volume

=== Варіанти вирішення проблеми

==== Pessimistic locks

Даний підхід передбачає заборону (отримання _lock_) на зміну файлів в окремій директорії, якщо наразі інший користувач редагує будь-яку сутність в даній директорії.

image::lowcode/admin-portal/regulation-repository/git/git-pessimistic-lock.svg[]

[NOTE]
Адміністратори реєстру не взаємодіють з файловою системою як такою. Всі зміни відбуваються шляхом взаємодії з `admin-portal backend service` через RestAPI.

[NOTE]
Технічна реалізація lock для файлів на файловій системі не розглядається в рамках даного документу


Користувач, що намагається провести редагування файлу, що знаходиться в області дії _lock_, буде отримувати помилку відповідне повідомлення від _backend_ сервісу і має чекати доки попередній користувач закінчить роботу за файлами в області дії _lock_.

[TIP]
Область lock може бути технічно зменшена до окремих файлів на файловій системі.

===== Pros
- Не потребує кардинальної зміни існуючого механізму взаємодії з _git repositories_

===== Cons
- Потребує інтеграції з додатковим компонентом для збереження інформації про _locks_ або розробки окремого контракту та механізму як зберігати дану інформацію на файловій системі (use transaction manager over Filesystem)
- Потребує розробки механізму єдиного `lock registry` для декількох екземплярів `admin-portal backend service`

==== Optimistic locks

Даний підхід передбачає використання певного ключа (наприклад hash сума контенту файлу, до початку його редагування користувачем) при відправці відредагованого контенту файлу на _backend_ сервіс. Під час збереження нового контенту файлу буде проводитись перевірка _optimistic locking key_, отриманого від користувача на відповідність файлу на файловій системі. Якщо ключ не відповідає файлу, то зміни користувача не будуть збережені і користувач отримає інформацію про це (http error code )

[CAUTION]
Використання в якості `optimistic locking key` дати останніх змін неможливе так як дата на файловій системі останньої зміни файлу буде завжди відрізнятися від актуальної дати зміни файлу одразу після `git clone`.

image::lowcode/admin-portal/regulation-repository/git/git-optimistic-lock.svg[]

===== Pros
- Не потребує додаткових інтеграцій з новими системами або компонентами
- Не потребує зміни контракту структури git репозиторіїв на файловій системі

===== Cons
- Потребує явної роботи з `optimistic locking keys` під час взаємодії з RestAPI (додає більше складність інтеграції з `admin-portal backend service`)
- Потребує допрацювання існуючого коду `admin-portal frontend`


==== Optimistic locks via HTTP Conditional Requests

Optimistic locking підхід може бути розроблений шляхом використання link:https://www.rfc-editor.org/rfc/rfc7232#section-2.3[ETag http header approach].

Кожен RestAPI ресурс буде маркуватись контрольною сумою в ETag http_header в Response, що відправляється клієнту.
Кожен PUT або DELETE запит буде маркуватись попередньо отриманим ETag та link:https://www.rfc-editor.org/rfc/rfc2616.html#page-129[If-Match] інструкцією. Сервер в такому випадку перевірятиме наявність ресурсу з відповідним ID, що той також має контрольну суму, що відповідає значенню в ETag, перед виконанням самої операції над сутністю. Якщо ресурс на момент оримання PUT або POST змінився, котнорльна сума не співпаде і така операція буде відхилена з 412 http status code.

[plantuml, db-tables-management-sequence, svg]
----
include::partial$lowcode/admin-portal/regulation-repository/git-optimistic-locking-etag.puml[Git optimistic locking]
----

===== Pros
- Потребує лише часткової зміни RestAPI контракту (робота з додатковими http headers)
- Використовується стандартизований підхід для забезпечення optimistic locking задокументований в link:https://www.rfc-editor.org/rfc/rfc2616.html#page-126[RFC-2616: Hypertext Transfer Protocol -- HTTP/1.1]
- Використання стандартизованого підходу дозволяє використовувати існуючі технічні інструменти для роботи з http conditional requests (для spring boot).
- Optimistic locking відбувається на рівні запитів Rest Controllers, та не потребує додаткової обробки на рівні сервісів

[NOTE]
TODO: will be an issue in a case of service scaling?

===== Cons
Якщо HTTP Request не буде мати ETag http header, то це дозволить йому змінити існуючий ресурс навіть, якщо він був уже кимось змінений раніше (відбудеться затирання одних змін іншими).

[TIP]
Дана поведінка може бути змінена технічним шляхом, але це суперечитиме контракту використання ETag описаному в RFC.

[NOTE]
Якщо клієнт буде використовувати у всіх PUT та DELETE запитах ETag то це забезпечить optimistic locking на рівні RestAPI.

==== Окремий репозиторій на файловій системі для кожного користувача в розрізі кожної версії-кандидату

===== Основні сутності, використанні при побудові рішення
- Scheduled jobs
- Зміни, що ініційовані адміністратором регламенту реєстру
- Репозиторії та бранчі на файловій системі
- Репозиторії та бранчі в Gerrit

===== Огляд переліку репозиторіїв на файловій системі та переліку scheduled jobs

image::lowcode/admin-portal/regulation-repository/git/git-summary.svg[]

Іменування репозиторіїв та бранчів має наступний формат:

- vc1 - версія-кандидат 1
- vc1u1 - репозиторій версії-кандидату 1 для користувача 1
- MR1 - Merge request для версії-кандидату 1
- vc1u1_merge - __merge_ репозиторій для репозиторію vc1u1

Репозиторії на файловій системі розподілені на декілька груп (spaces):

- User changes space: репозиторії для збереження змін від певного користувача в рамках змін певної версії-кандидату
- Version candidate space: репозиторії для збереження всіх змін для певної версії-кандидату
- Gerrit MR space: репозиторії для забезпечення оновлення Merge Request в Gerrit до актуального стану відносно репозиторіїв файлової системи
- Backup space: резервне збереження змін з репозиторіїв файлової системи в будь-який git сервіс
- MR Zone: Merge

Основні принципи організації роботи з локальними репозиторіями на файловій системі

- Кожна група може мати певну кількість локальних репозиторіїв (git clone)
- Кожен репозиторій на файловій системі може оперувати одним або більше git branch
- В репозиторіях, зміни в котрих можуть мати конфлікти, винесені в окремі локальні репозиторії с суфіксом __merge_

===== Changes Push flow: отримання та збереження змін

image::lowcode/admin-portal/regulation-repository/git/git-push-flow.svg[]

- Адміністратор регламенту реєстру отримує та зберігає зміни шляхом взаємодії з відповідним локальним репозиторієм в User changes space
- Адміністратор регламенту реєстру отримує інформацію про конфлікти з окремого відповідного репозиторію на файловій системі ( __merge_ репозиторій)
- Адміністратор регламенту реєстру отримує метадані про версію-кандидат з Gerrit MR

===== Changes synchronisation flow: синхронізація змін між локальними репозиторіями та отримання переліку конфліктних змін

image::lowcode/admin-portal/regulation-repository/git/git-sync-flow.svg[]

- Кожен репозиторій, який може бути актуалізований змінами з другого репозиторію, має додатковий репозиторій, через який виконується актуалізація змін ( __merge_ репозиторій)
- __merge_ репозиторій оновлюється періодично in scheduled manner.
- Якщо __merge_ репозиторій не має конфліктів, то відповідний user changes репозиторій є успішно актуалізованим
- Якщо __merge_ репозиторій має конфлікти, то відповідний user changes репозиторій є успішно актуалізованим до стану, коли зміни користувача не конфліктували зі змінами в версії-кандидаті (на момент визову synchronisation job)

[TIP]
Можна виділити окремий компонент для забезпечення sync функціональності - Changes Synchronisation Task

image::lowcode/admin-portal/regulation-repository/git/git-sync-component.svg[]

* В механізмі задіяні три git репозиторії:
** local - branch на локальній файловій системі, в котрий можуть вноситись зміни
** remote - віддалений branch, котрий використовується як `remote origin` для local репозиторію
** local_merge - branch що використовується для отримання інформації про конфлікти між local та remote репозиторіями

[CAUTION]
Механізм не лімітує розділення бранчів між репозиторіями. Наприклад бранчі local та remote можуть знаходитись в одному локальному репозиторії.

===== Backup flow: резервне збереження репозиторіїв в remote git

image::lowcode/admin-portal/regulation-repository/git/git-backup-flow.svg[]

[IMPORTANT]
Для забезпечення резервного копіювання змін з user changes space буде використовуватись remote git (gerrit).
Механізм резервного копіювання може бути сконфігурований на використання будь-якого git instance (включаючи будь-який git applicable транспорт протокол)

- Технічно backup механізм це виклик git push backup <branch name>, якщо  backup remote origin заданий в репозиторії
- Один backup job instance буде забезпечувати backup всіх репозиторіїв

===== Squash flow: синхронізація змін в Gerrit
image::lowcode/admin-portal/regulation-repository/git/git-squash-flow.svg[]

Squash flow забезпечує оновлення Merge Request в Gerrit згідно змінам м відповідному локальному репозиторії в Version candidate space

- Оновлення змін відбувається в односторонньому порядку (з локального репозиторію в MR)
- Всі зміни, що були зроблені в локальному репозиторії version candidate space в декількох окремих commit, будуть об'єднані в один commit
- Під час оновлення відбувається `git commot --amend`. Якщо MR буде мати зміни, що не є частиною змін з локального репозиторію, вони будуть втрачені під час ції операції

===== Cleanup flow: видалення репозиторіїв, робота з якими завершена

image::lowcode/admin-portal/regulation-repository/git/git-cleanup-flow.svg[]

Repository spaces та remote repositories, що потребують housekeeping

- user changes space
- version candidate changes space
- squash space
- backup space (remote branches)

[NOTE]

TODO: алгоритм отримання переліку репозиторіїв, що потребують видалення, буде розробелно окремо

[CAUTION]
Need to invent mechanism how to synchronise cleanup job, sync job and backup job