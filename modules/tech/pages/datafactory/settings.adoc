= Налаштування Кабінету отримувача послуг реєстру

== Загальний опис

Для забезпечення вимог по управлінню налаштуваннями, платформа підтримує наступні канали зв'язку:

** *email*
** *diia*
** *inbox*

Особливістю _inbox_ каналу зв'язку є те, що він буде активований за замовчуванням, а також користувач не зможе редагувати, деактивувати або якимось іншим чином налаштовувати цей канал.
Іншими словами, робота з _inbox_ каналом не є предметом даної статті

== Функціональні сценарії

- пошук налаштувать користувача за довільним ідентифікатором користувача
- пошук налаштувань користувача за ідентифікатором користувача, отриманим з токена доступу
- активація каналу зв'язку шляхом введення / оновлення даних про атрибути каналу (наприклад, email адреса)
- деактивація каналу зв'язку
- первинна валідація введених налаштувань користувача (за патерном email, відсутністю в blacklist тощо)

== Ролі користувачів

- _Користувач кабінету громадянина_

== Базові принципи

* Користувач має право змінювати лише власні налаштування
* Отримувати налаштування користувача може користувач, якому належать ці налаштування, або система (для змоги надсилати повідомлення користувачам на обрані ними канали зв'язку)
* Користувач може змінити налаштування каналу зв'язку
* Користувач може активувати канал, змінивши адресу для каналу
* Користувач може деактивувати канал
* Користувач може мати лише один канал кожного типу

== Низькорівневий дизайн рішення
Налаштування Кабінету отримувача послуг реєстру є частиною Платформи і розгортаються незалежно від регламенту.

image::datafactory/settings.svg[]

NOTE: При імплементації роботи з каналами зв'язку було змінено дизайн _Сервісу налаштувань_. Основна зміна полягає в тому, що сервіси _user-settings-service-api_ та _user-settings-service-persistence_ об'єднані в один сервіс _user-settings-service_.

=== Міграція на нове рішення

Необхідні кроки при міграції

- змінити ім'я сервіса налаштувань на _user-settings-service_
- в усіх місцях, де використовується стара адреса сервіса налаштувань, змінити її на нову (виклики з _Кабінету користувача_, _bpms_, _Сервісу відправки повідомлень_)
- виправити назву сервіса налаштувань всюди, де вона використовується (для усіх мережевих політик, деплойментів, конфігурацій, секретів тощо)

- декомісувати сервіс _user-settings-service-persistence_, усі пов'язані з ним деплойменти, секрети, конфігмапи тощо

- видалити наступні kafka-топіки:

-- _read-settings-inbound_

-- _read-settings-outbound_

-- _update-settings-inbound_

-- _update-settings-outbound_

-- _read-settings-by-keycloak-id-inbound_

-- _read-settings-by-keycloak-id-outbound_

-- .DLT топіки для усіх перерахованих _*-inbound_

== Компоненти системи та їх призначення в рамках дизайну рішення

У даному розділі наведено перелік компонент системи, які задіяні або потребують змін/створення в рамках реалізації функціональних вимог згідно технічного дизайну рішення.

|===
|Компонент|Службова назва|Призначення

|_Сервіс управління налаштуваннями користувачів_
|*user-settings-service*
|Отримання та зміна налаштувань каналів зв'язку, обраних користувачем

|_Розподілена реляційна база даних Citus_
|*citus-master*
|Довготривале збереження налаштувань каналів зв'язку користувачів на цільовому оточенні реєстру

|_Розподілений брокер повідомлень Kafka_
|*kafka*
|Асинхронне відправлення аудит-повідомлень про зміни в каналах зв'язку

|_Сервіс управління Avro-схемами опису структур даних_
|*kafka-schema-registry*
|Збереження Avro-схеми опису структури даних значущих подій аудиту

|===

== Налаштування політик міжсервісної взаємодії

Для коректної роботи сервісу налаштувань, мають бути налаштовані відповідні мережеві політики _NetworkPolicy_, які дозволяють взаємодію для наступних компонентів:

- *user-settings-service* -> *citus-master*
- *user-settings-service* -> *kafka*
- *user-settings-service* -> *kafka-schema-registry*

== Сервіс для доступу до налаштувань

=== Операції з налаштуваннями
Всі операції вимагають аутентифікацію.
Для операцій, які вимагають перевірки належності користувачу даних, які він хоче отримати, використовується перевірка keycloak_id який передається в JWT токені у полі *subject*.

=== Отримання користувачем налаштувань, що йому належать

*GET /api/settings/me* (X-Access-Token)

.Приклад відповіді:

[source, json]
----
{
  "settings_id":  "uuid",
  "channels": [
    {
        "channel": "email",
        "activated": "true",
        "address": "user@domain.com",
        "deactivation_reason": "some reason"
    }
  ]
}
----

.Коди відповіді
|===
|Код|Опис

a|[green]#200#
|OK
a|[red]#400#
|Некоректно сформований запит
a|[yellow]#401#
|Помилка автентифікації (відсутній токен доступу)
a|[yellow]#404#
|Дані не знайдено
a|[red]#500#
|Серверна помилка обробки запиту
|===

=== Отримання налаштувань для деякого користувача

*GET /api/settings/{keycloakUserId}*

.Приклад відповіді:

[source, json]
----
{
  "settings_id":  "uuid",
  "channels": [
    {
        "channel": "email",
        "activated": "true",
        "address": "user@domain.com",
        "deactivation_reason": "some reason"
    }
  ]
}
----

.Коди відповіді
|===
|Код|Опис

a|[green]#200#
|OK
a|[red]#400#
|Некоректно сформований запит
a|[yellow]#401#
|Помилка автентифікації (відсутній токен доступу)
a|[yellow]#404#
|Дані не знайдено
a|[red]#500#
|Серверна помилка обробки запиту
|===

CAUTION: приклад {channelName} - email, diia, inbox

=== Активація каналу зв'язку


*POST /api/settings/me/channels/{channel}/activate*

Активація каналу зв'язку для користувача, створення налаштувань для каналу, якщо вони ще не існують

.Приклад запита
[source, json]
----
{
    "address": "user@domain.com"
}
----

.Коди відповіді
|===
|Код|Опис

a|[green]#200#
|OK
a|[red]#400#
|Некоректно сформований запит
a|[yellow]#401#
|Помилка автентифікації (відсутній токен доступу)
a|[red]#500#
|Серверна помилка обробки запиту
|===

=== Деактивація каналу зв'язку

*POST /api/settings/me/channels/{channelName}/deactivate*

.Приклад запита

[source, json]
----
{
  "deactivationReason": "<deactivation reason enum: [USER_DEACTIVATED|SYSTEM_DEACTIVATED|BLACKLIST_DEACTIVATED]> + some message"
}
----

.Коди відповіді
|===
|Код|Опис
a|[green]#200#
|OK
a|[red]#400#
|Некоректно сформований запит
a|[yellow]#401#
|Помилка автентифікації (відсутній токен доступу)
a|[red]#500#
|Серверна помилка обробки запиту
|===

=== Попередня валідація даних каналу
[TIP]
Валідація адреси на унікальність / blacklist / патерн / тощо

*POST /settings/me/channels/{channel}/validate*

.Приклад запита
[source, json]
----
{
    "address": "<email>"
}
----

.Приклад успішної відповіді
[source, json]
----
{}
----

.Приклад відповіді з помилкою валідації
[source,json]
----
{
    "traceId": "string",
    "code": "string",
    "message": "string",
    "localizedMessage": "string"
}
----

.Коди відповіді
|===
|Код|Опис
a|[green]#200#
|OK
a|[red]#400#
|Некоректно сформований запит
a|[yellow]#401#
|Помилка автентифікації (відсутній токен доступу)
a|[yellow]#422#
|Помилка валідації
a|[red]#500#
|Серверна помилка обробки запиту
|===

== Взаємодія компонентів в рамках реалізації сценаріїв

[plantuml, settings_citizen, svg]
----
include::partial$datafactory/settings_sequence.puml[]
----

== Фізична модель зберігання даних

[NOTE]
У випадку необхідності введення статусу/ролі користувача таблиця "subject_settings" може бути розширена відповідними полями.

[plantuml]
----
@startuml
skinparam monochrome true
left to right direction

namespace registry {
object "Subject" as s  {
  id: uuid <<generated>>
  ...
}

object "subject_settings" as sp {
  id: uuid <<generated>>
  subject_id: uuid
  settings_id: uuid
}
}

namespace platform {

object "settings" as settings  {
  id: uuid <<generated>>
  keycloak_id: uuid
}

object "channels" as channels  {
  id: uuid <<generated>>
  settings_id: uuid <<FK>>
  channel: enum
  address: text
  deactivation_reason: text
  is_activated: boolean
  created_at: timestamp
  updated_at: timestamp
}

}

s ||--|| sp
sp ||--|| settings
channels }|--|| settings

@enduml
----


=== Структура даних _SETTINGS_

|===
|Поле|Тип|Обмеження|Значення за замовчуванням|Опис

|*ID*
|UUID
|Primary Key
|_uuid_generate_v4()_
|Унікальний автоматично згенерований ідентифікатор запису
|*KEYCLOAK_ID*
|UUID
|Not Null
|-
|Зовнішній ідентифікатор користувача в keycloak

|===

=== Структура даних _CHANNELS_

|===
|Поле|Тип|Обмеження|Значення за замовчуванням|Опис

|*ID*
|UUID
|Primary Key
|_uuid_generate_v4()_
|Унікальний автоматично згенерований ідентифікатор запису
|*SETTINGS_ID*
|UUID
|Foreign Key, Not Null, Unique Constraint with *CHANNEL*
|-
|Ідентифікатор запису в settings
|*CHANNEL*
|ENUM
|Not Null, Unique Constraint with *SETTINGS_ID* _[email,diia,messenger]_
|-
|Назва каналу зв'язку для використання шаблону повідомлення
|*ADDRESS*
|TEXT
|-
|-
|Адреса для відправлення повідомлень
|*DEACTIVATION_REASON*
|TEXT
|-
|-
|Причина попередньої деактивації каналу
|*IS_ACTIVATED*
|BOOLEAN
|Not Null
|false
|Чи активований даний канал
|*CREATED_AT*
|TIMESTAMP
|Not Null
|_now()_
|Дата/Час створення запису
|*UPDATED_AT*
|TIMESTAMP
|Not Null
|_now()_
|Дата/Час оновлення запису


|===

== Ролі/системні користувачі БД

Для обслуговування операцій взаємодії з БД, необхідно створити ролі/користувачів з визначеними правами доступу для використання відповідними компонентами системи:

|===
|Компонент системи|Роль/Користувач|Привілегії

|*settings-service*
|_settings_role_
|_GRANT SELECT, INSERT, UPDATE, DELETE ON SETTINGS_

|*settings-service*
|_settings_role_
|_GRANT SELECT, INSERT, UPDATE, DELETE ON CHANNELS_
|===

== Фіксація подій зміни статусу каналу у журналі аудиту системи

Події активації/деактивації каналів зв'язку користувачами фіксуються у журналі аудиту з повним контекстом. Для реалізації вимоги необхідно розширити підсистему аудиту наступним чином:

* Розширити перелік службових операцій:
** _USER_NOTIFICATION_CHANNEL_ACTIVATION_

[NOTE]
Детальніше з дизайном підсистеми "_Журнал аудиту_" можна ознайомитися
xref:datafactory/audit.adoc[за посиланням]

=== Структура події аудиту

Нижче наведено xref:datafactory/audit.adoc#_події[структуру події аудиту] та її відповідність структурі та значенням отриманого через Kafka-топік повідомлення про необхідність відправки нотифікації користувачу.

==== Структура контексту події аудиту

[source, json]
----
{
  "channel": "email",
  "action": "activate",
  "address": "email@email.com"
}
----

==== Kafka
.Приклад налаштувань сервісу для публікації подій аудиту через Kafka-топік (на прикладі використання *ddm-starter-audit* бібліотеки)
[source, yaml]
----
audit:
  kafka:
    topic: audit-events
    schemaRegistryUrl: http://kafka-schema-registry:8081
----
