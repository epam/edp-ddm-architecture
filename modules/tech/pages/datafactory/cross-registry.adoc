= Міжреєстрова взаємодія без Трембіта

Задля зменшення надлишкового використання обчислювальних потужностей, зовнішнього трафіка та часу відповді при інтеграції між реєстрами без використання Трембіта.
Виділяється два сценарії використання інтероперабельності реєстрів.

* За умови що реєстри належать одному клієнту, є спорідненими (Група реєстрів)
* Реєстри знаходяться на одній платформі належать різним клієнтам (Інтеграція на рівні платформи)

== Група реєстрів

Для реєстрів, що належать до одного клієнта використовується додатково створений спільний `realm` але окремі `client` в
Keycloak для Kong. Спільний `realm` використовується як `identity provider` для `realm`-ів реєстрів цієї групи, тобто створення користувачів, керування ролями відбувається в спільному груповому  `realm`-і, а не в  `realm`-ах окремих реєстрів. Таким чином забезпечується можливість створення спільних користувачів і таким же чином забезпечується можливість доступу до даних через API.
Конфігурація та вибір `realm` відбувається на рівні розгортання реєстру в Control Plane через абстракцію `RegistryGroup`. Будь-який реєстр може належати тільки до однієї групи. Створений реєстр не може бути включений до групи

RegistryGroup - являє собою окремий K8s ресурс який зберігає в собі комбінацію назв `realm`-ів.

image::tech:datafactory/regestry-group.svg[]

== Інтеграція на рівні платформи

image::datafactory/cross-registry.svg[]

Gateway - є окремим компонентом на основі Spring Cloud Gateway з вбудованими фільтрами для динамічної валідації JWT токенів в залежності від `realm`-у

=== Аутентифікація на gateway

[plantuml, auth, svg]
----
skinparam monochrome true
actor "Користувач \nіншого реєстра" as user
participant "Kong" as kong
participant "Gateway" as gate
participant "REST API" as rest
participant "Keycloak" as key
user -> kong: запит до ендпоінта з \nтокеном від іншого реєстра
kong -> gate: проксі запит
gate -> key: отримання публічного ключа для валідація токена \n(за внутрішньою адресою Keycloak)
gate -> gate: програмна валідація токена\n на підставі реалму з токена

gate -> key: отримання токена відповідного сервіс акаунта
return
gate -> gate: заміна access-токена
gate -> rest: запит до дата фабрики
return
gate --> kong
kong --> user: дані реєстра отримані без трембіти
----

=== Моделювання

==== Реєстр тримач даних

1) Надання доступу через створення `service account` в `Keycloak`
подібно до створення  `service account` для xref::lowcode/trembita/consumers.adoc[інтеграції з Трембіта]

[plantuml, structure, svg]
----
@startsalt
{
{T
+ <&folder> registry-regulations
++ <&folder> bpmn
++ <&folder> dmn
++ ...

++ <&folder> external-systems
+++ <&file> trembita.yml
+++ <&file> platform.yml
+++ ...
}
}
@endsalt
----



2) Налаштування `Rate limits` через панель адміністратора реєстра `Control Plain`

==== Реєстр клієнт
Використовує посилання абсолютні посилання з створеним для нього ім`ям в основі як префікс до існуючих в реєстрі тримачі ресурсів.





